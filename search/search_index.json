{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Guides","text":"<p>Welcome! You've discovered the Guides section!</p> <p>Here, you'll embark on a journey through the magical realm of tutorials. Explore and uncover the secrets of this enchanted domain!</p> <p>Or go back to our Homepage</p>"},{"location":"#vitruatop","title":"vitrua.top","text":""},{"location":"Kubernetes%20Dungeon/01_Pods/","title":"The Pod","text":""},{"location":"Kubernetes%20Dungeon/01_Pods/#objective","title":"Objective","text":"<p>Learn the basic configuration of a Kubernetes pod by observing a cute dragon pod.</p>"},{"location":"Kubernetes%20Dungeon/01_Pods/#storytime","title":"Storytime","text":"<p>In the mystical realm of Vitrua, there dwelled a revered scientist whose companion was a venerable dragon in the twilight of its existence. Determined to extend the dragon's waning years, the scientist delved into the arcane arts of longevity. Initially, he succeeded in encapsulating the essence of the dragon within a mesmerizing image, a tapestry of intricate layers. However, it was only when this image was ensconced within a container, a mystical orb, that true transformation occurred, imbuing the dragon with a vitality beyond its natural state.</p> <p>The dragon was still sad, as it had troubles interacting with the external world from it's container, so the scientist had to find a solution to facilitate the dragon's interaction with the world outside its confines. Through relentless experimentation, he devised a remarkable exoskeleton using a deceptively simple engineering blueprint:</p>"},{"location":"Kubernetes%20Dungeon/01_Pods/#pod-basic-yaml","title":"Pod basic yaml","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: dragon-pod\n  labels:\n    type: dragon-app\nspec:\n  containers:\n  - name: dragon-container\n    image: dragon-image:latest\n    ports:\n    - containerPort: 443\n      protocol: TCP\n</code></pre>"},{"location":"Kubernetes%20Dungeon/01_Pods/#components-explanation","title":"Components explanation","text":"<p>The scientist has made quite the simple but effective blueprint. Let's break down the YAML structure:</p> <ol> <li> <p><code>apiVersion: v1</code>: This line specifies the API version being used to ensure compatibility with the cluster, which in this case is version 1 of the Kubernetes API. It's analogous to specifying the version of a software application.</p> </li> <li> <p><code>kind: Pod</code>: Here, a Kubernetes Pod is being defined. A Pod is the smallest deployable unit in Kubernetes, representing a single instance of a running process. This Pod likely encapsulates the environment for the dragon's consciousness and interaction.</p> </li> <li> <p><code>metadata</code>: This section provides metadata about the Pod, including its name and labels.</p> <ul> <li> <p><code>name: dragon-pod</code>: This line specifies the name of the Pod, which is \"dragon-pod\". This name is how Kubernetes will refer to and manage this specific instance of the Pod.</p> </li> <li> <p><code>labels</code>: Labels are key-value pairs used to organize and select subsets of objects in Kubernetes. Here, the Pod is labeled with <code>type: dragon-app</code>, indicating that it belongs to a category of applications related to dragons.</p> </li> </ul> </li> <li> <p><code>spec</code>: This section specifies the desired state for the Pod, including its containers and their configuration.</p> <ul> <li> <p><code>containers</code>: This subsection defines the containers that should be launched within the Pod.</p> <ul> <li> <p><code>name: dragon-container</code>: This line assigns a name to the container within the Pod. In this case, it's named \"dragon-container\", representing the vessel for the dragon's consciousness.</p> </li> <li> <p><code>image: dragon-image:latest</code>: Here, the image for the container is specified. The container will be created using the Docker image named \"dragon-image\" with the tag \"latest\". This image likely contains the necessary software and environment for the dragon's consciousness to operate within the container.</p> </li> <li> <p><code>ports</code>: This subsection specifies the ports that should be exposed by the container.</p> <ul> <li> <p><code>- containerPort: 443</code>: This line indicates that the container should expose port 443, which is commonly used for HTTPS traffic. In the story, this port might be used for communication or interaction between the dragon and external systems.</p> </li> <li> <p><code>protocol: TCP</code>: This line specifies the protocol to be used for communication on the exposed port. In this case, it's TCP (Transmission Control Protocol), a common protocol used for reliable communication over networks.</p> </li> </ul> </li> </ul> </li> </ul> </li> </ol> <p>Overall, this YAML file describes the configuration for a Kubernetes Pod named \"dragon-pod\", which contains a single container named \"dragon-container\" running the \"dragon-image\" Docker image. The container exposes port 443 for TCP communication, likely facilitating interactions between the dragon's consciousness and external systems in the Land of Vitrua.</p>"},{"location":"Kubernetes%20Dungeon/02_Services/","title":"Services: ClusterIp, NodePort, LoadBalancer, ExternalName","text":""},{"location":"Kubernetes%20Dungeon/02_Services/#objective","title":"Objective","text":"<p>Learn and get practice with the different types of kubernetes services.</p>"},{"location":"Kubernetes%20Dungeon/02_Services/#story-time","title":"Story time","text":"<p>Once upon a time, three intrepid souls roamed the land: Brave Ben, Resourceful Rina, and Fearless Fred. One fateful day, they set their sights on the legendary Cluster Castle, a fabled dungeon rumored to conceal secrets of immense power and knowledge.</p> <p>Approaching the castle's entrance, they resolved to compete in their quest for the coveted treasures within. Each determined to claim the prized bounty first.</p> <p>As they ventured forth, they diverged onto separate paths, destined for an unexpected encounter with the mystical guardians: ClusterIP, NodePort, LoadBalancer, and ExternalName.</p>"},{"location":"Kubernetes%20Dungeon/02_Services/#clusterip","title":"ClusterIP","text":"<p>Brave Ben, opting for a solitary journey into the depths, utilized his teleportation magic to navigate the labyrinthine tunnels. Amidst the maze, he encountered ClusterIP, a spectral guide. This entity ensured seamless communication within the dungeon's confines, shielding him from external interference. The aid of ClusterIP was akin to possessing an exclusive map of the tunnels, accessible only to those within its bounds.</p>"},{"location":"Kubernetes%20Dungeon/02_Services/#nodeport","title":"NodePort","text":"<p>Meanwhile, Resourceful Rina circled the castle walls until she stumbled upon a concealed door. Upon entering, she was greeted by NodePort, the stalwart guardian. NodePort facilitated external access to specific chambers within the dungeon, acting as a direct bridge between the interior and the outside world. It served as a key to unlock designated areas, granting entry to predetermined zones.</p>"},{"location":"Kubernetes%20Dungeon/02_Services/#loadbalancer","title":"LoadBalancer","text":"<p>Finally Fearless Fred decided to boldly march through the main entrance, confronting a massive gate guarded by the imposing LoadBalancer. This formidable gatekeeper permitted numerous adventurers to access the dungeon's chambers. The LoadBalancer represented the necessity for a broader entry point, providing an accessible map to guide all who sought exploration within.</p>"},{"location":"Kubernetes%20Dungeon/02_Services/#externalname","title":"ExternalName","text":"<p>In the shadows, a lesser-known sorcerer, ExternalName, watched over a hidden passage leading to a realm beyond the dungeon's confines. This sorcerer acted as a conduit to an external service, allowing adventurers to access resources located outside the dungeon's domain. ExternalName served as a gateway to distant lands, offering a glimpse into worlds beyond imagination.</p>"},{"location":"Kubernetes%20Dungeon/02_Services/#conclusion","title":"Conclusion","text":"<p>Though taking different routes, ClusterIP, NodePort, LoadBalancer, and ExternalName guided the adventurers through the Cluster Castle, each ensuring access to its treasures while safeguarding its secrets with their protective measures. The four adventurers all emerged victorious, and returned laden with newfound knowledge and riches.</p>"},{"location":"Kubernetes%20Dungeon/02_Services/#exercise-managing-kubernetes-services-clusterip-nodeport-loadbalancer-and-externalname","title":"Exercise: Managing Kubernetes Services - ClusterIP, NodePort, LoadBalancer, and ExternalName","text":"<p>Objective: The objective of this exercise is to gain hands-on experience in managing different types of Kubernetes services: ClusterIP, NodePort, LoadBalancer, and ExternalName.</p> <p>Requirements: - Access to a Kubernetes cluster (locally installed or cloud-based) - kubectl command-line tool installed and configured to communicate with the Kubernetes cluster</p> <p>Instructions: 1. Create a ClusterIP Service:     - Use either a YAML configuration file or the command line to create a ClusterIP service to connect an app to a port.</p> <ol> <li> <p>Create a NodePort Service:</p> <ul> <li>Define a NodePort service to connect an app to a port, allowing external access by specifying a node port.</li> </ul> </li> <li> <p>Create a Basic LoadBalancer Service:</p> <ul> <li>Establish a basic LoadBalancer service to connect an app to a port.</li> </ul> </li> <li> <p>Create an ExternalName Service:</p> <ul> <li>Set up an ExternalName service to map a service to a DNS name.</li> </ul> </li> <li> <p>Confirm Service Creation:</p> <ul> <li>Verify that the services have been created correctly.</li> </ul> </li> <li> <p>Edit a Service:</p> <ul> <li>Modify or add a port, or link to a different element in at least one of the services.</li> </ul> </li> <li> <p>Clean Up Resources:</p> <ul> <li>Remove resources once the exercise is completed to prevent unnecessary costs or cluttering of the Kubernetes cluster.</li> </ul> </li> </ol> <p>Example Solution Steps:</p> <p>Assuming you have a Kubernetes cluster set up and a sample application deployed named \"my-app\":</p> <ol> <li> <p>Create ClusterIP Service: <pre><code>kubectl create service clusterip my-app-clusterip --tcp=80:8080\n</code></pre></p> </li> <li> <p>Create NodePort Service: <pre><code>kubectl create service nodeport my-app-nodeport --tcp=80:8080 --node-port=30000\n</code></pre></p> </li> <li> <p>Create LoadBalancer Service: <pre><code>kubectl create service loadbalancer my-app-loadbalancer --tcp=80:8080\n</code></pre></p> </li> <li> <p>Create ExternalName Service: <pre><code>kubectl create service externalname my-app-external --external-name=example.com\n</code></pre></p> </li> <li> <p>Verify Service Creation: <pre><code>kubectl get services\n</code></pre></p> </li> <li> <p>Edit a Service: <pre><code>kubectl edit svc my-app-clusterip\n</code></pre></p> </li> <li> <p>Clean Up Resources: <pre><code>kubectl delete service my-app-clusterip my-app-nodeport my-app-loadbalancer my-app-external\n</code></pre></p> </li> </ol> <p>These steps should provide a hands-on experience in managing various types of Kubernetes services and familiarize you with their configurations and functionalities.</p> <p>To get a full insight of the services, their characteristics and yaml files configuration, you can find here the full official documentation. </p>"},{"location":"Misc%20Magic/01_Git_Basic_workflow/","title":"Git Basic Workflow","text":""},{"location":"Misc%20Magic/01_Git_Basic_workflow/#objective","title":"Objective","text":"<p>Learn a basic workflow for social coding with git.</p>"},{"location":"Misc%20Magic/01_Git_Basic_workflow/#storytime","title":"Storytime","text":"<p>Once upon a time in the enchanted land of Vitrua, there lived a wizard named Wizzle. Wizzle was not your ordinary wizard; he was part of an order of fellow wizards and sorcerers who shared all their spells through a big cauldron. One day, Wizzle got an idea to upgrade the Fire spell, and he extracted a magical paper named <code>fire.spell</code> from the cauldron. </p> <pre><code>git clone https://github.com/vitrua/spellbook\n</code></pre> <p>Inscribed on the paper was the spell to conjure flames - a simple yet powerful \"Fire\" spell. Wizzle was excited to make it even more powerful.</p>"},{"location":"Misc%20Magic/01_Git_Basic_workflow/#the-spellcasting-ritual","title":"The Spellcasting Ritual:","text":"<ol> <li> <p>Create a New Branch - Fireball:</p> <ul> <li>Wizzle opened his enchanted terminal and invoked the Git spell to create a new branch named \"ball\":  <pre><code>git branch ball\n</code></pre></li> <li>With a flick of his wand, he switched to the \"fireball\" branch:  <pre><code>git checkout ball\n</code></pre></li> </ul> </li> <li> <p>Update the Spell - Fireball:</p> <ul> <li>Wizzle opened the magical <code>fire.spell</code> paper using his text-editor visualization spell.</li> <li>He modified the incantation from <code>Fire</code> to <code>Fireball</code>, bringing the new spell to life.</li> <li>Wizzle added the updated spell to the magical Git cauldron. <pre><code>git add fire.spell\n</code></pre></li> <li>With a wave of his hand, he committed the changes, letting the other wizards know what you can do with the new spell:  <pre><code>git commit -m \"Cast Fireball spell\"\n</code></pre></li> </ul> </li> <li> <p>Merge the Fireball Magic:</p> <ul> <li>Satisfied with the powerful Fireball spell, Wizzle decided to merge it into the main spellbook. He switched back to the main branch:  <pre><code>git checkout main\n</code></pre></li> <li>He merged the Fireball magic into the main spellbook:  <pre><code>git merge fireball\n</code></pre></li> </ul> </li> </ol> <p>The Grand Finale:</p> <p>With a sense of accomplishment, Wizzle pushed the updated main spellbook to the magical cauldron:  <pre><code>git push origin main\n</code></pre> His fellow wizards and sorcerers, connected through the magical network, marveled at the newfound powers of the Fireball spell.</p> <p>And so, in the land of Vitrua, Wizzle the Spellcaster continued to weave his magical Git commands, creating powerful spells and enchantments for the entire magical community.</p>"},{"location":"Misc%20Magic/01_Git_Basic_workflow/#magical-git-commands-summary","title":"Magical Git Commands Summary:","text":"<ul> <li><code>git branch &lt;branch_name&gt;</code>: Create a new branch.</li> <li><code>git checkout &lt;branch_name&gt;</code>: Switch to a branch.</li> <li><code>sed -i 's/Fire/Fireball/' fire.spell</code>: Update spell text.</li> <li><code>git add fire.spell</code>: Add changes to the staging area.</li> <li><code>git commit -m \"Commit message\"</code>: Commit changes.</li> <li><code>git merge &lt;branch_name&gt;</code>: Merge changes from another branch.</li> <li><code>git push origin &lt;branch_name&gt;</code>: Push changes to a remote repository.</li> </ul> <p>And so, the tale of Wizzle the Git Spellcaster goes down in the magical scrolls of Vitrua, inspiring wizards and developers alike to wield the power of Git for enchanting collaborative creations.</p>"},{"location":"Misc%20Magic/02_Cow_Fortune/","title":"Cowsay Fortune","text":""},{"location":"Misc%20Magic/02_Cow_Fortune/#objective","title":"Objective","text":"<p>Being greeted by a cow predicting your fortune every time you open a bash terminal. </p>"},{"location":"Misc%20Magic/02_Cow_Fortune/#example","title":"Example","text":"<pre><code> ___________________________________\n&lt; Beware of low-flying butterflies. &gt;\n -----------------------------------\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n</code></pre>"},{"location":"Misc%20Magic/02_Cow_Fortune/#storytime","title":"Storytime","text":"<p>Fortune-teller cow wasn't known for her milk production,</p> <p>but for her uncanny ability to see the future. </p> <p>Farmers flocked to her pasture, eagerly awaiting a swish of her tail </p> <p>(left meant sunshine, right meant rain). </p>"},{"location":"Misc%20Magic/02_Cow_Fortune/#installation","title":"Installation","text":"<ol> <li> <p>Install fortune and cowsay</p> <p>First, you need to ensure that both <code>fortune</code> and <code>cowsay</code> are installed on your system. You can do this using your package manager. For example, on Ubuntu or Debian-based systems, you can use <code>apt</code>:</p> <pre><code>sudo apt update\nsudo apt install fortune cowsay\n</code></pre> <p>For other Linux distributions, you might use <code>yum</code>, <code>dnf</code>, or another package manager appropriate to your system.</p> </li> <li> <p>Modify your .bashrc file</p> <p>Once you have <code>fortune</code> and <code>cowsay</code> installed, you can modify your <code>.bashrc</code> file to display a random fortune each time you open a new terminal window or tab.</p> <p>Open your <code>.bashrc</code> file in a text editor. You can do this with the following command:</p> <pre><code>nano ~/.bashrc\n</code></pre> <p>Scroll to the bottom of the file, and add the following lines:</p> <pre><code># Display a random fortune with cowsay when opening a new terminal\nif [ -x /usr/games/cowsay -a -x /usr/games/fortune ]; then\n  fortune | cowsay\nfi\n</code></pre> <p>Save the file by pressing <code>Ctrl + O</code>, then press <code>Enter</code> to confirm, and exit Nano by pressing <code>Ctrl + X</code>.</p> </li> <li> <p>Test it out</p> <p>Open a new terminal window or tab, and you should see a random fortune displayed in a speech bubble created by a cow! Each time you open a new terminal, you'll see a different fortune.</p> </li> </ol> <p>That's it! You've successfully installed <code>fortune</code> and <code>cowsay</code> on your Bash shell and configured it to display a random fortune each time you open a new terminal session.</p>"},{"location":"OSpace/01_Basic_Linux/","title":"Basic Linux Workflow","text":""},{"location":"OSpace/01_Basic_Linux/#objective","title":"Objective","text":"<p>Learn commands for basic Linux operations from terminal by following a penguin in Outer Space. </p>"},{"location":"OSpace/01_Basic_Linux/#introduction","title":"Introduction","text":"<p>Meet Pulsar Penguin, the brave astronaut quietly floating in his spaceship in outer space. As he taps with his fins on the control panel keyboard, his spacecraft is suddenly damaged by a small meteor. Trained to stay calm in such situations, he begins to navigate through the dire scenario.</p>"},{"location":"OSpace/01_Basic_Linux/#prerequisites","title":"Prerequisites","text":"<p>To follow along, you'll need:</p> <ul> <li>Access to a Linux-based system or terminal emulator.</li> </ul>"},{"location":"OSpace/01_Basic_Linux/#pulsars-directories","title":"Pulsar's Directories","text":"<pre><code>engine\n\u251c\u2500\u2500\u2500mounted\n\u2502   \u251c\u2500\u2500\u2500propeller.broken.part\n\u2502   \u2514\u2500\u2500\u2500jet.part\n\u2514\u2500\u2500\u2500spare\n    \u251c\u2500\u2500\u2500jet.new.part\n    \u2514\u2500\u2500\u2500propeller.new.part\n</code></pre>"},{"location":"OSpace/01_Basic_Linux/#linux-commands-in-action","title":"Linux Commands in Action","text":""},{"location":"OSpace/01_Basic_Linux/#navigating-and-managing-files","title":"Navigating and Managing Files","text":"<ul> <li> <p>Calmly, Pulsar begins repair operations by determining his current location with the 'print working directory' command:   <pre><code>pwd\n</code></pre></p> </li> <li> <p>Discovering he's in the /engine directory, he confirms its contents with the 'list' command:   <pre><code>ls\n</code></pre></p> </li> <li> <p>Hearing strange noises from the 'mounted' directory, he investigates further using the 'change directory' command:   <pre><code>cd mounted\n</code></pre></p> </li> <li> <p>He finds a broken file, 'propeller.broken.part', and swiftly creates a new directory using 'make directory' to store parts temporarily:   <pre><code>mkdir temporary\n</code></pre></p> </li> <li> <p>Returning to the 'engine' level:   <pre><code>cd ..\n</code></pre></p> </li> <li> <p>He easily makes a 'copy' of the spare part:   <pre><code>cp spare/propeller.new.part mounted/propeller.new.part\n</code></pre></p> </li> <li> <p>Revisiting the 'mounted' components, he renames the new part while 'moving' it:   <pre><code>mv propeller.new.part propeller.part\n</code></pre></p> </li> <li> <p>After completing the repairs, he cleans up the debris by 'removing' unnecessary files:   <pre><code>rm propeller.broken.part\nrm -r temporary\n</code></pre></p> </li> </ul>"},{"location":"OSpace/01_Basic_Linux/#system-management","title":"System Management","text":"<ul> <li> <p>Facing a moment of panic when the new part doesn't work due to incorrect permissions, Pulsar temporarily grants full access using the 'change mode' command:   <pre><code>chmod -R 777 /engine/mounted\n</code></pre></p> </li> <li> <p>Encountering an error, he elevates his privileges using the 'super user do' command:   <pre><code>sudo chmod -R 777 /engine/mounted\n</code></pre></p> </li> </ul>"},{"location":"OSpace/01_Basic_Linux/#communication-and-troubleshooting","title":"Communication and Troubleshooting","text":"<ul> <li> <p>With the spaceship stabilized, Pulsar performs a final check to ensure all parts are accounted for using 'global regular expression print':   <pre><code>grep part\n</code></pre></p> </li> <li> <p>Before resuming his journey, he consults the manual one last time:   <pre><code>man pwd\n</code></pre></p> </li> </ul>"},{"location":"OSpace/01_Basic_Linux/#linux-survival-summary","title":"Linux Survival Summary:","text":"<ul> <li><code>pwd</code>: Get the path to the current working directory.</li> <li><code>ls</code>: List directory contents. <code>ls -lah</code> for more information.</li> <li><code>cd &lt;directory_name&gt;</code>: Change directory. <code>cd ..</code> to go back to a higher level.</li> <li><code>mkdir &lt;directory_name&gt;</code>: Create a new directory.</li> <li><code>cp &lt;path_original_file&gt; &lt;path_destination_file&gt;</code>: Copy a file.</li> <li><code>mv &lt;path_original_file&gt; &lt;path_destination_file&gt;</code>: Move a file.</li> <li><code>rm &lt;file_path&gt;</code>: Remove a file. <code>rm -rf &lt;directory_path&gt;</code>: Remove a directory and everything inside it forcefully.</li> <li><code>chmod &lt;permissions&gt; &lt;file_name&gt;</code>: Manage permissions.</li> <li><code>sudo &lt;command&gt;</code>: Execute a command as a superuser (root).</li> <li><code>grep &lt;pattern&gt; &lt;file_name&gt;</code>: Search for a pattern in files.</li> </ul>"},{"location":"OSpace/01_Basic_Linux/#conclusion","title":"Conclusion","text":"<p>Pulsar's journey demonstrates how mastering basic Linux commands can be crucial in critical situations. By familiarizing yourself with these commands, you too can navigate through the complexities of Linux systems with confidence and resilience.</p>"},{"location":"OpenShift%20Castle/01_authentication_new_project_basics/","title":"Authentication, new project and basics","text":""},{"location":"OpenShift%20Castle/01_authentication_new_project_basics/#objective","title":"Objective","text":"<p>Learn how to authenticate, create new projects, and some basic commands in Openshift. Enter the Openshift Castle.</p>"},{"location":"OpenShift%20Castle/01_authentication_new_project_basics/#prerequisites","title":"Prerequisites","text":"<p>To embark on this adventure, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and Kubernetes concepts.</li> </ul>"},{"location":"OpenShift%20Castle/01_authentication_new_project_basics/#introduction","title":"Introduction","text":"<p>In the vast landscape of the digital realm, where clusters of containers flourish like bustling kingdoms, there lies the imposing fortress of Openshift. Built upon the foundation of Kubernetes, this castle stands as a bastion of security and scalability, protecting its treasures with unwavering vigilance.</p> <p>Our hero, a brave adventurer seeking knowledge and mastery, stands before the gates of Openshift. The castle looms above, its architecture intricate and imposing, a testament to the power it holds within.</p>"},{"location":"OpenShift%20Castle/01_authentication_new_project_basics/#authentication-gates","title":"Authentication Gates","text":"<p>Before venturing forth, our hero must authenticate at the castle gates. With the <code>oc login</code> command, he present their credentials: <pre><code>oc login &lt;cluster-url&gt;\n</code></pre></p>"},{"location":"OpenShift%20Castle/01_authentication_new_project_basics/#forging-new-projects","title":"Forging New Projects","text":"<p>A strange sensation courses through our hero's veins as they enter the castle, as if the fortress were under their command. The first thing noticed is the multitude of different wings within the castle, each isolated from the others. With newfound powers, our hero invokes the creation of a new project to carve out a new realm: <pre><code>oc new project &lt;my-app&gt;\n</code></pre></p>"},{"location":"OpenShift%20Castle/01_authentication_new_project_basics/#commanding-the-castle","title":"Commanding the Castle","text":"<p>Adorning the walls are inscriptions in a mysterious language. Armed with the knowledge of oc commands, our hero delves deeper into the castle's inner workings: <pre><code>oc cluster-info\noc api-versions\noc get clusteroperator\noc get pod\noc get pod &lt;pod_name&gt;\noc get pod &lt;pod_name&gt; -o yaml\noc get pod &lt;pod_name&gt; -o json\noc get deploy &lt;deploy_name&gt; -o wide\noc get all\noc describe &lt;resource_type&gt; &lt;resource_name&gt;\noc explain &lt;jsonpath_identifier&gt;\noc explain &lt;jsonpath_identifier&gt; --recursive\noc create -f &lt;pod.yaml&gt;\noc status --suggest\noc delete &lt;resource_type&gt; &lt;resource_name&gt;\n</code></pre> For instance: <pre><code>oc explain pods.spec.containers.resources\n</code></pre> These commands unveil the secrets of the castle's infrastructure and its inhabitants.</p> <p>To make these commands influence a different wing of the castle, than the one where he is in that moment, our hero needs to add the option <code>--namespace</code> or <code>-n</code> to the instruction: <pre><code>oc get pod -n &lt;namespace&gt;\n</code></pre></p>"},{"location":"OpenShift%20Castle/01_authentication_new_project_basics/#token-of-entry-oauth","title":"Token of Entry - OAuth","text":"<p>For those who seek passage via OAuth, the castle offers tokens of entry: <pre><code>oc login --token=sha256-BW...fE2 --server=https://api.eg.vitrua.top:6443\n</code></pre> These tokens grant access to the castle's inner sanctums.</p>"},{"location":"OpenShift%20Castle/01_authentication_new_project_basics/#conclusion","title":"Conclusion","text":"<p>And thus, the hero took his first steps inside the castle.</p>"},{"location":"OpenShift%20Castle/02_exploring_api_resources/","title":"Exploring API Resources","text":""},{"location":"OpenShift%20Castle/02_exploring_api_resources/#objective","title":"Objective","text":"<p>Discover and explore the API resources available within Openshift to understand the landscape of its capabilities. Learn to navigate in the OpenShift realm.</p>"},{"location":"OpenShift%20Castle/02_exploring_api_resources/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of discovery, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and Kubernetes concepts.</li> </ul>"},{"location":"OpenShift%20Castle/02_exploring_api_resources/#introduction","title":"Introduction","text":"<p>As we venture deeper into the heart of the Openshift castle, we uncover the API resources, the very fabric that defines the realm's architecture and functionality. These resources represent the essence of every component within the castle, guiding its operations and interactions.</p>"},{"location":"OpenShift%20Castle/02_exploring_api_resources/#viewing-api-resources","title":"Viewing API Resources","text":"<p>The API resource objects serve as blueprints for the intended state of every entity in the cluster. Similar to their counterparts in the realm of Kubernetes, these commands offer insights into the castle's inner workings: <pre><code>oc api-resources\n</code></pre> You can refine and organize the results using additional flags: <pre><code>oc api-resources --namespaced=true --api-group apps --sort-by name\n</code></pre></p>"},{"location":"OpenShift%20Castle/02_exploring_api_resources/#openshift-main-resource-types","title":"Openshift Main Resource Types","text":""},{"location":"OpenShift%20Castle/02_exploring_api_resources/#buildconfig-architectural-blueprints","title":"BuildConfig: Architectural Blueprints","text":"<p>In the grand design of the Openshift castle, the BuildConfig stands as the architect's blueprint, defining the intricate process of constructing container images from source code stored in Git repositories. It is the cornerstone of continuous integration and delivery workflows, laying the foundation for innovation and evolution within Openshift projects.</p>"},{"location":"OpenShift%20Castle/02_exploring_api_resources/#deploymentconfig-strategic-deployments","title":"DeploymentConfig: Strategic Deployments","text":"<p>Within the fortified walls of Openshift, the DeploymentConfig serves as a strategic map, guiding the deployment and management of sets of containers within pods. With features encompassing scaling and deployment strategies, it orchestrates the movement of troops across the battlefield of the cluster. In Openshift 4.5, it yields to Deployment objects, heralding a new era of enhanced features and flexibility, yet its legacy remains ingrained in the castle's history.</p>"},{"location":"OpenShift%20Castle/02_exploring_api_resources/#routes-pathways-of-navigation","title":"Routes: Pathways of Navigation","text":"<p>Like ancient pathways leading through the labyrinthine corridors of the Openshift castle, Routes are the DNS hostnames recognized by the Openshift router. They serve as the entry points for accessing applications and microservices, guiding travelers through the bustling streets and bustling squares of the cluster. With each route mapped and each journey embarked upon, they facilitate the seamless flow of traffic within Openshift's intricate network of pathways and passages.</p> <p>Embark on this journey of exploration through the API resources of Openshift, unraveling its intricacies and unlocking its potential.</p>"},{"location":"OpenShift%20Castle/03_extracting_config_data/","title":"Data Extraction from Configurations","text":""},{"location":"OpenShift%20Castle/03_extracting_config_data/#objective","title":"Objective","text":"<p>Master the art of extracting data from YAML representations of resources within the Openshift castle, unveiling insights and unraveling complexities.</p>"},{"location":"OpenShift%20Castle/03_extracting_config_data/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of data extraction, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and Kubernetes concepts.</li> </ul>"},{"location":"OpenShift%20Castle/03_extracting_config_data/#introduction","title":"Introduction","text":"<p>As we delve deeper into the depths of the Openshift castle, we uncover hidden treasures within the YAML representations of its resources. These data-rich files hold the key to understanding the inner workings of the castle's components, offering a glimpse into its architecture and functionality.</p>"},{"location":"OpenShift%20Castle/03_extracting_config_data/#extracting-data-from-yamls","title":"Extracting Data from YAMLs","text":"<p>Unlock the potential of data extraction with commands designed to parse YAML representations into a tabular format: <pre><code>oc get pods \\\n-o custom-columns=PodName:\".metadata.name\",\\\nContainerName:\"spec.containers[].name\",\\\nPhase:\"status.phase\",\\\nIP:\"status.podIP\",\\\nPorts:\"spec.containers[].ports[].containerPort\"\n</code></pre></p>"},{"location":"OpenShift%20Castle/03_extracting_config_data/#format-output-with-jsonpath","title":"Format output with JSONPath","text":"<p>For formatted output, harness the power of JSONPath expressions: <pre><code>oc get pods \\\n-o jsonpath='{range .items[]}{\"Pod Name: \"}{.metadata.name}\n{\"Container Names:\"}{.spec.containers[].name}\n{\"Phase: \"}{.status.phase}\n{\"IP: \"}{.status.podIP}\n{\"Ports: \"}{.spec.containers[].ports[].containerPort}\n{\"Pod Start Time: \"}{.status.startTime}{\"\\n\"}{end}'\n</code></pre></p> <p>Unlock the hidden insights within the YAML representations of Openshift resources, and empower yourself with the knowledge to navigate its intricate architecture with confidence.</p>"},{"location":"OpenShift%20Castle/04_examining_cluster_metrics/","title":"Examine Cluster Metrics","text":""},{"location":"OpenShift%20Castle/04_examining_cluster_metrics/#objective","title":"Objective","text":"<p>Examining cluster metrics, revealing the heartbeat of the operations of the Openshift castle.</p>"},{"location":"OpenShift%20Castle/04_examining_cluster_metrics/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of exploration, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and Kubernetes concepts.</li> </ul>"},{"location":"OpenShift%20Castle/04_examining_cluster_metrics/#introduction","title":"Introduction","text":"<p>As we journey further into the heart of the Openshift castle, we uncover the realm's hidden secrets through the examination of cluster metrics. These metrics serve as the pulse of the castle, offering glimpses into its inner workings and resource utilization.</p>"},{"location":"OpenShift%20Castle/04_examining_cluster_metrics/#examining-cluster-metrics","title":"Examining Cluster Metrics","text":"<p>To peer into the total CPU usage of all pods within the cluster, our adventurers employ the following command: <pre><code>oc adm top pods -A --sum\n</code></pre> For a more focused inquiry into a single pod's CPU usage, they utilize the command: <pre><code>oc adm top pods &lt;pod_name&gt; -n &lt;namespace&gt; --containers\n</code></pre></p>"},{"location":"OpenShift%20Castle/04_examining_cluster_metrics/#metrics-from-interface","title":"Metrics from interface","text":"<p>Within the stronghold's grand halls, adventurers find themselves drawn to the Home -&gt; Overview section of the web interface, where the castle's metrics are displayed like ancient tapestries, meticulously sorted by resource utilization. Here, amidst the hustle and bustle of the castle's daily activities, they gain a fleeting glimpse of the main consumers within its walls, providing a quick overview of the kingdom's vitality.</p> <p>Yet, for those intrepid souls yearning for deeper insights and exploration, a path awaits within the Observe -&gt; Metrics section. Here, amidst the solemn grandeur of the castle's observatory, Prometheus queries can be executed like incantations, summoning forth insights from the depths of time. Through the arcane language of time-series graphs, adventurers unlock the secrets hidden within the castle's vast expanse of data and metrics.</p> <p>Embark on this journey of discovery, as we unravel the mysteries concealed within the labyrinthine corridors of Openshift's castle, and illuminate the path to enlightenment for all who dare to venture forth.</p>"},{"location":"OpenShift%20Castle/05_get_events_and_troubleshooting/","title":"Exploring Cluster Events and Troubleshooting","text":""},{"location":"OpenShift%20Castle/05_get_events_and_troubleshooting/#objective","title":"Objective","text":"<p>Delve into the realm of Openshift's cluster events and troubleshooting, illuminating the path to understanding and resolution within the fortress's walls.</p>"},{"location":"OpenShift%20Castle/05_get_events_and_troubleshooting/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of exploration and discovery, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and Kubernetes concepts.</li> </ul>"},{"location":"OpenShift%20Castle/05_get_events_and_troubleshooting/#introduction","title":"Introduction","text":"<p>As we venture deeper into the fortified confines of the Openshift citadel, we encounter the realm of cluster events and troubleshooting. Here, amidst the ebb and flow of activity, lies a treasure trove of insights and solutions waiting to be unearthed.</p>"},{"location":"OpenShift%20Castle/05_get_events_and_troubleshooting/#get-cluster-events","title":"Get Cluster Events","text":"<p>Adventurers have the power to unveil the chronicles of the cluster through commands like: <pre><code>oc get events -n &lt;namespace&gt; --sortby .metadata.creationTimestamp\n</code></pre> Openshift boasts a monitoring stack anchored by Prometheus, residing within the 'openshift-monitoring' namespace. Powered by the Prometheus platform and Alertmanager, it stands as a sentinel, ever vigilant over the citadel's affairs.</p>"},{"location":"OpenShift%20Castle/05_get_events_and_troubleshooting/#check-node-status-and-troubleshooting","title":"Check Node Status and Troubleshooting","text":"<p>Armed with knowledge and determination, explorers can scrutinize the general status of the cluster and delve deeper into its inner workings with commands such as: <pre><code>oc cluster-info\noc get nodes\noc get node &lt;NODE_NAME&gt; -o jsonpath=*'{\"Allocatable:\\n\"}{.status.allocatable}{\"\\n\\n\"}{\"Capacity:\\n\"}{.status.capacity}{\"\\n\"}'\noc get node &lt;NODE_NAME&gt; -o json | jq '.status.conditions'\noc adm node-logs &lt;NODE_NAME&gt; -u &lt;COMPONENT_NAME&gt; --tail 10\n</code></pre> For those brave enough to seek resolution in the face of adversity, the path of the troubleshooter beckons. Activate the debug session and peer into the heart of the node: <pre><code>oc debug node/&lt;NODE_NAME&gt;\n</code></pre> Within the confines of the debug session, adventurers can confirm the activity of services with commands like: <pre><code># To run binaries in the host's executable path\nchroot /host\n# To confirm that the services are active\nfor SERVICES in kubelet crio; do echo ---- $SERVICES ---- ;\nsystemctl is-active $SERVICES ; echo \"\"; done\n</code></pre> Similar procedures can be employed for delving into the workings of pods, unraveling the threads of mystery woven within the citadel's walls.</p> <p>Embark on this journey of discovery, as we illuminate the shadows cast by the veil of uncertainty, and emerge victorious in the quest for knowledge and resolution within the timeless bastion of Openshift's citadel.</p>"},{"location":"OpenShift%20Castle/06_pods_creation_and_management/","title":"Pods Creation and Management","text":""},{"location":"OpenShift%20Castle/06_pods_creation_and_management/#objective","title":"Objective","text":"<p>Learn the art of creating and managing pods within the bastion of the Openshift citadel, laying the groundwork for your digital domains.</p>"},{"location":"OpenShift%20Castle/06_pods_creation_and_management/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of creation and mastery, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and Kubernetes concepts.</li> </ul>"},{"location":"OpenShift%20Castle/06_pods_creation_and_management/#introduction","title":"Introduction","text":"<p>As we lay the cornerstone of our digital domains within the fortified confines of the Openshift citadel, we delve into the realm of pod creation and management. Here, amidst the hum of activity, like the rooms of a castle, lies the little foundations upon which our containerized realms shall thrive.</p>"},{"location":"OpenShift%20Castle/06_pods_creation_and_management/#pods-creation","title":"Pods Creation","text":"<p>The creation of pods, the very crucible of containerization, is an art mastered through the commands of 'kubectl' or 'oc CLI'. With the <code>run</code> command, we breathe life into our digital entities: <pre><code>oc run &lt;RESOURCE/NAME&gt; --image &lt;IMAGE&gt; [options]\noc run &lt;RESOURCE/NAME&gt; --image &lt;IMAGE&gt; --command -- cmd &lt;arg1 ... argN&gt;\n</code></pre> To commence an interactive session within the pod's container, the <code>-it</code> option is invoked: <pre><code>oc run -it my-app --image docker.io/library/busybox --command -- /bin/bash\n</code></pre> Further options allow for fine-tuning the creation process, specifying restart policies, environment variables, and automatic deletion after the session's conclusion: <pre><code>kubectl run -it my-app --rm --image docker.io/library/busybox --env MY_PASSWORD=P455w@rd --restart Never --command -- date\n</code></pre> In the realm of Openshift, containers created by regular users are subject to the constraints imposed by the Security Context Constraints controller, ensuring a safe environment.</p>"},{"location":"OpenShift%20Castle/06_pods_creation_and_management/#executing-commands-in-running-pod","title":"Executing commands in running pod","text":"<p>When a pod is already in motion, commands can still be executed within its confines using <code>exec</code>: <pre><code>oc exec &lt;RESOURCE/NAME&gt; -- &lt;COMMAND&gt; [args...] [options]\n</code></pre> For an interactive session, the <code>-i</code> and <code>-t</code> flags once again guide our path. In multi-container pods, the <code>-c</code> or <code>--container=</code> flag designates the specific container for command execution.</p> <p>Embark on this journey of creation and management, as we forge the foundations of our digital realms within the hallowed halls of the Openshift citadel.</p>"},{"location":"OpenShift%20Castle/07_container_logs/","title":"Explore Container Logs","text":""},{"location":"OpenShift%20Castle/07_container_logs/#objective","title":"Objective","text":"<p>Uncover the secrets held within the logs of containers, shedding light on the activities and events transpiring within the walls of the Openshift citadel.</p>"},{"location":"OpenShift%20Castle/07_container_logs/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of exploration and revelation, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and Kubernetes concepts.</li> </ul>"},{"location":"OpenShift%20Castle/07_container_logs/#introduction","title":"Introduction","text":"<p>As we delve into the depths of the Openshift citadel, we turn our attention to the archives of container logs. Here, amidst the echoes of past events, lies a wealth of information waiting to be discovered and deciphered.</p>"},{"location":"OpenShift%20Castle/07_container_logs/#container-logs","title":"Container Logs","text":"<p>The logs of a container, akin to the chronicles of history, provide insights into the activities and events within. To retrieve these logs, adventurers employ the following command with various options: <pre><code>oc logs &lt;pod_name&gt; [options]\n</code></pre> - <code>-l</code> or <code>--selector=''</code>: Filters objects based on label key:value constraint. - <code>--tail=</code>: Specifies the number of lines of logs to display. - <code>-c</code> or <code>--container=</code>: Useful when multiple containers exist in a pod. - <code>-f</code> or <code>--follow=</code>: Streams logs for a container. - <code>-p</code> or <code>--previous=true</code>: Prints logs for a previous container instance in the pod, if available.</p>"},{"location":"OpenShift%20Castle/07_container_logs/#attach-to-pods","title":"Attach to Pods","text":"<p>For a more immersive experience, the <code>attach</code> command allows adventurers to connect to and start an interactive session on a running container within a pod: <pre><code>oc attach my-app -it\n</code></pre></p> <p>Embark on this journey of exploration and revelation, as we illuminate the archives of the Openshift citadel and uncover the secrets hidden within its container logs.</p>"},{"location":"OpenShift%20Castle/08_deleting_resources/","title":"Deleting Resources","text":""},{"location":"OpenShift%20Castle/08_deleting_resources/#objective","title":"Objective","text":"<p>Master the art of deleting resources within the confines of the Openshift castle, ensuring cleanliness and efficiency in your digital domains.</p>"},{"location":"OpenShift%20Castle/08_deleting_resources/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of resource deletion and management, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and Kubernetes concepts.</li> </ul>"},{"location":"OpenShift%20Castle/08_deleting_resources/#introduction","title":"Introduction","text":"<p>As we navigate the corridors of the Openshift castle, we encounter the necessity of resource deletion. Here, amidst the constant ebb and flow of digital entities, lies the art of tidying and organization.</p>"},{"location":"OpenShift%20Castle/08_deleting_resources/#deleting-resources_1","title":"Deleting Resources","text":"<p>Resources within the castle can be removed with the <code>delete</code> command, wielded with precision and care: <pre><code>oc delete pod my-app [options]\n</code></pre> Options abound to tailor the deletion process to your specific needs:</p> <ul> <li><code>-l &lt;key:value&gt;</code>: Selects resources based on the inserted label key:value.</li> <li><code>-f &lt;file_path&gt;</code>: Deletes resources specified in a file, providing the full path for accuracy.</li> <li><code>--grace-period=</code>: Specifies the seconds before a pod is forcibly terminated.</li> <li><code>--now</code>: Sets the grace period to 1 second, immediately shutting down the pod.</li> <li><code>--force</code>: Forcibly deletes the pod, overriding any constraints.</li> <li><code>--all</code>: Deletes all pods within a project, ensuring a clean slate for future endeavors.</li> </ul>"},{"location":"OpenShift%20Castle/08_deleting_resources/#full-project-deletion","title":"Full Project Deletion","text":"<p>For larger-scale deletions, entire projects and their associated resources can be removed with a single command: <pre><code>oc delete project &lt;project_name&gt;\n</code></pre></p> <p>Embark on this journey of resource management, as we wield the power of deletion within the hallowed halls of the Openshift castles.</p>"},{"location":"OpenShift%20Castle/09_cri-o_container_engine/","title":"The CRI-O Container Engine","text":""},{"location":"OpenShift%20Castle/09_cri-o_container_engine/#objective","title":"Objective","text":"<p>Uncover the secrets of the CRI-O container engine, gaining mastery over container management.</p>"},{"location":"OpenShift%20Castle/09_cri-o_container_engine/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of discovery and enlightenment, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and container concepts.</li> </ul>"},{"location":"OpenShift%20Castle/09_cri-o_container_engine/#introduction","title":"Introduction","text":"<p>As we traverse the labyrinthine corridors of the Openshift castle, we encounter the enigmatic presence of the CRI-O container engine. Here, amidst the whispers of arcane incantations, lies the key to unlocking the power of containerization.</p>"},{"location":"OpenShift%20Castle/09_cri-o_container_engine/#exploring-the-cri-o-container-engine","title":"Exploring the CRI-O Container Engine","text":""},{"location":"OpenShift%20Castle/09_cri-o_container_engine/#silent-guardian-of-containerized-realms","title":"Silent Guardian of Containerized Realms","text":"<p>CRI-O stands as the silent guardian of containerized realms, offering a command-line interface to manage containers with the mystical crictl command.</p>"},{"location":"OpenShift%20Castle/09_cri-o_container_engine/#mystical-commands-at-your-disposal","title":"Mystical Commands at Your Disposal","text":"<p>Behold the commands bestowed upon the wielder of this arcane tool:</p> <ul> <li><code>crictl pods</code>: Explore the pods within the containerized domain.</li> <li><code>crictl image</code>: Delve into the images that fuel the containerized realms.</li> <li><code>crictl inspect</code>: Unveil the secrets hidden within the containers.</li> <li><code>crictl exec</code>: Execute commands within containers, wielding the power of containerized magic.</li> <li><code>crictl logs</code>: Retrieve the logs that chronicle the activities within the mystical containers.</li> <li><code>crictl ps</code>: Witness the presence of containers, revealing their existence within the ethereal plane.</li> </ul>"},{"location":"OpenShift%20Castle/09_cri-o_container_engine/#mastery-through-authority","title":"Mastery Through Authority","text":"<p>To wield these commands with precision and mastery, one must possess the authority of a cluster administrator, guiding the containerized realms with wisdom and foresight.</p>"},{"location":"OpenShift%20Castle/09_cri-o_container_engine/#journey-deeper-into-the-realms","title":"Journey Deeper into the Realms","text":"<p>With crictl as your guide, journey deeper into the realms of containerization, obtaining the very essence of container IDs and delving into the depths of container exploration with commands like <code>lnsn</code> and <code>nsenter</code>.</p> <ul> <li> <p><code>lnsn</code>: This command enables you to obtain the container ID, a mystical identifier that serves as the key to unlock deeper insights into containerized realms.</p> </li> <li> <p><code>nsenter</code>: With this command, adventurers can transcend the boundaries of ordinary perception, entering into the mystical realms of containers. By invoking nsenter, one gains access to the inner workings of containers, allowing for exploration and manipulation beyond the confines of conventional reality.</p> </li> </ul> <p>Embark on this journey of discovery, as we unravel the secrets of the CRI-O container engine within the mystical confines of the Openshift castle.</p>"},{"location":"OpenShift%20Castle/10_oc_images/","title":"OC Images","text":""},{"location":"OpenShift%20Castle/10_oc_images/#objective","title":"Objective","text":"<p>Manage container images with the <code>oc image</code> command.</p>"},{"location":"OpenShift%20Castle/10_oc_images/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of exploration and enlightenment, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and container concepts.</li> </ul>"},{"location":"OpenShift%20Castle/10_oc_images/#introduction","title":"Introduction","text":"<p>As we navigate the intricate pathways of the Openshift castle, we encounter the realm of container images, governed by the mystical <code>oc image</code> command. Here, amidst the shimmering data streams, lies the essence of containerization waiting to be unveiled.</p>"},{"location":"OpenShift%20Castle/10_oc_images/#exploring-oc-images","title":"Exploring OC Images","text":""},{"location":"OpenShift%20Castle/10_oc_images/#commanding-the-digital-realms","title":"Commanding the Digital Realms","text":"<p>The <code>oc image</code> command serves as the wielder's tool to inspect, configure, and retrieve information about container images within the castle's domain.</p>"},{"location":"OpenShift%20Castle/10_oc_images/#mystical-options-at-your-command","title":"Mystical Options at Your Command","text":"<p>Behold the commands bestowed upon the keeper of this arcane tool:</p> <ul> <li><code>oc image info</code>: Gather insights into the properties and configurations of container images. Utilize options like <code>--filter-by-os</code> to manage specific types of images, e.g.:     <pre><code>oc image info docker.io/ibmcom/ibm-cloud-databases-redis-catalog --filter-by-os amd64\n</code></pre></li> </ul> <p>More powers can be:</p> <ul> <li> <p><code>oc image append</code>: Add layers to container images, empowering them with additional capabilities before pushing them to a registry.</p> </li> <li> <p><code>oc image extract</code>: Retrieve or copy files from container images to a local disk, without the need to run the image as a container.</p> </li> <li> <p><code>oc image mirror</code>: Facilitate the copying or mirroring of container images between different registries or repositories, enabling seamless transfers and management.</p> </li> </ul>"},{"location":"OpenShift%20Castle/10_oc_images/#journey-deeper-into-the-digital-realms","title":"Journey Deeper into the Digital Realms","text":"<p>With <code>oc image</code> as your guide, embark on a journey deeper into the digital realms of containerization, unlocking the hidden potential within container images and harnessing their power for your endeavors within the castle.</p> <p>Embark on this journey of discovery, as we unravel the mysteries of OC Images within the enchanted confines of the Openshift castle.</p>"},{"location":"OpenShift%20Castle/11_cli_troubleshooting_tools/","title":"CLI Troubleshooting Tools","text":""},{"location":"OpenShift%20Castle/11_cli_troubleshooting_tools/#objective","title":"Objective","text":"<p>Master the art of troubleshooting within the mystical confines of the Openshift castle, wielding the power of command-line tools with finesse and precision.</p>"},{"location":"OpenShift%20Castle/11_cli_troubleshooting_tools/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of troubleshooting and enlightenment, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and container concepts.</li> </ul>"},{"location":"OpenShift%20Castle/11_cli_troubleshooting_tools/#introduction","title":"Introduction","text":"<p>As we venture deeper into the labyrinthine corridors of the Openshift castle, we encounter the necessity of troubleshooting. Here, amidst the swirling mists of uncertainty, lies the arsenal of command-line tools waiting to be wielded in the pursuit of resolution.</p>"},{"location":"OpenShift%20Castle/11_cli_troubleshooting_tools/#cli-troubleshooting-tools_1","title":"CLI Troubleshooting Tools","text":""},{"location":"OpenShift%20Castle/11_cli_troubleshooting_tools/#commanding-the-ether","title":"Commanding the Ether","text":"<p>In the ethereal realm of command-line tools, troubleshooters wield an array of mystical commands to unveil the secrets hidden within the castle's digital domains:</p> <ul> <li><code>kubectl describe</code>: Delve into the detailed descriptions of resources, unraveling the intricacies of their configurations and states.</li> <li><code>kubectl edit</code>: Modify resource configurations directly from the command line, shaping the very essence of the digital realms.</li> <li><code>kubectl patch</code>: Apply changes to resource configurations using JSON or YAML patches, altering their properties with surgical precision.</li> <li><code>kubectl replace</code>: Replace existing resources with updated configurations, seamlessly transitioning them into new states.</li> <li><code>kubectl cp</code>: Transfer files and directories to and from containers, facilitating the exchange of knowledge and wisdom.</li> <li><code>kubectl exec</code>: Execute commands within containers, peering into their inner workings and retrieving valuable insights.</li> <li><code>kubectl explain</code>: Gain enlightenment on resource types and their fields, understanding their purpose and significance within the castle's architecture.</li> <li><code>kubectl port-forward</code>: Forge connections to containers, establishing pathways for communication and interaction.</li> </ul>"},{"location":"OpenShift%20Castle/11_cli_troubleshooting_tools/#openshift-specific-commands","title":"Openshift-Specific Commands","text":"<p>Within the enchanted confines of the Openshift castle, troubleshooters harness additional commands to navigate its unique landscapes:</p> <ul> <li><code>oc status</code>: Display the status of containers within the selected namespace, providing insights into their health and vitality.</li> <li><code>oc rsync</code>: Synchronize files and directories to and from containers, harmonizing the flow of information within the castle's realms.</li> <li><code>oc rsh</code>: Initiate remote shells within specified containers, traversing the boundaries of ordinary perception to explore their depths.</li> </ul> <p>Embark on this journey of troubleshooting, as we command the ether and unravel the mysteries concealed within the enchanted confines of the Openshift castle.</p>"},{"location":"OpenShift%20Castle/12_editing_resources/","title":"Editing Resources","text":""},{"location":"OpenShift%20Castle/12_editing_resources/#objective","title":"Objective","text":"<p>Learn the art of editing resources within the mystical confines of the Openshift castle, wielding the power to shape and mold configurations with finesse.</p>"},{"location":"OpenShift%20Castle/12_editing_resources/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of editing and transformation, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and container concepts.</li> </ul>"},{"location":"OpenShift%20Castle/12_editing_resources/#introduction","title":"Introduction","text":"<p>As we delve deeper into the enchanted realms of the Openshift castle, the need to make changes to resources arises. Here, amidst the flux of digital energies, lies the ability to edit configurations and orchestrate transformations.</p>"},{"location":"OpenShift%20Castle/12_editing_resources/#editing-resources_1","title":"Editing Resources","text":""},{"location":"OpenShift%20Castle/12_editing_resources/#direct-manipulation-of-configurations","title":"Direct Manipulation of Configurations","text":"<p>After the initial phase of inspection and data gathering, troubleshooters can directly test and apply changes to running containers using commands like <code>oc edit</code> and <code>oc patch</code>:</p> <ul> <li><code>oc edit</code>: Open the resource configuration in an editor, allowing for direct modification of parameters and settings.</li> <li><code>oc patch</code>: Apply changes to resource configurations using JSON or YAML patches, enabling precise alterations with surgical precision.</li> </ul>"},{"location":"OpenShift%20Castle/12_editing_resources/#example-usage","title":"Example Usage","text":"<pre><code>oc edit pod my-app-pod\n\noc patch pod valid-pod --type='json' \\\n-p='[{\"op\": \"replace\", \"path\": \"/spec/containers/0/image\", \\\n\"value\":\"docker.io/my-new-image:latest\"}]'\n</code></pre>"},{"location":"OpenShift%20Castle/12_editing_resources/#port-forwarding-for-investigation","title":"Port Forwarding for Investigation","text":"<p>For temporary port forwarding to expose connectivity to a pod for investigation purposes, troubleshooters can utilize the <code>oc port-forward</code> command:</p> <ul> <li><code>oc port-forward &lt;RESOURCE&gt; &lt;EXTERNAL_PORT:CONTAINER_PORT&gt;</code>: Establish a temporary connection between a local port and a container port, facilitating investigation and analysis.</li> </ul>"},{"location":"OpenShift%20Castle/12_editing_resources/#example-usage_1","title":"Example Usage","text":"<pre><code>oc port-forward nginx-app-ab12c 8080:80\n</code></pre> <p>Embark on this journey of editing and transformation, as we wield the power to shape the digital realms within the enchanted confines of the Openshift castle.</p>"},{"location":"OpenShift%20Castle/13_copying_files_to_and_from_containers/","title":"Copying Files to and from Containers","text":""},{"location":"OpenShift%20Castle/13_copying_files_to_and_from_containers/#objective","title":"Objective","text":"<p>Master the art of copying files to and from containers within the mystical confines of the Openshift castle, enabling seamless data exchange between realms.</p>"},{"location":"OpenShift%20Castle/13_copying_files_to_and_from_containers/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of file manipulation and synchronization, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and container concepts.</li> </ul>"},{"location":"OpenShift%20Castle/13_copying_files_to_and_from_containers/#introduction","title":"Introduction","text":"<p>As we navigate the ethereal landscapes of the Openshift castle, the need to exchange files with containers becomes apparent. Here, amidst the shimmering data streams, lies the ability to synchronize files between realms, enabling seamless interaction and data exchange.</p>"},{"location":"OpenShift%20Castle/13_copying_files_to_and_from_containers/#copying-files-to-and-from-containers_1","title":"Copying Files to and from Containers","text":""},{"location":"OpenShift%20Castle/13_copying_files_to_and_from_containers/#using-the-oc-cp-command","title":"Using the <code>oc cp</code> Command","text":"<p>To copy files to and from containers using the <code>oc cp</code> command, the <code>tar</code> binary must be present in the container. This command allows troubleshooters to exchange files between local directories and containers with ease:</p> <ul> <li><code>oc cp &lt;SOURCE&gt; &lt;DEST&gt;</code>: Copy files from a running container to a local directory, or from a local directory to a running container.</li> </ul>"},{"location":"OpenShift%20Castle/13_copying_files_to_and_from_containers/#example-usage","title":"Example Usage","text":"<pre><code>oc cp my-app-pod:/opt/app/config.ini /tmp/config.ini\noc cp /tmp/config.ini my-app-pod:/opt/app/\n</code></pre>"},{"location":"OpenShift%20Castle/13_copying_files_to_and_from_containers/#synchronizing-files-with-oc-rsync","title":"Synchronizing Files with <code>oc rsync</code>","text":"<p>For directory synchronization between a local directory and a directory within a container, troubleshooters can utilize the <code>oc rsync</code> command:</p> <ul> <li><code>oc rsync &lt;SOURCE&gt; &lt;DEST&gt;</code>: Synchronize files and directories between a local directory and a directory within a container.</li> </ul>"},{"location":"OpenShift%20Castle/13_copying_files_to_and_from_containers/#example-usage_1","title":"Example Usage","text":"<pre><code>oc rsync my-app-pod:/var/www/ /tmp/web_files\n</code></pre>"},{"location":"OpenShift%20Castle/13_copying_files_to_and_from_containers/#notes","title":"Notes","text":"<ul> <li>When targeting a file path within a pod for either the SOURCE or DEST argument, use the <code>&lt;pod_name&gt;:&lt;path&gt;</code> format, and optionally include the <code>-c &lt;container_name&gt;</code> option for specifying a particular container within a pod.</li> </ul> <p>Embark on this journey of file manipulation and synchronization, as we facilitate seamless data exchange between realms within the enchanted confines of the Openshift castle.</p>"},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/","title":"Container Operations and Monitoring","text":""},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/#objective","title":"Objective","text":"<p>Interact with containers. Master the art of executing commands, monitoring events, and accessing logs within containers, enabling efficient container management within the mystical confines of the Openshift castle.</p>"},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of container operations and monitoring, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and container concepts.</li> </ul>"},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/#introduction","title":"Introduction","text":"<p>As we delve deeper into the enchanted landscapes of the Openshift castle, the need to interact with and monitor containers becomes essential. Here, amidst the swirling energies of digital realms, lies the ability to execute commands, track events, and access logs within containers.</p>"},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/#container-operations-and-monitoring_1","title":"Container Operations and Monitoring","text":""},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/#connecting-to-a-running-container","title":"Connecting to a Running Container","text":"<p>To establish a connection to a running container within a pod, troubleshooters can utilize the <code>oc rsh</code> command:</p> <ul> <li><code>oc rsh &lt;POD_NAME&gt;</code>: Connect to the specified running container, enabling direct interaction and execution of commands.</li> </ul>"},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/#example-usage","title":"Example Usage","text":"<pre><code>oc rsh my-app-pod\n</code></pre>"},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/#executing-commands-within-a-container","title":"Executing Commands Within a Container","text":"<p>For executing commands directly within a container, the <code>oc exec</code> command provides a powerful tool:</p> <ul> <li><code>oc exec &lt;POD&gt; | &lt;TYPE/NAME&gt; [-c &lt;container_name&gt;] -- &lt;COMMAND&gt; [&lt;arg1 ... argN&gt;]</code>: Execute the specified command within the container, optionally specifying the container name if multiple containers exist within the pod.</li> </ul>"},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/#example-usage_1","title":"Example Usage","text":"<pre><code>oc exec my-app-pod -- ls /app\n</code></pre>"},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/#viewing-container-logs","title":"Viewing Container Logs","text":"<p>To access the logs generated by a container, troubleshooters can use the <code>oc logs</code> command:</p> <ul> <li><code>oc logs &lt;POD_NAME&gt;</code>: Retrieve and display the logs generated by the specified container.</li> </ul>"},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/#example-usage_2","title":"Example Usage","text":"<pre><code>oc logs my-app-pod\n</code></pre>"},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/#monitoring-container-events","title":"Monitoring Container Events","text":"<p>For monitoring events related to containers within a namespace, troubleshooters can utilize the <code>oc get events</code> command:</p> <ul> <li><code>oc get events</code>: View the events related to containers, providing insights into their lifecycle and status changes.</li> </ul>"},{"location":"OpenShift%20Castle/14_container_operations_and_monitoring/#example-usage_3","title":"Example Usage","text":"<pre><code>oc get events\n</code></pre> <p>Embark on this journey of container operations and monitoring, as we master the art of efficient container management within the enchanted confines of the Openshift castle.</p>"},{"location":"OpenShift%20Castle/15_resource_management/","title":"Command Line Resources Management","text":""},{"location":"OpenShift%20Castle/15_resource_management/#objective","title":"Objective","text":"<p>Master the art of managing resources through command-line interfaces within the mystical confines of the Openshift castle, enabling efficient resource creation and configuration.</p>"},{"location":"OpenShift%20Castle/15_resource_management/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of command-line resources management, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic familiarity with command-line interfaces (CLI) and container concepts.</li> </ul>"},{"location":"OpenShift%20Castle/15_resource_management/#introduction","title":"Introduction","text":"<p>Welcome, traveler, to the wondrous realms of the Openshift castle, where digital landscapes intertwine with mystical energies. As we navigate the labyrinthine corridors of this ancient stronghold, we discover the need to manage resources with precision and efficiency. Here, amidst the ever-changing vistas of digital realms, lies the power of command-line tools to shape and mold the fabric of existence itself.</p>"},{"location":"OpenShift%20Castle/15_resource_management/#command-line-resources-management_1","title":"Command Line Resources Management","text":""},{"location":"OpenShift%20Castle/15_resource_management/#imperative-commands-crafting-realms-with-swiftness","title":"Imperative Commands: Crafting Realms with Swiftness","text":"<p>Imperative commands such as <code>create</code>, <code>set</code>, and <code>run</code> serve as the swift hand of creation within the castle's halls. They offer a rapid means of crafting pods and other resources, bypassing the need for intricate object definitions. Like skilled artisans, troubleshooters wield these commands to forge new realms with speed and agility.</p>"},{"location":"OpenShift%20Castle/15_resource_management/#example-usage","title":"Example Usage","text":"<pre><code>oc run example-pod \\\n--image=docker.io/library/busybox \\\n--restart=Never \\\n-- echo \"Hello, world!\"\n</code></pre>"},{"location":"OpenShift%20Castle/15_resource_management/#declarative-commands-weaving-threads-of-intention","title":"Declarative Commands: Weaving Threads of Intention","text":"<p>Declarative commands beckon troubleshooters to weave threads of intention into the fabric of the digital tapestry. Through YAML files or templates, they define the desired state of resources, allowing for precise configuration and management. Within these commands lies the power to manifest visions into reality, shaping the very essence of the castle's domains.</p>"},{"location":"OpenShift%20Castle/15_resource_management/#example-usage_1","title":"Example Usage","text":"<pre><code>oc new-app --template hello-world \\\n--param MESSAGE=\"Hello, world!\"\n</code></pre>"},{"location":"OpenShift%20Castle/15_resource_management/#workload-resources-crafting-grand-designs","title":"Workload Resources: Crafting Grand Designs","text":"<p>Workload resources such as Jobs, Deployments, and StatefulSets represent the grand designs within the castle's architecture. With commands like <code>oc create job</code>, troubleshooters breathe life into these constructs, imbuing them with purpose and function. Through these commands, they orchestrate the movements of digital legions, fulfilling the castle's ever-changing needs.</p>"},{"location":"OpenShift%20Castle/15_resource_management/#example-usage_2","title":"Example Usage","text":"<pre><code>oc create job hello-job \\\n--image=docker.io/library/busybox \\\n-- /bin/echo \"Hello, world!\"\n</code></pre> <p>Embark on this grand journey of command-line resources management, as we navigate the enchanted pathways of creation and configuration within the mystical confines of the Openshift castle.</p>"},{"location":"OpenShift%20Castle/16_k8s_networking/","title":"Kubernetes Networking","text":""},{"location":"OpenShift%20Castle/16_k8s_networking/#objective","title":"Objective","text":"<p>Learn the intricacies of networking within the mystical realms of Openshift.</p>"},{"location":"OpenShift%20Castle/16_k8s_networking/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of Kubernetes networking, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Kubernetes concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/16_k8s_networking/#introduction","title":"Introduction","text":"<p>Welcome, traveler, to the ethereal realm of Kubernetes networking within the enchanted confines of the Openshift castle. Here, amidst the swirling energies of digital landscapes, lies the essence of seamless communication and load balancing among pods and services. Join us as we unravel the mysteries of Kubernetes networking and delve into the inner workings of the OpenShift Cluster Network Operator.</p>"},{"location":"OpenShift%20Castle/16_k8s_networking/#kubernetes-networking_1","title":"Kubernetes Networking","text":""},{"location":"OpenShift%20Castle/16_k8s_networking/#services-anchors-in-the-digital-seas","title":"Services: Anchors in the Digital Seas","text":"<p>In Kubernetes, services serve as anchors in the vast digital seas, providing permanent, static IP addresses for groups of pods belonging to the same deployment or replica set. These services offer load balancing for client requests among member pods, ensuring resilience and reliability within the castle's domains.</p>"},{"location":"OpenShift%20Castle/16_k8s_networking/#creating-services-with-oc-expose","title":"Creating Services with <code>oc expose</code>","text":"<p>To create a service in Openshift, troubleshooters can utilize the <code>oc expose</code> command, specifying parameters such as selector, port, target port, and protocol:</p> <pre><code>oc expose deployment/&lt;deployment-name&gt; [--selector &lt;selector&gt;] [--port &lt;port&gt;] [--target-port &lt;target port&gt;] [--protocol &lt;protocol&gt;] [--name &lt;name&gt;]\n</code></pre>"},{"location":"OpenShift%20Castle/16_k8s_networking/#viewing-service-endpoints","title":"Viewing Service Endpoints","text":"<p>To view the endpoints associated with a service, troubleshooters can use the <code>oc get endpoints</code> command, gaining insights into the connectivity and reachability of pods within the cluster.</p>"},{"location":"OpenShift%20Castle/16_k8s_networking/#internal-dns-resolution","title":"Internal DNS Resolution","text":"<p>Kubernetes employs an internal DNS server, visible only to pods, which assigns DNS names to defined services. These DNS names follow a specific format:</p> <pre><code>SVC-NAME.PROJECT-NAME.svc.CLUSTER-DOMAIN\n</code></pre>"},{"location":"OpenShift%20Castle/16_k8s_networking/#the-openshift-cluster-network-operator","title":"The OpenShift Cluster Network Operator","text":"<p>The OpenShift Cluster Network Operator (CNO) configures network settings within the Openshift cluster, ensuring seamless integration with Container Network Interface (CNI) plugins. As a cluster administrator, troubleshooters can observe the status of the CNO using commands like <code>oc get</code> and <code>oc describe</code>.</p>"},{"location":"OpenShift%20Castle/16_k8s_networking/#example-usage","title":"Example Usage","text":"<pre><code>oc get -n openshift-network-operator deployment/network-operator\noc describe network.config/cluster\n</code></pre> <p>Embark on this grand journey of Kubernetes networking, as we navigate the digital seas and unravel the mysteries of connectivity and communication within the enchanted confines of the Openshift castle.</p>"},{"location":"OpenShift%20Castle/17_routes_external_connectivity/","title":"Routes for External Connectivity","text":""},{"location":"OpenShift%20Castle/17_routes_external_connectivity/#objective","title":"Objective","text":"<p>Learn how to expose applications to external networks in the mystical realms of Openshift through routes.</p>"},{"location":"OpenShift%20Castle/17_routes_external_connectivity/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of routes for external connectivity, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Openshift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/17_routes_external_connectivity/#introduction","title":"Introduction","text":"<p>Welcome, adventurer, to the realm of routes for external connectivity within the enchanted confines of Openshift. Here, amidst the shifting currents of digital networks, lies the key to exposing applications to the outside world. Join us as we unravel the mysteries of routes and learn how to pave pathways for external access to your applications.</p>"},{"location":"OpenShift%20Castle/17_routes_external_connectivity/#routes-for-external-connectivity_1","title":"Routes for External Connectivity","text":""},{"location":"OpenShift%20Castle/17_routes_external_connectivity/#exposing-applications-to-the-outside-world","title":"Exposing Applications to the Outside World","text":"<p>In Openshift, routes provide a means to expose applications to external networks, allowing them to be accessed with unique hostnames that are publicly accessible. Routes rely on Kubernetes ingress controllers to redirect traffic from public IP addresses to pods, offering additional features such as TLS re-encryption, TLS passthrough, and support for blue-green deployments.</p>"},{"location":"OpenShift%20Castle/17_routes_external_connectivity/#creating-routes-with-oc-expose","title":"Creating Routes with <code>oc expose</code>","text":"<p>To create a route in Openshift, troubleshooters can utilize the <code>oc expose</code> command, specifying parameters such as hostname and service:</p> <p><pre><code>oc expose service &lt;service-name&gt; --hostname &lt;hostname&gt;\n</code></pre> e.g.: <pre><code>oc expose service nginx --hostname castle-of-dreams.example.com\n</code></pre></p> <p>If the hostname is omitted, Openshift generates a hostname with the following structure: <code>&lt;route-name&gt;-&lt;project-name&gt;.&lt;default-domain&gt;</code></p>"},{"location":"OpenShift%20Castle/17_routes_external_connectivity/#minimal-route-definition","title":"Minimal Route Definition","text":"<p>A minimal definition for a route typically includes the following:</p> <p><pre><code>kind: Route\napiVersion: route.openshift.io/v1\nmetadata:\n  name: &lt;route-name&gt;\nspec:\n  host: &lt;hostname&gt;\n  to:\n    kind: Service\n    name: &lt;service-name&gt;\n  port:\n    targetPort: &lt;target-port&gt;\n</code></pre> e.g.: <pre><code>kind: Route\napiVersion: route.openshift.io/v1\nmetadata:\n  name: castle-of-dreams-route\nspec:\n  host: castle-of-dreams.example.com\n  to:\n    kind: Service\n    name: nginx\n  port:\n    targetPort: 80\n</code></pre></p>"},{"location":"OpenShift%20Castle/17_routes_external_connectivity/#deleting-routes","title":"Deleting Routes","text":"<p>To delete a route in Openshift, troubleshooters can use the following command:</p> <p><pre><code>oc delete route &lt;route-name&gt;\n</code></pre> e.g.: <pre><code>oc delete route castle-of-dreams-route\n</code></pre></p> <p>Embark on this journey of routes for external connectivity, as we pave pathways for accessing applications from the outside world within the mystical confines of the Openshift castle.</p>"},{"location":"OpenShift%20Castle/18_sticky_sessions/","title":"Sticky Sessions","text":""},{"location":"OpenShift%20Castle/18_sticky_sessions/#objective","title":"Objective","text":"<p>Learn how to configure sticky sessions in the mystical realms of Openshift to maintain session persistence for user requests.</p>"},{"location":"OpenShift%20Castle/18_sticky_sessions/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of sticky sessions, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Openshift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/18_sticky_sessions/#introduction","title":"Introduction","text":"<p>Welcome, traveler, to the realm of sticky sessions within the enchanted confines of Openshift. Here, amidst the ebb and flow of digital traffic, lies the art of maintaining session persistence for user requests. Join us as we delve into the mysteries of sticky sessions and learn how to configure them to ensure seamless user experiences.</p>"},{"location":"OpenShift%20Castle/18_sticky_sessions/#sticky-sessions_1","title":"Sticky Sessions","text":""},{"location":"OpenShift%20Castle/18_sticky_sessions/#configuring-session-persistence","title":"Configuring Session Persistence","text":"<p>RHOCP utilizes cookies to configure session persistence for ingress and route resources. The ingress controller selects an endpoint to handle user requests and creates a cookie for the session. This cookie is then passed back in response to the request, allowing the ingress controller to route subsequent requests to the same pod, ensuring session continuity.</p>"},{"location":"OpenShift%20Castle/18_sticky_sessions/#overwriting-default-cookie-name","title":"Overwriting Default Cookie Name","text":"<p>By default, RHOCP auto-generates the cookie name for ingress and route resources. However, troubleshooters can overwrite this default cookie name using the <code>annotate</code> command with either <code>kubectl</code> or <code>oc</code>. </p>"},{"location":"OpenShift%20Castle/18_sticky_sessions/#example-usage","title":"Example Usage","text":"<pre><code>oc annotate ingress ingr-example ingress.kubernetes.io/affinity=cookie\noc annotate route route-example router.openshift.io/cookie_name=myapp\nROUTE_NAME=$(oc get route &lt;route_name&gt; -o jsonpath='{.spec.host}')\ncurl $ROUTE_NAME -k -c /tmp/cookie_jar\n</code></pre> <p>The cookie is passed back in response to the request and is saved to the <code>/tmp/cookie_jar</code> directory.</p> <p>Embark on this journey of sticky sessions, as we configure session persistence to ensure uninterrupted user experiences within the mystical confines of the Openshift castle.</p>"},{"location":"OpenShift%20Castle/19_scaling/","title":"Scale Application","text":""},{"location":"OpenShift%20Castle/19_scaling/#objective","title":"Objective","text":"<p>Learn how to scale applications in the mystical realms of Openshift to meet varying workload demands.</p>"},{"location":"OpenShift%20Castle/19_scaling/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of scaling applications, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Openshift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/19_scaling/#introduction","title":"Introduction","text":"<p>Welcome, valiant protector, to the realm of scaling the fortress within the enchanted confines of Openshift. Just as a fortress must adapt its defenses to withstand the onslaught of adversaries, so too must your applications be scaled to meet the ever-changing demands of your digital realm. Join us as we explore the methods of fortification and learn how to adapt to the shifting landscapes of workload demands.</p>"},{"location":"OpenShift%20Castle/19_scaling/#scaling-the-fortress","title":"Scaling the Fortress","text":""},{"location":"OpenShift%20Castle/19_scaling/#manually-adjusting-replicas-rallying-the-troops","title":"Manually Adjusting Replicas: Rallying the Troops","text":"<p>In Openshift, troubleshooters can manually adjust the number of replicas for a deployment to scale the fortress up or down according to the intensity of the siege. This enables them to efficiently allocate resources and maintain performance under varying circumstances.</p>"},{"location":"OpenShift%20Castle/19_scaling/#example-usage","title":"Example Usage","text":"<pre><code>oc scale --replicas 5 deployment/fortress\n</code></pre> <p>Embark on this journey of scaling the fortress, as we wield the power to adapt and fortify our defenses within the ever-changing landscapes of Openshift.</p>"},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/","title":"Secrets &amp; Configmaps","text":""},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#objective","title":"Objective","text":"<p>Learn how to create secrets and configmaps, to inject as volumes, and manipulate them to securely store sensitive information and configuration data.</p>"},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#prerequisites","title":"Prerequisites","text":"<p>To embark on this journey of fortifying the bastion, you'll need:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Openshift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#introduction","title":"Introduction","text":"<p>Welcome, guardian of secrets, to the realm of fortifying the bastion within the enchanted confines of Openshift. Just as a fortress requires secure storage for its most sensitive information and precise configuration for its inner workings, so too must your applications be fortified with secrets and configmaps. Join us as we delve into the art of safeguarding your fortress and ensuring its resilience against digital adversaries.</p>"},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#creating-secrets-and-configmaps","title":"Creating Secrets and Configmaps","text":""},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#crafting-shields-and-scrolls","title":"Crafting Shields and Scrolls","text":"<p>In Openshift, troubleshooters can create secrets and configmaps to fortify the bastion of their fortress. Secrets provide a secure means of storing sensitive information such as passwords, API tokens, and certificates, while configmaps hold configuration data in the form of key-value pairs.</p>"},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#example-usage","title":"Example Usage","text":"<pre><code>oc create secret generic &lt;secret_name&gt; \\\n--from-literal &lt;key1&gt;=&lt;secret1&gt; \\\n--from-literal &lt;key2&gt;=&lt;secret2&gt;\n\noc create secret tls &lt;secret_tls_name&gt; \\\n--cert /&lt;path-to-certificate&gt; --key /&lt;path-to-key&gt;\n\noc create cm &lt;configmap_name&gt; \\\n--from-literal &lt;key1&gt;=&lt;config1&gt; --from-literal &lt;key2&gt;=&lt;config2&gt;\n</code></pre> <p>These commands populate the 'create' command with the necessary files or key-value pairs, similar to the 'kubectl' command, enabling troubleshooters to fortify their fortress with shields and scrolls of secrecy and configuration. Mind as usual, that data created in this way are not encrypted, an expert thief would be able to retrieve them.</p> <p>You can apply these configurations in a declarative way too, utilizing the yaml scrolls, and remember to inject them in the corresponding deployment to make them active.</p>"},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#secrets-and-configmaps-as-volumes","title":"Secrets and Configmaps as Volumes","text":""},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#unveiling-hidden-treasures","title":"Unveiling Hidden Treasures","text":"<p>In the realm of Openshift, intrepid explorers can bind secrets and configmaps to directories within their fortress's chambers. By doing so, they allow their applications to access the secrets and configuration data securely, akin to uncovering hidden treasures within the labyrinthine corridors of their bastion.</p>"},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#example-usage_1","title":"Example Usage","text":"<pre><code>oc set volume deployment/my-app --add --type secret --secret-name my-app-secret --mount-path /app-secrets\n</code></pre> <p>With this command, troubleshooters can mount the created secrets to an '/app-secrets' directory within the pod, granting their applications access to the concealed knowledge securely.</p> <p>To confirm the attachment of the volume to the deployment, one may invoke:</p> <pre><code>oc set volume deployment/my-app\n</code></pre> <p>Furthermore, to seamlessly integrate these treasures into the fabric of your applications, you can set environment variables from the secrets and configmaps. For instance:</p> <pre><code>oc set env deployment/my-app \\\n--from secret/my-app-secret --prefix MYSQL_\n</code></pre> <p>This command augments the application's environment variables with the key-value pairs from the secrets, enabling seamless interaction with the concealed knowledge within the fortress.</p>"},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#updating-and-deleting-secrets-configmaps","title":"Updating and Deleting Secrets &amp; Configmaps","text":""},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#manipulating-the-threads-of-fate","title":"Manipulating the Threads of Fate","text":"<p>In the labyrinthine corridors of Openshift, troubleshooters can manipulate the threads of fate that bind secrets and configmaps to their fortress's essence. By deftly updating and deleting these artifacts, they ensure the resilience and security of their bastion's secrets and configurations.</p>"},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#example-usage_2","title":"Example Usage","text":"<p>To update secrets and configmaps from the command line, troubleshooters embark on a two-step journey of visualization and effective modification. For instance:</p> <pre><code>oc extract secret/my-app-secrets -n demo --to /tmp/my-app --confirm\noc set data secret/my-app-secrets -n demo --from-file /tmp/my-app/root_password\n</code></pre> <p>These commands allow troubleshooters to visualize and locally edit the secrets and configmaps before effecting the update, ensuring precision and accuracy in their modifications. After updating, it's essential to restart the pods to ensure they read the updated values, unless they are mounted as volumes and the software doesn't read the configuration data only at startup time.</p> <p>For secrets and configmaps that have outlived their purpose and are no longer needed, troubleshooters can invoke the 'delete' command, liberating their fortress from the burdens of obsolete artifacts. For example:</p> <pre><code>kubectl delete secret/my-app-secrets -n demo\noc delete configmap/my-app-map -n demo\n</code></pre> <p>With these commands, troubleshooters can seamlessly update and delete secrets and configmaps, maintaining the sanctity and security of their fortress within the mystical confines of Openshift.</p>"},{"location":"OpenShift%20Castle/20_secrets_and_configmaps/#conclusion","title":"Conclusion","text":"<p>Fortify your bastion and safeguard your fortress against the machinations of digital adversaries within the mystical confines of Openshift.</p>"},{"location":"OpenShift%20Castle/21_persistent_storage/","title":"Persistent Storage","text":""},{"location":"OpenShift%20Castle/21_persistent_storage/#objective","title":"Objective","text":"<p>Master the realm of persistent storage within Openshift, enabling your applications to retain critical data across time and space.</p>"},{"location":"OpenShift%20Castle/21_persistent_storage/#prerequisites","title":"Prerequisites","text":"<p>Before delving into the depths of persistent storage, ensure you possess:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Familiarity with basic Openshift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/21_persistent_storage/#introduction","title":"Introduction","text":"<p>Welcome, custodian of continuity, to the arcane realm of persistent storage within the fortified bastion of Openshift. As the guardian of data across the ebb and flow of time, you possess the power to shape the very essence of continuity within your fortress. Join us as we unravel the mysteries of creating and managing persistent volumes, ensuring the perpetuity of your fortress's data within the mystical confines of Openshift.</p>"},{"location":"OpenShift%20Castle/21_persistent_storage/#creating-persistent-volumes-pvs","title":"Creating Persistent Volumes (PVs)","text":""},{"location":"OpenShift%20Castle/21_persistent_storage/#forging-the-chains-of-continuity","title":"Forging the Chains of Continuity","text":"<p>In the realm of Openshift, troubleshooters can forge the chains of continuity by creating persistent volumes (PVs) through declarative means. Utilizing YAML manifests, they define the characteristics of the PV, such as capacity, access modes, and storage classes.</p>"},{"location":"OpenShift%20Castle/21_persistent_storage/#example-usage","title":"Example Usage","text":"<p>To create a Persistent Volume, troubleshooters can wield the power of YAML manifests, crafting the essence of continuity within their fortress. For instance:</p> my-app.pv.yaml<pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: my-app-pv\nspec:\n  capacity:\n    storage: 20Gi\n  accessModes:\n    - ReadWriteOnce\n  volumeMode: Block\n  persistentVolumeReclaimPolicy: Retain\n  fc:\n    targetWWNs: [\"12345a1234567bcd1\"]\n    lun: 0\n    readOnly: false\n</code></pre> <p>With this manifest, troubleshooters define a Persistent Volume named \"my-app-pv\" with a capacity of 20Gi, accessible in ReadWriteOnce mode. They can then create the PV using the command:</p> <pre><code>oc create -f my-app.pv.yaml\n</code></pre>"},{"location":"OpenShift%20Castle/21_persistent_storage/#claiming-persistent-volume-storage-pvc","title":"Claiming Persistent Volume Storage (PVC)","text":""},{"location":"OpenShift%20Castle/21_persistent_storage/#embracing-the-threads-of-destiny","title":"Embracing the Threads of Destiny","text":"<p>Once the PV is forged, troubleshooters can embrace the threads of destiny by claiming its storage through Persistent Volume Claims (PVCs). By specifying the desired characteristics such as capacity and access mode, they bind the PV to their application's essence, ensuring continuity and resilience.</p>"},{"location":"OpenShift%20Castle/21_persistent_storage/#example-usage_1","title":"Example Usage","text":"<p>To claim persistent volume storage, troubleshooters manifest the essence of their destiny within the PVC. For example:</p> my-app.pvc.yaml<pre><code>apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: my-app-pvc\n  labels:\n    app: my-app\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 15Gi\n</code></pre> <p>With this manifest, troubleshooters define a PVC named \"my-app-pvc\" requesting 15Gi of storage in ReadWriteOnce mode. They can then generate the PVC using the command:</p> <pre><code>oc create -f my-app.pvc.yaml\n</code></pre>"},{"location":"OpenShift%20Castle/21_persistent_storage/#managing-persistent-volumes-in-deployments","title":"Managing Persistent Volumes in Deployments","text":""},{"location":"OpenShift%20Castle/21_persistent_storage/#weaving-destiny-into-the-fabric-of-applications","title":"Weaving Destiny into the Fabric of Applications","text":"<p>With the PVs and PVCs crafted, troubleshooters can weave the threads of destiny into the fabric of their applications by mounting the PVCs within their deployments. Utilizing the 'set volumes' command, they bind the PVC to the desired mount path within the deployment, ensuring seamless interaction between the application and its persistent storage.</p>"},{"location":"OpenShift%20Castle/21_persistent_storage/#example-usage_2","title":"Example Usage","text":"<p>To mount PVCs within deployments, troubleshooters invoke the 'set volumes' command, integrating destiny into the fabric of their applications. For instance:</p> <pre><code>oc set volumes deployment/my-app \\\n--add \\\n--name my-app-pv \\\n--type persistentVolumeClaim \\\n--claim-mode rwo \\\n--claim-size 15Gi \\\n--mount-path /var/lib/my-app \\\n--claim-name my-app-pvc\n</code></pre>"},{"location":"OpenShift%20Castle/21_persistent_storage/#managing-persistent-volumes","title":"Managing Persistent Volumes","text":""},{"location":"OpenShift%20Castle/21_persistent_storage/#ensuring-the-continuity-of-destiny","title":"Ensuring the Continuity of Destiny","text":"<p>In the ever-evolving saga of your fortress's destiny, troubleshooters must master the art of managing persistent volumes. From retrieval to deletion, they must ensure the continuity and resilience of their fortress's data across time and space.</p>"},{"location":"OpenShift%20Castle/21_persistent_storage/#retrieving-persistent-volumes","title":"Retrieving Persistent Volumes","text":"<p>Troubleshooters can retrieve information about persistent volumes using the 'get' command. For instance:</p> <pre><code>oc get pv\n</code></pre> <p>This command provides an overview of all persistent volumes within the Openshift cluster, enabling troubleshooters to monitor and manage their fortress's storage resources.</p>"},{"location":"OpenShift%20Castle/21_persistent_storage/#deleting-persistent-volumes","title":"Deleting Persistent Volumes","text":"<p>In the cycle of renewal and rebirth, troubleshooters must sometimes release the shackles of the past by deleting persistent volumes that have outlived their purpose. Deleting a PV is a multi-step process that involves careful consideration and execution to ensure the continuity and resilience of the fortress's data.</p>"},{"location":"OpenShift%20Castle/21_persistent_storage/#step-1-delete-the-pvc","title":"Step 1: Delete the PVC","text":"<p>Before deleting a PV, troubleshooters must first delete the associated PVC to release the claim on the volume. For example:</p> <pre><code>oc delete pvc my-app-pvc\n</code></pre> <p>This command frees the PVC named \"my-app-pvc\" from the confines of the fortress, preparing the PV for deletion.</p>"},{"location":"OpenShift%20Castle/21_persistent_storage/#step-2-delete-the-pv","title":"Step 2: Delete the PV","text":"<p>Once the PVC is deleted, troubleshooters can proceed to delete the PV using the 'delete' command. For example:</p> <pre><code>oc delete pv my-app-pv\n</code></pre> <p>This command releases the persistent volume named \"my-app-pv\" from the Openshift cluster, ensuring the continuity and resilience of the fortress's storage resources.</p>"},{"location":"OpenShift%20Castle/21_persistent_storage/#conclusion","title":"Conclusion","text":"<p>Embark on this journey of continuity and resilience within the fortified bastion of Openshift. By mastering the art of persistent storage, you ensure the perpetuity of your fortress's data, safeguarding it against the ravages of time and entropy.</p>"},{"location":"OpenShift%20Castle/22_storage_class/","title":"Storage Classes","text":""},{"location":"OpenShift%20Castle/22_storage_class/#objective","title":"Objective","text":"<p>Delve into the realm of storage classes within Openshift, understanding how they define the characteristics and capabilities of persistent storage for your applications.</p>"},{"location":"OpenShift%20Castle/22_storage_class/#prerequisites","title":"Prerequisites","text":"<p>Before embarking on this journey of storage classes, ensure you possess:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Familiarity with basic Openshift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/22_storage_class/#introduction","title":"Introduction","text":"<p>Welcome, architect of storage, to the realm of storage classes within the fortified bastion of Openshift. As the weaver of storage destinies, you possess the power to define the characteristics and capabilities of persistent storage within your fortress. Join us as we unravel the mysteries of crafting and managing storage classes, empowering your applications with tailored storage solutions within the mystical confines of Openshift.</p>"},{"location":"OpenShift%20Castle/22_storage_class/#defining-storage-classes","title":"Defining Storage Classes","text":""},{"location":"OpenShift%20Castle/22_storage_class/#crafting-the-blueprint-of-destiny","title":"Crafting the Blueprint of Destiny","text":"<p>In the tapestry of persistent storage, storage classes serve as the blueprint of destiny, defining the characteristics and capabilities of persistent volumes (PVs). Through declarative means, troubleshooters manifest the essence of their storage solutions, specifying parameters such as storage provider, volume type, and reclaim policy.</p>"},{"location":"OpenShift%20Castle/22_storage_class/#example-usage","title":"Example Usage","text":"<p>To craft a storage class, troubleshooters wield the power of YAML manifests, defining the blueprint of destiny within their fortress. For example:</p> io1-gold-storage.yaml<pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: io1-gold-storage\n  annotations:\n    storageclass.kubernetes.io/is-default-class: 'false'\n    description: 'Provides RWO and RWOP Filesystem &amp; Block volumes'\nparameters:\n  type: io1\n  iopsPerGB: \"10\"\nprovisioner: kubernetes.io/aws-ebs\nreclaimPolicy: Delete\nvolumeBindingMode: Immediate\nallowVolumeExpansion: true\n</code></pre> <p>With this manifest, troubleshooters define a storage class named \"io1-gold-storage\", specifying parameters such as storage type, IOPS per GB, provisioner, and reclaim policy. They can then create the storage class using the command:</p> <pre><code>oc create -f io1-gold-storage.yaml\n</code></pre>"},{"location":"OpenShift%20Castle/22_storage_class/#conclusion","title":"Conclusion","text":"<p>Embark on this journey of crafting storage destinies within the fortified bastion of Openshift. By mastering the art of storage classes, you empower your applications with tailored storage solutions, ensuring their resilience and efficiency within the mystical confines of Openshift.</p>"},{"location":"OpenShift%20Castle/23_stateful_set/","title":"StatefulSet Configuration","text":""},{"location":"OpenShift%20Castle/23_stateful_set/#objective","title":"Objective","text":"<p>Configure StatefulSets effectively in your Kubernetes cluster.</p>"},{"location":"OpenShift%20Castle/23_stateful_set/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to a Kubernetes cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Kubernetes concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/23_stateful_set/#introduction","title":"Introduction","text":"<p>In the dynamic landscape of Kubernetes, most applications are designed to be stateless, akin to agile warriors traversing the castle's battlements. However, certain applications, such as databases, require persistent storage and consistent identities across pod restarts. StatefulSets serve as the stout walls and sturdy gates of the castle, providing the necessary mechanisms to manage such stateful applications within Kubernetes clusters.</p>"},{"location":"OpenShift%20Castle/23_stateful_set/#statefulset-configuration-building-the-castles-keep","title":"StatefulSet Configuration: Building the Castle's Keep","text":""},{"location":"OpenShift%20Castle/23_stateful_set/#understanding-stateful-components","title":"Understanding Stateful Components","text":"<p>StatefulSets enable the deployment of stateful applications by providing ordered pod creation, stable network identifiers, and unique persistent storage for each pod instance. This ensures that each pod in the StatefulSet maintains a consistent identity across restarts and rescheduling, much like the steadfast guards stationed atop the castle's towers.</p>"},{"location":"OpenShift%20Castle/23_stateful_set/#example-manifest-fortifying-the-castle-walls","title":"Example Manifest: Fortifying the Castle Walls","text":"mysql-server.statefulset.yaml<pre><code>apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: mysql-server\nspec:\n  selector:\n    matchLabels:\n      app: database\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: database\n    spec:\n      containers:\n      - env:\n        - name: MYSQL_USER\n          valueFrom:\n            secretKeyRef:\n              key: user\n              name: db-credentials\n        image: mysql/mysql-server:8.0\n        name: database\n        ports:\n        - containerPort: 3306\n          name: database\n        volumeMounts:\n        - mountPath: /var/lib/mysql\n          name: data\n      terminationGracePeriodSeconds: 10\n  volumeClaimTemplates:\n  - metadata:\n      name: data\n    spec:\n      accessModes: [ \"ReadWriteOnce\" ]\n      storageClassName: \"example-storage-class\"\n      resources:\n        requests:\n          storage: 2Gi\n</code></pre> <p>In this manifest, we erect the castle's keep, naming it \"mysql-server\" with three replicas. Each replica houses a pod with a MySQL database container, fortified with persistent storage for data persistence. The <code>volumeClaimTemplates</code> section outlines the blueprint for the persistent volume claim (PVC) used by each pod instance, ensuring the castle's storerooms remain well-stocked and impregnable.</p>"},{"location":"OpenShift%20Castle/23_stateful_set/#managing-statefulsets-protecting-the-castles-integrity","title":"Managing StatefulSets: Protecting the Castle's Integrity","text":"<p>StatefulSets, akin to the castle's ramparts and battlements, demand careful management to uphold the fortress's integrity and resilience. Let us explore how to safeguard and fortify our castle against potential threats.</p>"},{"location":"OpenShift%20Castle/23_stateful_set/#creating-a-statefulset-raising-the-castles-walls","title":"Creating a StatefulSet: Raising the Castle's Walls","text":"<p>To raise the castle's walls, apply the manifest file using the <code>kubectl create</code> command:</p> <p><pre><code>kubectl create -f &lt;stateful_manifest_name&gt;\n</code></pre> For instance: <pre><code>kubectl create -f mysql-server.statefulset.yaml\n</code></pre></p>"},{"location":"OpenShift%20Castle/23_stateful_set/#updating-a-statefulset-reinforcing-the-castles-defenses","title":"Updating a StatefulSet: Reinforcing the Castle's Defenses","text":"<p>To reinforce the castle's defenses, edit the manifest file accordingly and apply the changes using <code>kubectl apply</code>:</p> <p><pre><code>kubectl apply -f &lt;stateful_manifest_name&gt;\n</code></pre> For example: <pre><code>kubectl apply -f updated-mysql-server.statefulset.yaml\n</code></pre></p>"},{"location":"OpenShift%20Castle/23_stateful_set/#deleting-a-statefulset-securing-the-castle-gates","title":"Deleting a StatefulSet: Securing the Castle Gates","text":"<p>To secure the castle gates and dismantle any potential threats, use the <code>kubectl delete</code> command:</p> <p><pre><code>kubectl delete statefulset &lt;statefulset_name&gt;\n</code></pre> For instance: <pre><code>kubectl delete statefulset mysql-server\n</code></pre></p>"},{"location":"OpenShift%20Castle/23_stateful_set/#conclusion","title":"Conclusion","text":"<p>StatefulSets serve as the bastions of fortitude within Kubernetes clusters, safeguarding stateful applications with unwavering resilience. By mastering their configuration and management principles, you can fortify the castle of your Kubernetes realm, ensuring the perpetuity and security of your data with the stalwart vigilance of its guardians.</p>"},{"location":"OpenShift%20Castle/24_health_probes/","title":"Application of Health Probes","text":""},{"location":"OpenShift%20Castle/24_health_probes/#objective","title":"Objective","text":"<p>Explore the crucial role of health probes in maintaining the well-being of your applications within the Openshift cluster.</p>"},{"location":"OpenShift%20Castle/24_health_probes/#prerequisites","title":"Prerequisites","text":"<p>Before beginning your journey into health probes, ensure you have:</p> <ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Openshift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/24_health_probes/#introduction","title":"Introduction","text":"<p>Greetings, vigilant guardian of application health! Within the fortified bastion of Openshift, health probes serve as your ever-watchful sentinels, constantly monitoring the vitality of your applications. As the steward of application well-being, you wield the power to deploy readiness, liveness, and startup probes, ensuring that your applications thrive within the mystical realm of Openshift. Join us as we delve into the art of configuring and applying health probes, fortifying your applications against the perils of downtime.</p>"},{"location":"OpenShift%20Castle/24_health_probes/#understanding-health-probes","title":"Understanding Health Probes","text":""},{"location":"OpenShift%20Castle/24_health_probes/#the-watchful-sentinels-of-your-application","title":"The Watchful Sentinels of Your Application","text":"<p>In the enchanted world of Openshift, health probes are your watchful sentinels, each with a unique role to play:</p> <ul> <li>Readiness Probes: Ensure your application is ready to serve requests.</li> <li>Liveness Probes: Confirm that your application is running and healthy.</li> <li>Startup Probes: Verify that your application has successfully started.</li> </ul> <p>These probes can perform tests using HTTP GET requests, container commands, or TCP socket connections. Timing variables, such as how often the probe runs and how many attempts it should make before failing, help fine-tune their behavior.</p>"},{"location":"OpenShift%20Castle/24_health_probes/#configuring-health-probes","title":"Configuring Health Probes","text":""},{"location":"OpenShift%20Castle/24_health_probes/#crafting-the-sentinels","title":"Crafting the Sentinels","text":"<p>Health probes can be added to your workload resources, such as deployments, by updating and applying a YAML file or by using the <code>oc edit</code> command.</p>"},{"location":"OpenShift%20Castle/24_health_probes/#example-usage-with-yaml","title":"Example Usage with YAML","text":"<p>In this example, a liveness probe is configured for a container named \"my-app\":</p> liveness-probe-deployment.yaml<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: liveness-probe-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: my-app\n  template:\n    metadata:\n      labels:\n        app: my-app\n    spec:\n      containers:\n      - name: my-app\n        image: my-app:latest\n        livenessProbe:\n          failureThreshold: 10\n          periodSeconds: 5\n          httpGet:\n            path: /health\n            port: 3000\n</code></pre> <p>This manifest sets up a liveness probe to check the <code>/health</code> endpoint every 5 seconds, failing after 10 unsuccessful attempts. Apply this configuration using the command:</p> <pre><code>oc create -f liveness-probe-deployment.yaml\n</code></pre>"},{"location":"OpenShift%20Castle/24_health_probes/#configuring-probes-via-cli","title":"Configuring Probes via CLI","text":"<p>You can also set up health probes directly through the CLI. For example, to add a readiness probe to a deployment named \"my-app\":</p> <pre><code>oc set probe deployment/my-app \\\n--readiness \\\n--failure-threshold 10 \\\n--period-seconds 5 \\\n--get-url http://:8080/healthz\n</code></pre>"},{"location":"OpenShift%20Castle/24_health_probes/#conclusion","title":"Conclusion","text":"<p>Embark on the journey of deploying health probes within the fortified bastion of Openshift. By mastering the art of configuring readiness, liveness, and startup probes, you ensure your applications are resilient and responsive, maintaining their vitality within the mystical confines of Openshift.</p>"},{"location":"OpenShift%20Castle/25_pod_scheduling/","title":"Pod Scheduling","text":""},{"location":"OpenShift%20Castle/25_pod_scheduling/#objective","title":"Objective","text":"<p>Understand the intricacies of pod scheduling within the Openshift cluster, ensuring efficient and optimal placement of your applications.</p>"},{"location":"OpenShift%20Castle/25_pod_scheduling/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Openshift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/25_pod_scheduling/#introduction","title":"Introduction","text":"<p>Greetings, master scheduler of the mystical realm! Within the fortified bastion of Openshift, the pod scheduler acts as the wise overseer, orchestrating the placement of your application pods onto the nodes of your cluster. As the steward of resource allocation, you wield the power to filter, prioritize, and select the best nodes, ensuring that your applications run efficiently and reliably. Join us on a journey to uncover the secrets of pod scheduling and master the art of optimal pod placement.</p>"},{"location":"OpenShift%20Castle/25_pod_scheduling/#understanding-pod-scheduling","title":"Understanding Pod Scheduling","text":""},{"location":"OpenShift%20Castle/25_pod_scheduling/#the-orchestration-of-resource-allocation","title":"The Orchestration of Resource Allocation","text":"<p>In the enchanted world of Openshift, pod scheduling is akin to assigning the best quarters to your loyal subjects within the castle. This process involves three main steps:</p> <ol> <li> <p>Filtering Nodes: The scheduler evaluates which nodes are suitable based on the criteria specified by the pods, such as node selectors and resource requests for CPU, memory, and storage. Only the nodes meeting these requirements are considered eligible. If no eligible nodes are found, a FailedScheduling event is triggered, indicating that no suitable quarters are available.</p> </li> <li> <p>Prioritizing Nodes: Among the eligible nodes, the scheduler assigns weighted scores based on various criteria, determining their suitability for hosting the pod. Nodes with higher scores are considered better candidates.</p> </li> <li> <p>Selecting the Best Fit Node: The scheduler sorts the nodes by their scores and selects the highest-scoring node to host the pod. If multiple nodes share the highest score, the scheduler employs a round-robin method to choose one. Once a suitable node is selected, a Scheduled event is generated for the pod.</p> </li> </ol>"},{"location":"OpenShift%20Castle/25_pod_scheduling/#configuring-pod-scheduling","title":"Configuring Pod Scheduling","text":""},{"location":"OpenShift%20Castle/25_pod_scheduling/#crafting-the-perfect-quarters","title":"Crafting the Perfect Quarters","text":"<p>To ensure your applications are allocated the best quarters within the castle, you can customize the scheduling process by defining specific criteria.</p>"},{"location":"OpenShift%20Castle/25_pod_scheduling/#example-usage-with-node-selectors-and-resource-requests","title":"Example Usage with Node Selectors and Resource Requests","text":"<p>Here\u2019s how to configure a pod with specific node selectors and resource requests:</p> pod-scheduling-example.yaml<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-app-pod\nspec:\n  containers:\n  - name: my-app-container\n    image: my-app:latest\n    resources:\n      requests:\n        memory: \"64Mi\"\n        cpu: \"250m\"\n  nodeSelector:\n    disktype: ssd\n</code></pre> <p>In this example, the pod named \"my-app-pod\" requests specific CPU and memory resources and is scheduled to nodes labeled with <code>disktype=ssd</code>. Apply this configuration using the command:</p> <pre><code>oc create -f pod-scheduling-example.yaml\n</code></pre>"},{"location":"OpenShift%20Castle/25_pod_scheduling/#customizing-scheduling-via-cli","title":"Customizing Scheduling via CLI","text":"<p>You can also set node selectors and resource requests directly through the CLI. For example, to schedule a pod with specific criteria:</p> <pre><code>oc run my-app-pod --image=my-app:latest --requests=cpu=250m,memory=64Mi --overrides='{ \"apiVersion\": \"v1\", \"spec\": { \"nodeSelector\": { \"disktype\": \"ssd\" } } }'\n</code></pre>"},{"location":"OpenShift%20Castle/25_pod_scheduling/#conclusion","title":"Conclusion","text":"<p>Embark on the journey of mastering pod scheduling within the fortified bastion of Openshift. By understanding and configuring the scheduling process, you ensure your applications are efficiently and reliably allocated the best quarters, maintaining their performance and resilience within the mystical confines of Openshift.</p>"},{"location":"OpenShift%20Castle/26_compute_resources/","title":"Compute Resources","text":""},{"location":"OpenShift%20Castle/26_compute_resources/#objective","title":"Objective","text":"<p>Learn how to define and manage compute resources for your containers in Openshift, ensuring efficient and optimal use of CPU and memory.</p>"},{"location":"OpenShift%20Castle/26_compute_resources/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Openshift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/26_compute_resources/#introduction","title":"Introduction","text":"<p>Welcome, esteemed guardian of resources! In the fortified castle of Openshift, you hold the power to allocate and manage the kingdom's precious resources. By defining resource requests and limits for your application containers, you ensure that each subject receives their fair share, preventing any single container from hoarding the castle\u2019s CPU and memory. Join us as we explore the art of managing compute resources, safeguarding the balance and efficiency of your applications within the Openshift kingdom.</p>"},{"location":"OpenShift%20Castle/26_compute_resources/#understanding-compute-resources","title":"Understanding Compute Resources","text":""},{"location":"OpenShift%20Castle/26_compute_resources/#the-lifeblood-of-your-applications","title":"The Lifeblood of Your Applications","text":"<p>In the magical realm of Openshift, compute resources are the lifeblood of your applications. Just as each knight in the castle requires provisions to maintain their strength, each container needs CPU and memory to function effectively. By setting resource requests and limits, you ensure that every container receives the necessary resources while preventing any from consuming too much.</p> <ul> <li>Resource Requests: The amount of CPU and memory guaranteed for a container.</li> <li>Resource Limits: The maximum amount of CPU and memory a container can use.</li> </ul>"},{"location":"OpenShift%20Castle/26_compute_resources/#configuring-compute-resources","title":"Configuring Compute Resources","text":""},{"location":"OpenShift%20Castle/26_compute_resources/#allocating-provisions-for-your-knights","title":"Allocating Provisions for Your Knights","text":"<p>To allocate resources for your containers, you can define resource requests and limits using YAML files or the CLI.</p>"},{"location":"OpenShift%20Castle/26_compute_resources/#example-usage-with-yaml","title":"Example Usage with YAML","text":"<p>Here\u2019s how to configure resource requests and limits for a container:</p> compute-resources-example.yaml<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-nginx-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: my-nginx\n  template:\n    metadata:\n      labels:\n        app: my-nginx\n    spec:\n      containers:\n      - name: my-nginx\n        image: nginx\n        resources:\n          requests:\n            cpu: \"1000m\"\n            memory: \"1Gi\"\n          limits:\n            cpu: \"200m\"\n            memory: \"1Gi\"\n</code></pre> <p>In this example, the container named \"my-nginx\" requests 1000 millicores (1 CPU) and 1Gi of memory, with limits set to 200 millicores and 1Gi of memory. Apply this configuration using the command:</p> <pre><code>oc create -f compute-resources-example.yaml\n</code></pre>"},{"location":"OpenShift%20Castle/26_compute_resources/#configuring-resources-via-cli","title":"Configuring Resources via CLI","text":"<p>You can also set resource requests and limits directly through the CLI. For example, to set resources for a deployment named \"my-nginx\":</p> <pre><code>oc set resources deployment my-nginx --requests cpu=1000m,memory=1Gi --limits cpu=200m,memory=1Gi\n</code></pre>"},{"location":"OpenShift%20Castle/26_compute_resources/#monitoring-and-managing-resources","title":"Monitoring and Managing Resources","text":"<p>To view the available and used resources of a node:</p> <pre><code>oc describe node &lt;node_name&gt;\n</code></pre> <p>To check the resource usage of a node:</p> <pre><code>oc adm top node &lt;node_name&gt;\n</code></pre> <p>To see the resource usage of all pods in a specific namespace:</p> <pre><code>oc adm top pods -n &lt;namespace_name&gt;\n</code></pre>"},{"location":"OpenShift%20Castle/26_compute_resources/#limit-compute-resources","title":"Limit Compute Resources","text":""},{"location":"OpenShift%20Castle/26_compute_resources/#preventing-resource-hoarding","title":"Preventing Resource Hoarding","text":"<p>By setting resource limits, you prevent any container from consuming excessive resources, ensuring fair distribution and maintaining the kingdom's harmony.</p>"},{"location":"OpenShift%20Castle/26_compute_resources/#example-usage-with-yaml_1","title":"Example Usage with YAML","text":"<p>To limit resources for a container, you define the limits section in the YAML file:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-nginx-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: my-nginx\n  template:\n    metadata:\n      labels:\n        app: my-nginx\n    spec:\n      containers:\n      - name: my-nginx\n        image: nginx\n        resources:\n          requests:\n            cpu: \"100m\"\n            memory: \"1Gi\"\n          limits:\n            cpu: \"200m\"\n            memory: \"1Gi\"\n</code></pre> <p>If the container exceeds its memory limit, it will be terminated by the Out Of Memory (OOM) killer. If it exceeds its CPU limit, it will be throttled, slowing down its execution.</p>"},{"location":"OpenShift%20Castle/26_compute_resources/#configuring-limits-via-cli","title":"Configuring Limits via CLI","text":"<p>To set limits using the CLI:</p> <pre><code>oc set resources deployment/my-app --limits memory=1Gi\noc set resources deployment/my-app --limits cpu=200m\n</code></pre>"},{"location":"OpenShift%20Castle/26_compute_resources/#conclusion","title":"Conclusion","text":"<p>Embark on the journey of mastering compute resources within the fortified bastion of Openshift. By understanding and configuring resource requests and limits, you ensure fair and efficient allocation of CPU and memory, maintaining the balance and harmony of your applications within the mystical confines of Openshift.</p>"},{"location":"OpenShift%20Castle/27_application_autoscaling/","title":"Application Autoscaling","text":""},{"location":"OpenShift%20Castle/27_application_autoscaling/#objective","title":"Objective","text":"<p>Understand the mechanisms of horizontal pod autoscaling within the Openshift cluster to ensure your applications can dynamically scale based on demand.</p>"},{"location":"OpenShift%20Castle/27_application_autoscaling/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Openshift concepts and command-line interfaces (CLI).</li> <li>Resource requests specified for your pods to allow autoscaling based on metrics.</li> </ul>"},{"location":"OpenShift%20Castle/27_application_autoscaling/#introduction","title":"Introduction","text":"<p>Greetings, noble overseer of the dynamic kingdom! In the fortified bastion of Openshift, the horizontal pod autoscaler acts as the magical force that adjusts your application\u2019s resources in response to the ever-changing demands of the realm. By setting up autoscaling, you ensure that your applications can handle fluctuating workloads, maintaining their performance and resilience. Join us as we delve into the arcane art of application autoscaling, enabling your applications to thrive within the Openshift kingdom.</p>"},{"location":"OpenShift%20Castle/27_application_autoscaling/#understanding-application-autoscaling","title":"Understanding Application Autoscaling","text":""},{"location":"OpenShift%20Castle/27_application_autoscaling/#the-magic-of-dynamic-resource-allocation","title":"The Magic of Dynamic Resource Allocation","text":"<p>In the enchanted world of Openshift, the horizontal pod autoscaler (HPA) is your ally in maintaining balance. It uses performance metrics collected by the Openshift Metrics subsystem to automatically adjust the number of pods in a deployment based on demand.</p> <p>The autoscaler works in a loop, performing these steps every 15 seconds by default:</p> <ol> <li>Retrieve Metrics: The autoscaler fetches the scaling metric details from the HPA resource.</li> <li>Collect Metrics: For each targeted pod, the autoscaler gathers metrics from the metrics subsystem.</li> <li>Compute Usage Percentage: It calculates the usage percentage for each pod using the collected metrics and the pod's resource requests.</li> <li>Calculate Average Usage: It computes the average usage and resource requests across all targeted pods, establishing a usage ratio.</li> <li>Make Scaling Decision: The autoscaler uses this ratio to decide whether to scale the number of pods up or down.</li> </ol>"},{"location":"OpenShift%20Castle/27_application_autoscaling/#configuring-application-autoscaling","title":"Configuring Application Autoscaling","text":""},{"location":"OpenShift%20Castle/27_application_autoscaling/#casting-the-autoscaling-spell","title":"Casting the Autoscaling Spell","text":"<p>To enable autoscaling for your deployment, you can create an HPA resource using the <code>oc autoscale</code> command or a YAML manifest.</p>"},{"location":"OpenShift%20Castle/27_application_autoscaling/#example-usage-with-oc-autoscale-command","title":"Example Usage with <code>oc autoscale</code> Command","text":"<p>Here\u2019s how to create an HPA resource for a deployment named \"my-app\" to scale between 1 and 10 pods, targeting 75% CPU usage:</p> <pre><code>oc autoscale deployment/my-app --min 1 --max 10 --cpu-percent 75\n</code></pre> <p>This command sets up an autoscaler that adjusts the number of pods based on their CPU usage, scaling up to a maximum of 10 pods when the average CPU usage exceeds 75%.</p>"},{"location":"OpenShift%20Castle/27_application_autoscaling/#example-usage-with-yaml","title":"Example Usage with YAML","text":"<p>Alternatively, you can define the HPA resource in a YAML file:</p> hpa-example.yaml<pre><code>apiVersion: autoscaling/v1\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: my-app\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: my-app\n  minReplicas: 1\n  maxReplicas: 10\n  targetCPUUtilizationPercentage: 80\n</code></pre> <p>Apply this configuration using the command:</p> <pre><code>oc apply -f hpa-example.yaml\n</code></pre>"},{"location":"OpenShift%20Castle/27_application_autoscaling/#monitoring-and-managing-autoscaling","title":"Monitoring and Managing Autoscaling","text":"<p>To check if the autoscaler has been correctly created in the current project:</p> <pre><code>oc get hpa\n</code></pre> <p>This command lists the HPAs in the current namespace, showing their status and metrics.</p>"},{"location":"OpenShift%20Castle/27_application_autoscaling/#conclusion","title":"Conclusion","text":"<p>Embark on the journey of mastering application autoscaling within the fortified bastion of Openshift. By configuring and managing horizontal pod autoscalers, you ensure your applications can dynamically adjust to varying workloads, maintaining their performance and resilience within the mystical confines of Openshift.</p>"},{"location":"OpenShift%20Castle/28_deployment_strategies/","title":"Deployment Strategies","text":""},{"location":"OpenShift%20Castle/28_deployment_strategies/#objective","title":"Objective","text":"<p>Learn how to select and implement deployment strategies in Openshift to minimize risks and ensure smooth application updates.</p>"},{"location":"OpenShift%20Castle/28_deployment_strategies/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Openshift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/28_deployment_strategies/#introduction","title":"Introduction","text":"<p>Welcome, strategic architect of the Openshift kingdom! Deploying application changes can be fraught with risks such as downtime, bugs, or performance issues. By carefully selecting and implementing deployment strategies, you can minimize these risks and ensure seamless updates. Join us as we explore the various deployment strategies available in Openshift, and learn how to apply them to safeguard your applications within the fortified castle.</p>"},{"location":"OpenShift%20Castle/28_deployment_strategies/#understanding-deployment-strategies","title":"Understanding Deployment Strategies","text":""},{"location":"OpenShift%20Castle/28_deployment_strategies/#the-art-of-strategic-deployment","title":"The Art of Strategic Deployment","text":"<p>In the magical realm of Openshift, deployment strategies are your tools for updating applications while minimizing impact. Whether you're gradually rolling out updates or replacing all instances at once, choosing the right strategy is crucial for maintaining the kingdom\u2019s stability.</p> <p>Just as a wise ruler plans the defense of a castle, you must plan your deployments to ensure the safety and efficiency of your applications.</p> <ul> <li> <p>RollingUpdate Strategy: Updates the application in stages, replacing one instance at a time until all are updated. This is the default strategy and ensures minimal downtime. Imagine a skilled knight replacing guards one by one at their posts, ensuring the castle remains protected at all times.</p> </li> <li> <p>Recreate Strategy: Terminates all instances of the application before deploying the new version, causing downtime but ensuring a clean slate. Picture the castle gates closing, all guards being replaced at once, and then reopening with fresh new protectors ready to defend.</p> </li> </ul>"},{"location":"OpenShift%20Castle/28_deployment_strategies/#configuring-deployment-strategies","title":"Configuring Deployment Strategies","text":""},{"location":"OpenShift%20Castle/28_deployment_strategies/#crafting-the-deployment-plan","title":"Crafting the Deployment Plan","text":"<p>To apply a deployment strategy, you modify the <code>.spec.strategy.type</code> property of the Deployment object. Let\u2019s delve into how you can configure these strategies using YAML.</p>"},{"location":"OpenShift%20Castle/28_deployment_strategies/#example-usage-with-yaml","title":"Example Usage with YAML","text":"<p>Here\u2019s how to define a RollingUpdate strategy in your deployment configuration:</p> deployment-strategy-example.yaml<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp2\nspec:\n  progressDeadlineSeconds: 600\n  replicas: 10\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: myapp2\n  strategy:\n    rollingUpdate:\n      maxSurge: 25%\n      maxUnavailable: 50%\n    type: RollingUpdate\n  template:\n    metadata:\n      labels:\n        app: myapp2\n    spec:\n      containers:\n      - name: myapp2\n        image: myapp:latest\n</code></pre> <p>Apply this configuration using the command:</p> <pre><code>oc apply -f deployment-strategy-example.yaml\n</code></pre>"},{"location":"OpenShift%20Castle/28_deployment_strategies/#managing-deployments-via-cli","title":"Managing Deployments via CLI","text":"<p>In times of change, even the most strategic plans may require adjustments. To pause and resume a rollout, preventing automatic updates and allowing for controlled deployment, you can command your army like this:</p> <pre><code>oc rollout pause deployment/myapp\noc rollout resume deployment/myapp\n</code></pre> <p>This is akin to pausing the changing of the guard, giving you control over when and how the new guards take their posts.</p>"},{"location":"OpenShift%20Castle/28_deployment_strategies/#replica-sets","title":"Replica Sets","text":"<p>When you create or update a Deployment object, Openshift generates a new ReplicaSet object with the updated pod template. Avoid directly editing ReplicaSet objects; instead, monitor their status as a vigilant ruler would:</p> <pre><code>oc get replicaset\n</code></pre>"},{"location":"OpenShift%20Castle/28_deployment_strategies/#rolling-back-deployments","title":"Rolling Back Deployments","text":"<p>If an update causes issues, you can roll back to a previous version, much like reverting to a tried and trusted defense strategy:</p> <pre><code>oc rollout undo deployment/myapp2\n</code></pre> <p>Monitor the rollout status with:</p> <pre><code>oc rollout status deployment/myapp2\n</code></pre>"},{"location":"OpenShift%20Castle/28_deployment_strategies/#handling-stuck-rollouts","title":"Handling Stuck Rollouts","text":"<p>For DeploymentConfig objects, you can cancel a stuck rollout. Think of this as aborting a flawed plan before it can jeopardize the castle\u2019s defenses:</p> <pre><code>oc rollout cancel\n</code></pre>"},{"location":"OpenShift%20Castle/28_deployment_strategies/#viewing-deployment-history","title":"Viewing Deployment History","text":"<p>Every wise ruler keeps records of past strategies. List all available revisions:</p> <pre><code>oc rollout history deployment/myapp2\n</code></pre> <p>For details about a specific revision, add the <code>--revision</code> option:</p> <pre><code>oc rollout history deployment/myapp2 --revision=1\n</code></pre>"},{"location":"OpenShift%20Castle/28_deployment_strategies/#conclusion","title":"Conclusion","text":"<p>Embark on the journey of mastering deployment strategies within the fortified bastion of Openshift. By understanding and implementing the appropriate strategies, you ensure your applications are updated smoothly, maintaining their performance and resilience within the mystical confines of Openshift.</p> <p>Just as a wise ruler safeguards their castle with strategic planning and vigilant management, you too can protect your applications and ensure their success within the Openshift kingdom.</p>"},{"location":"OpenShift%20Castle/29_image_streams/","title":"Image Streams","text":""},{"location":"OpenShift%20Castle/29_image_streams/#objective","title":"Objective","text":"<p>Learn how to leverage image streams in Openshift to ensure reproducible, stable deployments of containerized applications and facilitate rollbacks.</p>"},{"location":"OpenShift%20Castle/29_image_streams/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Openshift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/29_image_streams/#introduction","title":"Introduction","text":"<p>Greetings, esteemed overseer of the Openshift kingdom! Within the fortress of your realm, image streams are the enchanted scrolls that guide your applications to stable and reproducible deployments. Unlike the upstream Kubernetes lands, where resources reference container images directly, Openshift resources reference these magical image streams. By mastering image streams, you ensure that your applications can be deployed reliably and rolled back to their last known-good state whenever needed. Join us as we uncover the secrets of image streams and enhance your dominion over the Openshift kingdom.</p>"},{"location":"OpenShift%20Castle/29_image_streams/#understanding-image-streams","title":"Understanding Image Streams","text":""},{"location":"OpenShift%20Castle/29_image_streams/#the-enchantment-of-image-streams","title":"The Enchantment of Image Streams","text":"<p>In the mystical Openshift realm, image streams serve as a repository of container images, offering a stable, short name to reference these images, independent of registry servers and container runtime configurations. An image stream can reference multiple images from different registry servers and repositories, much like a library filled with books from various kingdoms, each tagged and cataloged for easy retrieval.</p> <p>These image streams store metadata about their corresponding images, enabling quicker search and inspection without accessing the source registry server. Tags within image streams can even store image layers locally, acting as a cache and avoiding the need to fetch layers from external servers.</p>"},{"location":"OpenShift%20Castle/29_image_streams/#describing-image-streams","title":"Describing Image Streams","text":""},{"location":"OpenShift%20Castle/29_image_streams/#visualizing-the-magic","title":"Visualizing the Magic","text":"<p>To see the source image and current image ID for each image stream tag, use the <code>describe</code> command. This command is like opening a magical tome that reveals the secrets of your image streams:</p> <pre><code>oc describe is keycloak -n openshift\n</code></pre>"},{"location":"OpenShift%20Castle/29_image_streams/#creating-image-streams-and-tags","title":"Creating Image Streams and Tags","text":""},{"location":"OpenShift%20Castle/29_image_streams/#conjuring-new-image-streams","title":"Conjuring New Image Streams","text":"<p>You can create image streams in your project so that resources, such as Deployment objects, can use them. Here's how to create an image stream named \"keycloak\":</p> <pre><code>oc create is keycloak\n</code></pre> <p>After creating the image stream, use the <code>oc create istag</code> command to add image stream tags. This is like inscribing new spells in your book of magic. For example, add the 20.0 and 19.0 tags to the keycloak image stream:</p> <pre><code>oc create istag keycloak:20.0 --from-image quay.io/keycloak/keycloak:20.0.2\noc create istag keycloak:19.0 --from-image quay.io/keycloak/keycloak:19.0\n</code></pre> <p>To update an image stream tag with a new source image reference:</p> <pre><code>oc tag SOURCE-IMAGE IMAGE-STREAM-TAG\n</code></pre> <p>For example:</p> <pre><code>oc tag quay.io/keycloak/keycloak:20.0.3 keycloak:20.0\n</code></pre> <p>Use the <code>describe</code> command to verify the SHA ID of the new image to ensure the tag has been updated.</p>"},{"location":"OpenShift%20Castle/29_image_streams/#importing-image-stream-tags-periodically","title":"Importing Image Stream Tags Periodically","text":""},{"location":"OpenShift%20Castle/29_image_streams/#automatic-updates-with-scheduled-imports","title":"Automatic Updates with Scheduled Imports","text":"<p>To keep your image stream tags up to date automatically, Openshift can periodically check for new image versions and update the tags when a new version is detected. This ensures your magical defenses are always current. Activate this periodic refresh with the <code>--scheduled</code> option:</p> <pre><code>oc tag quay.io/keycloak/keycloak:20.0.3 keycloak:20.0 --scheduled\n</code></pre> <p>The default interval between verifications is 15 minutes.</p>"},{"location":"OpenShift%20Castle/29_image_streams/#configuring-image-pull-through","title":"Configuring Image Pull-through","text":""},{"location":"OpenShift%20Castle/29_image_streams/#caching-images-locally","title":"Caching Images Locally","text":"<p>You can configure your image stream tags to cache the images in the Openshift internal container registry, ensuring quick access and reducing dependency on external sources. Use the <code>--reference-policy local</code> option:</p> <pre><code>oc tag quay.io/keycloak/keycloak:20.0.3 keycloak:20.0 --reference-policy local\n</code></pre>"},{"location":"OpenShift%20Castle/29_image_streams/#using-image-streams-in-deployments","title":"Using Image Streams in Deployments","text":""},{"location":"OpenShift%20Castle/29_image_streams/#enabling-local-lookup-policy","title":"Enabling Local Lookup Policy","text":"<p>When creating a Deployment object, you can specify an image stream instead of a container image from a registry. Enable the local lookup policy with:</p> <pre><code>oc set image-lookup keycloak\n</code></pre> <p>Verify the policy with:</p> <pre><code>oc describe is keycloak\n</code></pre> <p>To retrieve the local lookup policy status for all image streams in the current project:</p> <pre><code>oc set image-lookup\n</code></pre> <p>To disable the local lookup policy:</p> <pre><code>oc set image-lookup keycloak --enabled=false\n</code></pre>"},{"location":"OpenShift%20Castle/29_image_streams/#configuration-in-deployments","title":"Configuration in Deployments","text":"<p>You can configure a deployment to utilize an image stream by using the <code>--image</code> option when creating it:</p> <pre><code>oc create deployment mykeycloak --image keycloak:20.0\n</code></pre> <p>Openshift recognizes to look first for an image stream when a short name is used. This strategy ensures that your deployments are always using the most current and trusted images.</p> <p>Image streams can also be used with other Kubernetes resources such as jobs, cronjobs, and pods.</p>"},{"location":"OpenShift%20Castle/29_image_streams/#conclusion","title":"Conclusion","text":"<p>Embark on the journey of mastering image streams within the fortified bastion of Openshift. By understanding and implementing image streams, you ensure your applications are deployed reliably and can be easily rolled back to a stable state. Just as a wise ruler maintains a library of enchanted scrolls, you too can safeguard your applications and ensure their success within the Openshift kingdom.</p>"},{"location":"OpenShift%20Castle/30_configure_image_triggers/","title":"Configuring Image Triggers","text":""},{"location":"OpenShift%20Castle/30_configure_image_triggers/#objective","title":"Objective","text":"<p>Learn how to configure image triggers in Openshift to automate the rollout of new application versions when updated images become available.</p>"},{"location":"OpenShift%20Castle/30_configure_image_triggers/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Openshift concepts and command-line interfaces (CLI).</li> <li>Familiarity with image streams and deployment objects.</li> </ul>"},{"location":"OpenShift%20Castle/30_configure_image_triggers/#introduction","title":"Introduction","text":"<p>Welcome back, vigilant guardian of the Openshift kingdom! In our previous journey, we discovered the secrets of image streams, the enchanted scrolls that guide your applications to stable and reproducible deployments. Now, we delve into the arcane art of configuring image triggers, the magical mechanism that ensures your deployments automatically update when new versions of images are available. Just as a castle's defenses must be ever-ready for new threats, your deployments must seamlessly incorporate the latest enhancements. Join us as we unravel the mysteries of image triggers and fortify your Openshift domain.</p>"},{"location":"OpenShift%20Castle/30_configure_image_triggers/#understanding-image-triggers","title":"Understanding Image Triggers","text":""},{"location":"OpenShift%20Castle/30_configure_image_triggers/#the-magic-of-image-triggers","title":"The Magic of Image Triggers","text":"<p>In the enchanted Openshift realm, an image stream tag points to an immutable image, recording the SHA ID of the source image. When a new version of the image becomes available, the image stream tag can be updated to point to the new image. However, to ensure that deployment objects automatically roll out this new image, you must configure image triggers.</p> <p>Think of image triggers as the castle's automatic alarms that notify the guards of any changes and prompt immediate action to update defenses. These triggers ensure that your applications are always running the most current and secure versions.</p>"},{"location":"OpenShift%20Castle/30_configure_image_triggers/#configuring-image-triggers_1","title":"Configuring Image Triggers","text":""},{"location":"OpenShift%20Castle/30_configure_image_triggers/#setting-the-image-trigger","title":"Setting the Image Trigger","text":"<p>To configure an image trigger for a deployment object, use the <code>oc set triggers</code> command. This command is like casting a spell that binds the deployment to automatically update when the image stream tag is updated:</p> <pre><code>oc set triggers deployment/mykeycloak --from-image keycloak:20 --containers keycloak\n</code></pre> <p>This command sets up the trigger to update the deployment whenever the <code>keycloak:20</code> image stream tag is updated.</p>"},{"location":"OpenShift%20Castle/30_configure_image_triggers/#disabling-and-enabling-the-image-trigger","title":"Disabling and Enabling the Image Trigger","text":"<p>There may be times when you need to temporarily disable the image trigger. Use the <code>--manual</code> option to disable it, and the <code>--auto</code> option to re-enable it. This is akin to pausing and resuming the castle's alarms:</p> <pre><code>oc set triggers deployment/mykeycloak --manual --from-image keycloak:20 --containers keycloak\noc set triggers deployment/mykeycloak --auto --from-image keycloak:20 --containers keycloak\n</code></pre>"},{"location":"OpenShift%20Castle/30_configure_image_triggers/#removing-the-image-trigger","title":"Removing the Image Trigger","text":"<p>If you need to remove the triggers from all the containers in the deployment object, use the <code>--remove-all</code> option. This is like disarming all the castle's automatic alarms:</p> <pre><code>oc set triggers deployment/mykeycloak --remove-all\n</code></pre>"},{"location":"OpenShift%20Castle/30_configure_image_triggers/#image-triggers-and-rollouts","title":"Image Triggers and Rollouts","text":"<p>Another important detail is that when you use the <code>oc rollout undo</code> command, the image trigger gets disabled to prevent it from rolling out the newest image again. This ensures that your deployment reverts to the previous state without immediately updating to the latest image again:</p> <pre><code>oc rollout undo deployment/mykeycloak\n</code></pre> <p>For Openshift Deployment objects, this command works seamlessly. However, for Kubernetes deployment objects, the <code>rollout undo</code> command does not work the same way, and you need to manually revert the image stream tag.</p>"},{"location":"OpenShift%20Castle/30_configure_image_triggers/#aliasing-image-stream-tags","title":"Aliasing Image Stream Tags","text":"<p>You can also create multiple image stream tags that point to the same image and visualize that both tags point to the same image. This is like giving different names to the same enchanted scroll, making it easier to manage and reference:</p> <pre><code>oc tag --alias keycloak:20.0.2 keycloak:20\noc describe is keycloak\n</code></pre>"},{"location":"OpenShift%20Castle/30_configure_image_triggers/#conclusion","title":"Conclusion","text":"<p>Congratulations, noble protector of the Openshift kingdom! By mastering the art of configuring image triggers, you ensure that your applications automatically update to incorporate the latest enhancements, maintaining their resilience and security. Just as a wise ruler maintains vigilant and responsive defenses, you too can safeguard your applications and ensure their continuous improvement within the Openshift domain.</p>"},{"location":"OpenShift%20Castle/31_yaml_validation_and_comparison/","title":"YAML Validation and Resource Comparison","text":""},{"location":"OpenShift%20Castle/31_yaml_validation_and_comparison/#objective","title":"Objective","text":"<p>Learn how to validate YAML files and compare resources in Openshift to ensure error-free deployments.</p>"},{"location":"OpenShift%20Castle/31_yaml_validation_and_comparison/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of YAML syntax and Openshift command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/31_yaml_validation_and_comparison/#introduction","title":"Introduction","text":"<p>Welcome back, vigilant custodian of the Openshift kingdom! As you manage and deploy resources in your realm, ensuring the accuracy and validity of your configuration files is crucial. Just as a wise ruler meticulously inspects every decree before it is issued, you must validate your YAML files to prevent errors and ensure smooth deployments. Additionally, comparing resources allows you to see changes before applying them, much like reviewing the plans for castle upgrades. Join us on this journey as we master the arts of YAML validation and resource comparison to maintain the stability and security of your Openshift domain.</p>"},{"location":"OpenShift%20Castle/31_yaml_validation_and_comparison/#yaml-validation","title":"YAML Validation","text":""},{"location":"OpenShift%20Castle/31_yaml_validation_and_comparison/#the-importance-of-validation","title":"The Importance of Validation","text":"<p>In the Openshift kingdom, validating your YAML files is akin to checking the accuracy of a royal decree. It ensures that the configurations are correct and free of errors before they are applied, preventing disruptions and maintaining the smooth operation of your applications.</p>"},{"location":"OpenShift%20Castle/31_yaml_validation_and_comparison/#server-side-validation","title":"Server-Side Validation","text":"<p>To validate a YAML file before applying changes to a resource, use the <code>--dry-run=server</code> and <code>--validate=true</code> flags. The <code>--dry-run=server</code> option submits a server-side request without persisting the resource, while the <code>--validate=true</code> option uses a schema to validate the input and fails the request if it is invalid. This is like consulting with the royal council to verify the decree before issuing it:</p> <pre><code>kubectl apply -f ~/my-app/example-deployment.yaml --dry-run=server --validate=true\n</code></pre>"},{"location":"OpenShift%20Castle/31_yaml_validation_and_comparison/#client-side-validation","title":"Client-Side Validation","text":"<p>For a quick check that prints only the object that would be sent to the server, use the <code>--dry-run=client</code> option. This is akin to drafting the decree and reviewing it before presenting it to the council:</p> <pre><code>kubectl apply -f ~/my-app/example-deployment.yaml --dry-run=client\n</code></pre>"},{"location":"OpenShift%20Castle/31_yaml_validation_and_comparison/#comparing-resources","title":"Comparing Resources","text":""},{"location":"OpenShift%20Castle/31_yaml_validation_and_comparison/#the-art-of-comparison","title":"The Art of Comparison","text":"<p>Before making changes to your resources, it is wise to review the differences between the current live objects and the manifests. This practice helps you understand the impact of your changes and ensures that they align with your intentions. Think of this as comparing the old and new plans for a castle upgrade to ensure all improvements are beneficial.</p>"},{"location":"OpenShift%20Castle/31_yaml_validation_and_comparison/#using-kubectl-diff","title":"Using <code>kubectl diff</code>","text":"<p>The <code>kubectl diff</code> command allows you to review the differences between live objects and manifests. This command is like holding up two versions of a map to see what has changed:</p> <pre><code>kubectl diff -f example-deployment.yaml\n</code></pre> <p>By comparing the live state with your desired state, you can catch potential issues before they affect your running applications.</p>"},{"location":"OpenShift%20Castle/31_yaml_validation_and_comparison/#conclusion","title":"Conclusion","text":"<p>Congratulations, meticulous steward of the Openshift kingdom! By mastering YAML validation and resource comparison, you ensure that your deployments are accurate and error-free, maintaining the stability and security of your applications. Just as a wise ruler carefully reviews every decree and plan, you too can safeguard your Openshift domain by validating and comparing resources before applying changes.</p>"},{"location":"OpenShift%20Castle/32_management_with_kustomize/","title":"Manage resources with Kustomize","text":""},{"location":"OpenShift%20Castle/32_management_with_kustomize/#objective","title":"Objective","text":"<p>Learn how to use Kustomize to manage Kubernetes configurations, enabling declarative changes while preserving the original base YAML files.</p>"},{"location":"OpenShift%20Castle/32_management_with_kustomize/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Kubernetes and YAML syntax.</li> </ul>"},{"location":"OpenShift%20Castle/32_management_with_kustomize/#introduction","title":"Introduction","text":"<p>Welcome, master architect of the Openshift kingdom! Just as a wise ruler uses blueprints to design and modify their castle, Kustomize is a powerful tool that helps you manage and adapt your Kubernetes configurations. By grouping your resources into directories and utilizing Kustomize's capabilities, you can easily customize configurations for different environments while preserving the integrity of your original files. Join us as we explore the magical world of Kustomize and enhance your ability to manage the Openshift realm.</p>"},{"location":"OpenShift%20Castle/32_management_with_kustomize/#understanding-kustomize","title":"Understanding Kustomize","text":""},{"location":"OpenShift%20Castle/32_management_with_kustomize/#the-magic-of-kustomize","title":"The Magic of Kustomize","text":"<p>In the Openshift kingdom, Kustomize acts like a master builder\u2019s toolkit. It allows you to group Kubernetes resources in a directory, make declarative changes, and adapt these resources for various environments and clusters. Kustomize works on directories containing a <code>kustomization.yaml</code> file at the root, with the concepts of base and overlays guiding your modifications.</p>"},{"location":"OpenShift%20Castle/32_management_with_kustomize/#customizing-for-multiple-environments","title":"Customizing for Multiple Environments","text":"<p>Kustomize enables you to customize configurations for multiple environments using overlays and patching. This mechanism has two elements: patch and target. A patch specifies the changes to be made, while the target defines the specific resource to be modified.</p>"},{"location":"OpenShift%20Castle/32_management_with_kustomize/#example-of-patching","title":"Example of Patching","text":"<p>Consider the following example, where a <code>kustomization.yaml</code> file is used to apply patches directly within the file:</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nnamespace: stage-environment\npatches:\n- patch: |-\n    - op: replace\n    path: /metadata/name\n    value: my-app-stage\n  target:\n    kind: Deployment\n    name: my-app\n- patch: |-\n    - op: replace\n    path: /spec/replicas\n    value: 15\n  target:\n    kind: Deployment\n    name: my-app\nbases:\n- ../../base\ncommonLabels:\n  env: stage\n</code></pre> <p>Alternatively, you can use a separate patch file:</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nnamespace: prod-environment\npatches:\n- path: patch.yaml\n  target:\n    kind: Deployment\n    name: my-app\n  options:\n    allowNameChange: true\nbases:\n- ../../base\ncommonLabels:\n  env: prod\n</code></pre> <p>Where the <code>patch.yaml</code> file contains:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-app-prod\nspec:\n  replicas: 5\n</code></pre>"},{"location":"OpenShift%20Castle/32_management_with_kustomize/#view-deploy-and-delete-resources-using-kustomize","title":"View, Deploy, and Delete Resources Using Kustomize","text":""},{"location":"OpenShift%20Castle/32_management_with_kustomize/#rendering-manifests","title":"Rendering Manifests","text":"<p>To render the manifests without applying them to the cluster, use the <code>kubectl kustomize</code> command. This is like previewing the blueprints before constructing the castle:</p> <pre><code>kubectl kustomize &lt;kustomization-directory&gt;\n</code></pre> <p>For example:</p> <pre><code>kubectl kustomize overlay/production\n</code></pre>"},{"location":"OpenShift%20Castle/32_management_with_kustomize/#applying-kustomizations","title":"Applying Kustomizations","text":"<p>To apply the kustomization to the cluster, use the <code>-k</code> flag with <code>kubectl apply</code>. This is akin to putting the castle blueprints into action:</p> <pre><code>kubectl apply -k overlay/production\n</code></pre>"},{"location":"OpenShift%20Castle/32_management_with_kustomize/#deleting-resources","title":"Deleting Resources","text":"<p>To remove resources deployed using Kustomize, use the <code>-k</code> flag with the <code>oc delete</code> command. This is like dismantling a section of the castle according to the blueprints:</p> <pre><code>oc delete -k overlay/production\n</code></pre>"},{"location":"OpenShift%20Castle/32_management_with_kustomize/#conclusion","title":"Conclusion","text":"<p>Congratulations, master builder of the Openshift kingdom! By mastering Kustomize, you gain the power to manage and adapt your Kubernetes configurations with ease and precision. Just as a ruler carefully plans and modifies their castle, you can now ensure your applications are tailored to their environments while preserving the integrity of your original configurations. Embrace the power of Kustomize and fortify your Openshift domain with confidence.</p>"},{"location":"OpenShift%20Castle/33_kustomize_generators/","title":"Kustomize Generators","text":""},{"location":"OpenShift%20Castle/33_kustomize_generators/#objective","title":"Objective","text":"<p>Learn how to use Kustomize generators to create ConfigMaps and Secrets dynamically, ensuring flexible and reusable configurations for your Kubernetes resources.</p>"},{"location":"OpenShift%20Castle/33_kustomize_generators/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Kubernetes, YAML syntax, and Kustomize.</li> </ul>"},{"location":"OpenShift%20Castle/33_kustomize_generators/#introduction","title":"Introduction","text":"<p>Welcome, noble custodian of the Openshift kingdom! Within the walls of your realm, ConfigMaps and Secrets serve as the magical artifacts that configure and secure your applications. Kustomize generators allow you to dynamically create these artifacts, ensuring that your configurations are flexible, reusable, and easily managed. Join us as we delve into the enchantment of Kustomize generators and enhance your dominion over the Openshift kingdom.</p>"},{"location":"OpenShift%20Castle/33_kustomize_generators/#understanding-kustomize-generators","title":"Understanding Kustomize Generators","text":""},{"location":"OpenShift%20Castle/33_kustomize_generators/#the-magic-of-configmap-and-secret-generators","title":"The Magic of ConfigMap and Secret Generators","text":"<p>In the Openshift kingdom, Kustomize provides two powerful fields to generate ConfigMap and Secret resources: <code>configMapGenerator</code> and <code>secretGenerator</code>. These generators dynamically create configurations based on literals, files, or environment variables, allowing you to manage application settings and secrets efficiently.</p> <p>In your kingdom, imagine ConfigMaps as enchanted scrolls containing vital information and Secrets as hidden treasures known only to trusted allies. Kustomize generators are the scribes and treasure keepers, ensuring that these scrolls and treasures are created and maintained seamlessly.</p>"},{"location":"OpenShift%20Castle/33_kustomize_generators/#example-of-configmap-generator","title":"Example of ConfigMap Generator","text":"<p>Consider the following example, where a <code>kustomization.yaml</code> file includes a <code>configMapGenerator</code>:</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nnamespace: my-app-stage\nbases:\n- ../../base\nconfigMapGenerator:\n- name: my-app-configmap\n  literals:\n    - msg=\"Hello!\"\n    - enable=\"true\"\n</code></pre> <p>Executing the command <code>kubectl kustomize overlays/staging</code> will visualize a new ConfigMap, much like summoning a new enchanted scroll for your realm. Applying this configuration to the cluster ensures that the ConfigMap is incorporated into your Deployment:</p> <pre><code>kubectl apply -k overlays/staging\n</code></pre>"},{"location":"OpenShift%20Castle/33_kustomize_generators/#generating-configmaps-with-different-methods","title":"Generating ConfigMaps with Different Methods","text":"<p>Kustomize allows multiple ways to populate the <code>configMapGenerator</code> field, including using files, environment files, or key-value pairs. These methods are akin to gathering knowledge from different tomes, scrolls, and sages within your kingdom.</p>"},{"location":"OpenShift%20Castle/33_kustomize_generators/#using-files","title":"Using Files","text":"<pre><code>configMapGenerator:\n- name: configmap-1\n  files:\n    - application.properties\n</code></pre> <p>Example <code>application.properties</code> file:</p> application.properties<pre><code>Day=Monday\nEnable=True\n</code></pre>"},{"location":"OpenShift%20Castle/33_kustomize_generators/#using-environment-files","title":"Using Environment Files","text":"<pre><code>configMapGenerator:\n- name: configmap-2\n  envs:\n    - configmap-2.env\n</code></pre> <p>Example <code>configmap-2.env</code> file:</p> configmap-2.env<pre><code>Greet=Welcome\nEnable=True\n</code></pre>"},{"location":"OpenShift%20Castle/33_kustomize_generators/#using-literals","title":"Using Literals","text":"<pre><code>configMapGenerator:\n- name: configmap-3\n  literals:\n    - name=\"configmap-3\"\n    - description=\"literal key-value pair\"\n</code></pre>"},{"location":"OpenShift%20Castle/33_kustomize_generators/#viewing-configurations","title":"Viewing Configurations","text":"<p>To view the details of resources and customizations defined by your <code>kustomization.yaml</code> file, use the following command:</p> <pre><code>kubectl kustomize &lt;kustomization-directory&gt;\n</code></pre> <p>For example:</p> <pre><code>kubectl kustomize .\n</code></pre> <p>This command is like unfurling a detailed map of your kingdom, revealing the locations of all enchanted scrolls and hidden treasures.</p>"},{"location":"OpenShift%20Castle/33_kustomize_generators/#customizing-generator-behavior","title":"Customizing Generator Behavior","text":"<p>The <code>generatorOptions</code> field allows you to alter the default behavior of Kustomize generators. This provides further flexibility in how ConfigMaps and Secrets are generated and managed, ensuring that your kingdom's needs are always met.</p>"},{"location":"OpenShift%20Castle/33_kustomize_generators/#conclusion","title":"Conclusion","text":"<p>Congratulations, wise steward of the Openshift kingdom! By mastering Kustomize generators, you can dynamically create ConfigMaps and Secrets, ensuring your applications are configured and secured with the utmost flexibility and efficiency. Just as a ruler adapts their strategies to the needs of the realm, you can now tailor your configurations to meet the demands of your environments. Embrace the power of Kustomize generators and fortify your Openshift domain with confidence.</p> <p>With this newfound knowledge, you hold the keys to a well-organized and secure realm, where ConfigMaps and Secrets are generated with precision and ease. Your kingdom thrives under your vigilant guidance, as you skillfully wield the power of Kustomize to shape your domain.</p>"},{"location":"OpenShift%20Castle/34_templates/","title":"Templates","text":""},{"location":"OpenShift%20Castle/34_templates/#objective","title":"Objective","text":"<p>Learn how to use Openshift templates to define sets of Kubernetes resource configurations with customizable parameters.</p>"},{"location":"OpenShift%20Castle/34_templates/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Kubernetes, YAML syntax, and Openshift CLI commands.</li> </ul>"},{"location":"OpenShift%20Castle/34_templates/#introduction","title":"Introduction","text":"<p>Welcome, noble overseer of the Openshift kingdom! In your realm, templates are the blueprints that enable you to create and customize Kubernetes resources with ease. Red Hat's Openshift extends Kubernetes with template resources, allowing you to define, evaluate, and deploy configurations tailored to your needs. Join us as we explore the power of Openshift templates and enhance your control over the Openshift kingdom.</p>"},{"location":"OpenShift%20Castle/34_templates/#understanding-openshift-templates","title":"Understanding Openshift Templates","text":""},{"location":"OpenShift%20Castle/34_templates/#the-blueprint-of-resources","title":"The Blueprint of Resources","text":"<p>In the Openshift kingdom, templates are like blueprints stored in the royal library. These blueprints define sets of Kubernetes resource configurations with customizable parameters, allowing you to create various resources such as Pods, Services, and Deployments. With templates, you can standardize and streamline the deployment process, ensuring that your kingdom's resources are consistent and well-organized.</p> <p>Red Hat provides template resources as a Kubernetes extension, and the Cluster Samples Operator populates these templates in the <code>openshift</code> namespace. As the ruler of your realm, you have the power to opt-out of template addition during installation and customize templates to fit the unique needs of your projects.</p>"},{"location":"OpenShift%20Castle/34_templates/#viewing-templates","title":"Viewing Templates","text":"<p>To view the available templates in the <code>openshift</code> namespace, use the following command:</p> <pre><code>oc get templates -n openshift\n</code></pre> <p>This command is like opening a grand tome listing all the blueprints stored in your royal library.</p> <p>To evaluate a specific template and see its details, use:</p> <pre><code>oc describe template &lt;template-name&gt; -n openshift\n</code></pre> <p>This reveals the intricate designs and parameters of the selected blueprint, providing you with a deeper understanding of its structure.</p>"},{"location":"OpenShift%20Castle/34_templates/#viewing-template-parameters","title":"Viewing Template Parameters","text":"<p>To see only the parameters that a template uses, the <code>oc process</code> command provides the <code>--parameters</code> option:</p> <pre><code>oc process --parameters &lt;template-name&gt; -n openshift\n</code></pre> <p>This is akin to examining the key components and customizable elements of your blueprint, allowing you to tailor it to your needs.</p> <p>You can also view the parameters of a template defined in a file using the <code>-f</code> option:</p> <pre><code>oc process --parameters -f my-cache-service.yaml\n</code></pre>"},{"location":"OpenShift%20Castle/34_templates/#retrieving-template-manifests","title":"Retrieving Template Manifests","text":"<p>To retrieve the manifest of a template, use the following command:</p> <pre><code>oc get template cache-service -o yaml -n openshift\n</code></pre> <p>This command unfurls the complete blueprint, showing all the detailed configurations and settings defined within.</p>"},{"location":"OpenShift%20Castle/34_templates/#deploying-templates","title":"Deploying Templates","text":""},{"location":"OpenShift%20Castle/34_templates/#creating-resources-from-templates","title":"Creating Resources from Templates","text":"<p>When it's time to deploy the template, you can use the <code>--template</code> parameter with the <code>new-app</code> command to create resources directly from the openshift project:</p> <pre><code>oc new-app --template=cache-service -p APPLICATION_USER=my-user\n</code></pre> <p>This command is particularly convenient for non-production environments, allowing you to swiftly create new resources based on your blueprints. However, note that the <code>new-app</code> command is useful only for creating new resources, not for updating existing ones.</p>"},{"location":"OpenShift%20Castle/34_templates/#applying-parameters-to-templates","title":"Applying Parameters to Templates","text":"<p>To apply parameters to a template and process it, use the <code>oc process</code> command. This command can process both local and cluster templates:</p> <pre><code>oc process -f my-cache-service.yaml -p APPLICATION_USER=my-user | oc apply -f -\n</code></pre> <p>This process is like activating a magical spell, transforming the blueprint into tangible resources within your kingdom.</p>"},{"location":"OpenShift%20Castle/34_templates/#conclusion","title":"Conclusion","text":"<p>Congratulations, esteemed steward of the Openshift kingdom! By mastering Openshift templates, you can define, evaluate, and deploy sets of Kubernetes resource configurations with ease. These blueprints ensure that your deployments are consistent, efficient, and tailored to the unique needs of your projects. Embrace the power of templates and fortify your Openshift realm with confidence.</p> <p>With this knowledge, you hold the key to a well-structured and efficient kingdom, where resources are created and managed with precision and ease. Your kingdom thrives under your vigilant guidance, as you skillfully wield the power of Openshift templates to shape your domain.</p>"},{"location":"OpenShift%20Castle/35_deploy_and_update_from_templates/","title":"Deploying and Updating from Templates","text":""},{"location":"OpenShift%20Castle/35_deploy_and_update_from_templates/#objective","title":"Objective","text":"<p>Learn how to deploy and update applications using Openshift templates.</p>"},{"location":"OpenShift%20Castle/35_deploy_and_update_from_templates/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Kubernetes, YAML syntax, and Openshift CLI commands.</li> </ul>"},{"location":"OpenShift%20Castle/35_deploy_and_update_from_templates/#introduction","title":"Introduction","text":"<p>Welcome, noble custodian of the Openshift kingdom! As you navigate the realm of templates, you'll discover the art of deploying and updating applications seamlessly. By leveraging Openshift templates, you can transform parameterized blueprints into tangible resources and ensure your deployments are consistent and well-maintained. Embark on this journey to master the deployment and update of applications from templates, enhancing the stability and efficiency of your domain.</p>"},{"location":"OpenShift%20Castle/35_deploy_and_update_from_templates/#deploying-applications-from-templates","title":"Deploying Applications from Templates","text":""},{"location":"OpenShift%20Castle/35_deploy_and_update_from_templates/#transforming-templates-into-resources","title":"Transforming Templates into Resources","text":"<p>In the heart of your kingdom, the <code>oc process</code> command serves as the magical incantation that transforms templates into sets of related Kubernetes resource manifests. This command uses parameter values to shape the blueprint into a deployable form.</p> <p>To override default values and create a resource manifest, use the following command:</p> <pre><code>oc process my-cache-service -o yaml \\\n-p TOTAL_CONTAINER_MEM=1024 \\\n-p APPLICATION_USER='cache-user' \\\n-p APPLICATION_PASSWORD='my-secret-password' \\\n&gt; my-cache-service-manifest.yaml\n</code></pre> <p>This command is akin to tailoring a royal decree to fit the specific needs of your realm, adjusting parameters to ensure optimal performance.</p>"},{"location":"OpenShift%20Castle/35_deploy_and_update_from_templates/#using-parameter-files","title":"Using Parameter Files","text":"<p>For greater convenience and version control, save the parameters in a versioned file and apply it using the <code>--param-file</code> option:</p> <pre><code>oc process my-cache-service -o yaml \\\n--param-file=my-cache-service-params.env &gt; my-cache-service-manifest.yaml\n</code></pre> <p>This approach is like keeping a detailed ledger in the royal archives, ensuring all adjustments and configurations are well-documented and easily retrievable.</p>"},{"location":"OpenShift%20Castle/35_deploy_and_update_from_templates/#direct-deployment","title":"Direct Deployment","text":"<p>To skip the manifest generation and apply the resources directly to the cluster, use command piping:</p> <pre><code>oc process my-cache-service --param-file=my-cache-service-params.env | oc apply -f -\n</code></pre> <p>This method streamlines the deployment process, casting your spell directly onto the resources without intermediary steps, ensuring swift and efficient execution.</p>"},{"location":"OpenShift%20Castle/35_deploy_and_update_from_templates/#updating-applications-from-templates","title":"Updating Applications from Templates","text":""},{"location":"OpenShift%20Castle/35_deploy_and_update_from_templates/#comparing-updates","title":"Comparing Updates","text":"<p>Before updating resources, compare the results of the proposed update against the live resource using the <code>diff</code> command:</p> <pre><code>oc process my-cache-service -o yaml --param-file=my-cache-service-params-2.env | oc diff -f -\n</code></pre> <p>This step is like consulting the royal advisors to assess the impact of new decrees, ensuring that the proposed changes align with the kingdom's best interests.</p>"},{"location":"OpenShift%20Castle/35_deploy_and_update_from_templates/#applying-updates","title":"Applying Updates","text":"<p>Once verified, apply the updates by piping the commands:</p> <pre><code>oc process my-cache-service --param-file=my-cache-service-params-2.env | oc apply -f -\n</code></pre> <p>This command enacts the new configurations, updating the resources in your kingdom to reflect the latest adjustments, ensuring your realm remains well-maintained and up-to-date.</p>"},{"location":"OpenShift%20Castle/35_deploy_and_update_from_templates/#conclusion","title":"Conclusion","text":"<p>Congratulations, esteemed steward of the Openshift kingdom! By mastering the deployment and updating of applications from templates, you ensure your resources are efficiently managed and consistently configured. Embrace the power of templates to transform and maintain your realm, ensuring stability and efficiency in all your deployments.</p> <p>With these skills, you hold the key to a well-ordered and dynamic kingdom, where resources are deployed and updated with precision and ease. Your kingdom flourishes under your wise and vigilant guidance, as you expertly wield the power of Openshift templates to shape and enhance your domain.</p>"},{"location":"OpenShift%20Castle/36_managing_templates/","title":"Managing Templates","text":""},{"location":"OpenShift%20Castle/36_managing_templates/#objective","title":"Objective","text":"<p>Learn how to manage Openshift templates by customizing default values and creating templates for specific usage targets, ensuring efficient resource configuration in production environments.</p>"},{"location":"OpenShift%20Castle/36_managing_templates/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an Openshift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Kubernetes, YAML syntax, and Openshift CLI commands.</li> </ul>"},{"location":"OpenShift%20Castle/36_managing_templates/#introduction","title":"Introduction","text":"<p>Greetings, noble ruler of the Openshift kingdom! In your quest to maintain a well-ordered and efficient realm, mastering the management of templates is essential. By creating custom copies of templates and tailoring them to specific needs, you can ensure your resources are configured optimally for production workflows. Join us on this journey to refine your template management skills and enhance the stability and flexibility of your kingdom.</p>"},{"location":"OpenShift%20Castle/36_managing_templates/#managing-templates_1","title":"Managing Templates","text":""},{"location":"OpenShift%20Castle/36_managing_templates/#customizing-templates","title":"Customizing Templates","text":"<p>In the heart of your kingdom, it's crucial to customize templates to meet the specific needs of your realm. Begin by making a custom copy of the template to adjust the default values. For example, to copy the <code>cache-service</code> template to a file, use the following command:</p> <pre><code>oc get template cache-service -o yaml -n openshift &gt; my-cache-service.yaml\n</code></pre> <p>This action is akin to acquiring a blueprint from the royal archives, preparing it for modification to suit your unique requirements.</p>"},{"location":"OpenShift%20Castle/36_managing_templates/#setting-up-the-template","title":"Setting Up the Template","text":"<p>With the template copied, set it up by making the following adjustments:</p> <ol> <li>New Specific Name: Assign a new name relative to the usage target, ensuring clarity and specificity in its purpose.</li> <li>Change Default Values: Modify the default values of the parameters to align with your production needs.</li> <li>Remove Namespace Field: Eliminate the namespace field to allow the template to be used in any project.</li> </ol> <p>These steps ensure your template is finely tuned, ready to serve the distinct needs of your kingdom.</p>"},{"location":"OpenShift%20Castle/36_managing_templates/#uploading-the-template","title":"Uploading the Template","text":"<p>Once customized, you can upload the template to the current project with the following command:</p> <pre><code>oc create -f my-cache-service.yaml\n</code></pre> <p>This command is like inscribing your newly crafted decree into the royal records, making it available for deployment.</p> <p>Alternatively, to upload the template to a different project, use the <code>-n</code> option:</p> <pre><code>oc create -f my-cache-service.yaml -n another-project\n</code></pre> <p>Remember, this command creates the template but does not deploy the resources. It's akin to placing the blueprint in the hands of your engineers, ready for use when the time comes.</p>"},{"location":"OpenShift%20Castle/36_managing_templates/#conclusion","title":"Conclusion","text":"<p>Congratulations, esteemed custodian of the Openshift kingdom! By mastering the art of managing templates, you ensure your resources are configured optimally and tailored to the specific needs of your production environments. Embrace this power to create, customize, and manage templates, enhancing the efficiency and stability of your deployments.</p> <p>With these skills, you hold the key to a well-ordered and dynamic kingdom, where resources are finely tuned and readily available for deployment. Your kingdom flourishes under your wise and vigilant guidance, as you expertly wield the power of Openshift templates to shape and enhance your domain.</p>"},{"location":"OpenShift%20Castle/37_users_and_groups/","title":"Users and Groups","text":""},{"location":"OpenShift%20Castle/37_users_and_groups/#objective","title":"Objective","text":"<p>Understand the primary resources for authentication and access control in OpenShift, including users, identities, service accounts, groups, and roles, to manage permissions and secure interactions with the API server.</p>"},{"location":"OpenShift%20Castle/37_users_and_groups/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of OpenShift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/37_users_and_groups/#introduction","title":"Introduction","text":"<p>Greetings, vigilant guardian of the OpenShift kingdom! In your realm, managing who has access to what is paramount to maintaining order and security. OpenShift provides several resources to help you govern interactions with the API server. By understanding and utilizing users, identities, service accounts, groups, and roles, you can assign permissions effectively and safeguard your kingdom's integrity. Join us as we explore these essential elements of authentication and access control, and ensure your realm remains secure and well-regulated.</p>"},{"location":"OpenShift%20Castle/37_users_and_groups/#primary-resources-for-authentication","title":"Primary Resources for Authentication","text":""},{"location":"OpenShift%20Castle/37_users_and_groups/#user","title":"User","text":"<p>In the bustling marketplace of your kingdom, the User is like a citizen with a unique identity. These entities interact with the API server and represent actors within the system. Permissions for users can be assigned directly or through membership in groups.</p> <ul> <li>Usage: Users can perform various tasks and actions within the OpenShift environment, granted through role assignments.</li> </ul>"},{"location":"OpenShift%20Castle/37_users_and_groups/#identity","title":"Identity","text":"<p>Identity serves as the record keeper, documenting successful authentication attempts by users and identity providers. It stores data about the authentication source, ensuring that each interaction is traceable to its origin.</p> <ul> <li>Usage: Helps track authentication sources and verify user legitimacy within the kingdom.</li> </ul>"},{"location":"OpenShift%20Castle/37_users_and_groups/#service-account","title":"Service Account","text":"<p>A Service Account is akin to a trusted envoy, allowing applications to communicate independently with the API server. By using service accounts, you preserve the integrity of user credentials and avoid the risks associated with sharing them.</p> <ul> <li>Usage: Ensures secure application communication without exposing user credentials.</li> </ul>"},{"location":"OpenShift%20Castle/37_users_and_groups/#group","title":"Group","text":"<p>Group represents specific sets of users, much like guilds or councils within your kingdom. By assigning permissions to groups, you can collectively manage access for multiple users, streamlining the process of role assignment.</p> <ul> <li>Usage: Simplifies permission management by grouping users with similar roles or responsibilities.</li> </ul>"},{"location":"OpenShift%20Castle/37_users_and_groups/#role","title":"Role","text":"<p>The Role is the decree that defines what API operations users, groups, and service accounts can perform. Roles are granted through assignments, empowering actors within the system to carry out their duties effectively.</p> <ul> <li>Usage: Specifies permissions and access levels, ensuring that actors can perform necessary tasks while maintaining security.</li> </ul>"},{"location":"OpenShift%20Castle/37_users_and_groups/#conclusion","title":"Conclusion","text":"<p>Noble custodian of the OpenShift kingdom, you now possess the knowledge to manage users and groups effectively. By understanding the roles of users, identities, service accounts, groups, and roles, you can govern interactions with the API server, ensuring that your realm remains secure and well-regulated. Embrace these resources to assign permissions wisely, safeguard credentials, and maintain the integrity of your kingdom.</p> <p>With these skills, you are equipped to uphold order and security within your domain, ensuring that all actors can perform their duties while protecting the kingdom's treasures. Your vigilant management of users and groups fortifies your realm, keeping it safe and thriving under your wise and watchful eye.</p>"},{"location":"OpenShift%20Castle/38_authenticating_api_requests/","title":"Authenticating API Requests","text":""},{"location":"OpenShift%20Castle/38_authenticating_api_requests/#objective","title":"Objective","text":"<p>Learn how to authenticate API requests in OpenShift using OAuth access tokens and X.509 client certificates, and understand how to authenticate as a cluster administrator.</p>"},{"location":"OpenShift%20Castle/38_authenticating_api_requests/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of OpenShift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/38_authenticating_api_requests/#introduction","title":"Introduction","text":"<p>Greetings, vigilant guardian of the OpenShift kingdom! Ensuring secure access to your kingdom's API is paramount for maintaining order and protecting valuable resources. OpenShift offers two primary methods for authenticating API requests: OAuth access tokens and X.509 client certificates. By mastering these authentication methods, you can safeguard your realm and manage access effectively.</p>"},{"location":"OpenShift%20Castle/38_authenticating_api_requests/#authenticating-api-requests_1","title":"Authenticating API Requests","text":"<p>In the enchanted lands of OpenShift, the magical process of authenticating API requests ensures that only trusted entities can interact with the kingdom's precious resources.</p>"},{"location":"OpenShift%20Castle/38_authenticating_api_requests/#oauth-access-tokens","title":"OAuth Access Tokens","text":"<p>The OAuth access token is like a magical key granted by the Authentication operator, which runs an OAuth server. This key allows users to access the API and perform actions based on their roles and permissions.</p> <ul> <li>Usage: OAuth access tokens are generated after a successful login via an identity provider, much like a knight receiving a seal of approval to enter the royal court. These tokens are used to authenticate API requests, ensuring that only those with proper authorization can perform specific actions.</li> </ul>"},{"location":"OpenShift%20Castle/38_authenticating_api_requests/#x509-client-certificates","title":"X.509 Client Certificates","text":"<p>X.509 client certificates serve as trusted insignias, proving the identity of a client to the API server. These certificates are included in the kubeconfig file created during the OpenShift installation.</p> <ul> <li>Usage: X.509 certificates authenticate API requests by verifying the client's identity using a secure certificate, akin to presenting a royal decree that confirms one's noble status and right to access the kingdom's resources.</li> </ul>"},{"location":"OpenShift%20Castle/38_authenticating_api_requests/#authenticating-as-cluster-administrator","title":"Authenticating as Cluster Administrator","text":"<p>Before you can manage users and configure identity providers, you must authenticate as an administrator. Let's explore the methods to achieve this, ensuring you have the keys to the kingdom.</p>"},{"location":"OpenShift%20Castle/38_authenticating_api_requests/#authenticating-with-the-x509-certificate","title":"Authenticating with the X.509 Certificate","text":"<p>During installation, the OpenShift installer creates a unique kubeconfig file in the auth directory. This file contains specific details and parameters for the CLI to connect a client to the correct API server, including an X.509 certificate. Installation logs provide the location of the kubeconfig file:</p> <pre><code>INFO Run 'export KUBECONFIG=root/auth/kubeconfig' to manage the cluster with 'oc'.\n</code></pre> <p>To use the kubeconfig file to authenticate <code>oc</code> commands, follow these steps:</p> <ol> <li>Copy the kubeconfig file: Transfer the file to your workstation, much like carrying a royal decree to your chambers.</li> <li>Set the KUBECONFIG environment variable: Define the path to the kubeconfig file.</li> </ol> <pre><code>export KUBECONFIG=/home/user/auth/kubeconfig\noc get nodes\n</code></pre> <p>Alternatively, specify the kubeconfig file directly with the <code>oc</code> command:</p> <pre><code>oc --kubeconfig /home/user/auth/kubeconfig get nodes\n</code></pre>"},{"location":"OpenShift%20Castle/38_authenticating_api_requests/#authenticating-with-the-kubeadmin-virtual-user","title":"Authenticating with the kubeadmin Virtual User","text":"<p>After installation, OpenShift creates the kubeadmin virtual user. The kubeadmin secret in the kube-system namespace contains the hashed password for this user. The installation logs provide the kubeadmin credentials:</p> <pre><code>INFO The cluster is ready when 'oc login -u kubeadmin -p shdU_trbi_6ucX_edbu_aqop'\n</code></pre> <p>As the esteemed ruler, you can use these credentials to access the cluster and perform administrative tasks.</p>"},{"location":"OpenShift%20Castle/38_authenticating_api_requests/#deleting-the-virtual-user","title":"Deleting the Virtual User","text":"<p>To enhance cluster security, delete the kubeadmin user credentials after defining an identity provider, creating a user, and assigning that user the cluster-admin role:</p> <pre><code>oc delete secret kubeadmin -n kube-system\n</code></pre> <p>Even after deleting the virtual user, you can still log in through the kubeconfig file, ensuring that your kingdom's gates remain secure yet accessible to trusted administrators.</p>"},{"location":"OpenShift%20Castle/38_authenticating_api_requests/#conclusion","title":"Conclusion","text":"<p>Wise steward of the OpenShift kingdom, you now hold the knowledge to authenticate API requests securely and manage your domain effectively. By leveraging OAuth access tokens and X.509 client certificates, you can ensure that only trusted entities access your API. As a cluster administrator, you possess the authority to manage users and configure identity providers, further fortifying your realm's security. Embrace these authentication methods to safeguard your kingdom and maintain order within its boundaries.</p>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/","title":"The HTPasswd Identity Provider","text":""},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#objective","title":"Objective","text":"<p>Learn how to manage user credentials using the HTPasswd Identity Provider in OpenShift by creating, updating, and deleting users, as well as updating the HTPasswd secret.</p>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of OpenShift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#introduction","title":"Introduction","text":"<p>Welcome, guardian of the OpenShift kingdom! As the keeper of the realm, managing user credentials and ensuring secure access to your cluster is crucial. By using the HTPasswd Identity Provider, you can efficiently manage user credentials, ensuring only trusted individuals gain access to your kingdom's treasures.</p>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#managing-users-with-the-htpasswd-identity-provider","title":"Managing Users with the HTPasswd Identity Provider","text":""},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#step-1-creating-an-htpasswd-file","title":"Step 1: Creating an HTPasswd File","text":"<p>In the bustling courtyard of your castle, creating an HTPasswd file is akin to crafting a list of trusted knights who can access the kingdom. Use the following command to create this file:</p> <pre><code>htpasswd -c -B -b /tmp/htpasswd student redhat123\n</code></pre> <p>To add or update credentials for a user, use:</p> <pre><code>htpasswd -b /tmp/htpasswd student redhat1234\n</code></pre> <p>And to delete credentials for a user, use:</p> <pre><code>htpasswd -D /tmp/htpasswd student\n</code></pre>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#step-2-creating-the-htpasswd-secret","title":"Step 2: Creating the HTPasswd Secret","text":"<p>With the list of trusted knights prepared, the next step is to store it securely in the royal vaults, known in OpenShift as secrets. Create the HTPasswd secret with:</p> <pre><code>oc create secret generic htpasswd-secret --from-file htpasswd=/tmp/htpasswd -n openshift-config\n</code></pre>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#step-3-extracting-secret-data","title":"Step 3: Extracting Secret Data","text":"<p>When the time comes to update the list of knights, ensure you are working with the most current version. Extract the secret data:</p> <pre><code>oc extract secret/htpasswd-secret -n openshift-config --to /tmp/ --confirm\n</code></pre>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#step-4-updating-the-htpasswd-secret","title":"Step 4: Updating the HTPasswd Secret","text":"<p>After updating the list, store the new version back in the royal vaults:</p> <pre><code>oc set data secret/htpasswd-secret --from-file htpasswd=/tmp/htpasswd -n openshift-config\n</code></pre> <p>Monitor the redeployment of authentication pods to ensure the changes take effect:</p> <pre><code>watch oc get pods -n openshift-authentication\n</code></pre>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#deleting-users-and-identities","title":"Deleting Users and Identities","text":"<p>In the kingdom, removing a knight from service requires careful steps to ensure their access is fully revoked. Follow these steps to delete users and their identities.</p>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#step-1-deleting-the-user-from-htpasswd","title":"Step 1: Deleting the User from HTPasswd","text":"<p>Remove the user from the HTPasswd file:</p> <pre><code>htpasswd -D /tmp/htpasswd manager\n</code></pre>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#step-2-updating-the-secret","title":"Step 2: Updating the Secret","text":"<p>Update the secret to remove the user's credentials from the royal vaults:</p> <pre><code>oc set data secret/htpasswd-secret --from-file htpasswd=/tmp/htpasswd -n openshift-config\n</code></pre>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#step-3-removing-the-user-resource","title":"Step 3: Removing the User Resource","text":"<p>Remove the user resource from the OpenShift kingdom:</p> <pre><code>oc delete user manager\n</code></pre>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#step-4-deleting-the-identity-resource","title":"Step 4: Deleting the Identity Resource","text":"<p>Find and delete the identity resource associated with the user:</p> <pre><code>oc get identities | grep manager\noc delete identity my_htpasswd_provider:manager\n</code></pre>"},{"location":"OpenShift%20Castle/39_httpasswd_id_provider/#conclusion","title":"Conclusion","text":"<p>Noble guardian, you now possess the knowledge to manage user credentials using the HTPasswd Identity Provider. By creating, updating, and deleting users and their identities, you can maintain the security of your OpenShift kingdom. With these skills, you ensure that only trusted knights can access your realm, safeguarding its treasures and maintaining order.</p> <p>Embrace your role as the vigilant protector of the OpenShift kingdom, and may your reign be secure and prosperous!</p>"},{"location":"OpenShift%20Castle/40_assign_admin_privileges/","title":"Assigning Administrative Privileges","text":""},{"location":"OpenShift%20Castle/40_assign_admin_privileges/#objective","title":"Objective","text":"<p>Learn how to assign administrative privileges to users and groups in OpenShift using the cluster-admin role, granting them cluster-wide administrative capabilities.</p>"},{"location":"OpenShift%20Castle/40_assign_admin_privileges/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of OpenShift concepts and command-line interfaces (CLI).</li> </ul>"},{"location":"OpenShift%20Castle/40_assign_admin_privileges/#introduction","title":"Introduction","text":"<p>In the grand kingdom of OpenShift, the power to manage the realm lies in the hands of those with administrative privileges. Granting such power is not taken lightly, as it confers the ability to govern the entire cluster. This guide will lead you through the process of assigning the esteemed cluster-admin role to trusted individuals or groups, ensuring the smooth and secure operation of your OpenShift kingdom.</p>"},{"location":"OpenShift%20Castle/40_assign_admin_privileges/#assigning-administrative-privileges_1","title":"Assigning Administrative Privileges","text":""},{"location":"OpenShift%20Castle/40_assign_admin_privileges/#the-cluster-admin-role","title":"The Cluster-Admin Role","text":"<p>In the heart of the OpenShift castle, the cluster-admin role is akin to the title of High Steward, granting the bearer full administrative rights over the entire realm. This powerful role is essential for managing the kingdom's vast resources and ensuring its defenses are robust.</p>"},{"location":"OpenShift%20Castle/40_assign_admin_privileges/#step-1-identifying-trusted-nobles","title":"Step 1: Identifying Trusted Nobles","text":"<p>Before bestowing such a title, you must identify the noble knights and trusted advisors worthy of this responsibility. These individuals or groups should have a proven track record of loyalty and competence in managing the realm's affairs.</p>"},{"location":"OpenShift%20Castle/40_assign_admin_privileges/#step-2-granting-the-cluster-admin-role","title":"Step 2: Granting the Cluster-Admin Role","text":"<p>To elevate a user or group to the esteemed position of cluster-admin, use the following command. This command is your royal decree, granting them the necessary powers to govern the kingdom.</p> <pre><code>oc adm policy add-cluster-role-to-user cluster-admin &lt;user_name&gt;\n</code></pre> <p>Replace <code>&lt;user_name&gt;</code> with the name of the user or group you wish to elevate. For example, to grant cluster-admin privileges to a user named \"arthur\", the command would be:</p> <pre><code>oc adm policy add-cluster-role-to-user cluster-admin arthur\n</code></pre>"},{"location":"OpenShift%20Castle/40_assign_admin_privileges/#step-3-verifying-the-role-assignment","title":"Step 3: Verifying the Role Assignment","text":"<p>After issuing your decree, it is wise to verify that the privileges have been correctly assigned. You can check the roles assigned to a user with the following command:</p> <pre><code>oc get clusterrolebindings | grep &lt;user_name&gt;\n</code></pre> <p>For instance, to check the roles assigned to \"arthur\", use:</p> <pre><code>oc get clusterrolebindings | grep arthur\n</code></pre>"},{"location":"OpenShift%20Castle/40_assign_admin_privileges/#step-4-removing-administrative-privileges","title":"Step 4: Removing Administrative Privileges","text":"<p>In the event that a noble knight must be relieved of their duties, the cluster-admin role can be revoked. This ensures the kingdom's security remains intact and only trusted individuals retain administrative powers.</p> <p>To remove the cluster-admin role from a user, use the following command:</p> <pre><code>oc adm policy remove-cluster-role-from-user cluster-admin &lt;user_name&gt;\n</code></pre> <p>For example, to revoke the cluster-admin privileges from \"arthur\", the command would be:</p> <pre><code>oc adm policy remove-cluster-role-from-user cluster-admin arthur\n</code></pre>"},{"location":"OpenShift%20Castle/40_assign_admin_privileges/#best-practices-for-managing-administrative-privileges","title":"Best Practices for Managing Administrative Privileges","text":"<ul> <li>Selective Granting: Only grant the cluster-admin role to users or groups that require full administrative access.</li> <li>Regular Audits: Periodically review the roles and privileges assigned to users to ensure compliance with security policies.</li> <li>Training and Awareness: Ensure that users granted the cluster-admin role are well-trained and aware of their responsibilities and the potential impact of their actions.</li> </ul>"},{"location":"OpenShift%20Castle/40_assign_admin_privileges/#conclusion","title":"Conclusion","text":"<p>Noble guardian of the OpenShift kingdom, you now possess the knowledge to grant and manage administrative privileges within your realm. By carefully selecting trusted individuals and conferring upon them the cluster-admin role, you ensure that your kingdom is governed by capable and loyal stewards.</p> <p>As you continue to oversee the prosperous and secure operation of your OpenShift kingdom, remember that the power to manage the realm lies in the hands of those you trust. Use this power wisely, and may your reign be long and successful!</p>"},{"location":"OpenShift%20Castle/41_rbac_with_cli/","title":"Managing RBAC with the CLI","text":""},{"location":"OpenShift%20Castle/41_rbac_with_cli/#objective","title":"Objective","text":"<p>This guide will show you how to manage Role-Based Access Control (RBAC) in Red Hat OpenShift Container Platform (RHOCP) using the command-line interface (CLI). You'll learn how to assign and remove roles, manage cluster and namespace roles, and use the <code>oc adm policy</code> command for various RBAC operations.</p>"},{"location":"OpenShift%20Castle/41_rbac_with_cli/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster with the <code>oc</code> CLI installed.</li> <li>Basic knowledge of OpenShift and RBAC concepts.</li> </ul>"},{"location":"OpenShift%20Castle/41_rbac_with_cli/#introduction","title":"Introduction","text":"<p>In the medieval kingdom of OpenShift, roles and responsibilities are critical to maintaining order and ensuring the efficient management of resources. The King, represented by the cluster administrator, must delegate tasks and privileges wisely to ensure the realm runs smoothly. This guide will help you navigate the complexities of Role-Based Access Control (RBAC), much like a royal advisor guiding the king in appointing trusted stewards.</p>"},{"location":"OpenShift%20Castle/41_rbac_with_cli/#managing-rbac-with-the-cli_1","title":"Managing RBAC with the CLI","text":""},{"location":"OpenShift%20Castle/41_rbac_with_cli/#cluster-roles-and-local-roles","title":"Cluster Roles and Local Roles","text":"<p>OpenShift defines two main types of roles:</p> <ul> <li>Cluster Roles: These roles apply across the entire cluster and are managed by cluster administrators.</li> <li>Local Roles: These roles apply within a specific project (namespace) and are managed at the project level.</li> </ul>"},{"location":"OpenShift%20Castle/41_rbac_with_cli/#adding-a-cluster-role-to-a-user","title":"Adding a Cluster Role to a User","text":"<p>To grant a user a cluster-wide role, the King can issue a decree using the following command:</p> <pre><code>oc adm policy add-cluster-role-to-user &lt;cluster_role&gt; &lt;username&gt;\n</code></pre> <p>For example, to make \"arthur\" a cluster administrator:</p> <pre><code>oc adm policy add-cluster-role-to-user cluster-admin arthur\n</code></pre>"},{"location":"OpenShift%20Castle/41_rbac_with_cli/#changing-a-regular-user-to-a-cluster-administrator","title":"Changing a Regular User to a Cluster Administrator","text":"<p>To elevate a regular user to the status of a cluster administrator, use:</p> <pre><code>oc adm policy add-cluster-role-to-user cluster-admin &lt;username&gt;\n</code></pre> <p>Example:</p> <pre><code>oc adm policy add-cluster-role-to-user cluster-admin arthur\n</code></pre>"},{"location":"OpenShift%20Castle/41_rbac_with_cli/#removing-a-cluster-role-from-a-user","title":"Removing a Cluster Role from a User","text":"<p>If a noble knight must be relieved of their duties, the following command can be used:</p> <pre><code>oc adm policy remove-cluster-role-from-user &lt;cluster_role&gt; &lt;username&gt;\n</code></pre> <p>For instance, to revoke the cluster-admin role from \"arthur\":</p> <pre><code>oc adm policy remove-cluster-role-from-user cluster-admin arthur\n</code></pre>"},{"location":"OpenShift%20Castle/41_rbac_with_cli/#changing-a-cluster-administrator-to-a-regular-user","title":"Changing a Cluster Administrator to a Regular User","text":"<p>To demote a cluster administrator back to a regular user:</p> <pre><code>oc adm policy remove-cluster-role-from-user cluster-admin &lt;username&gt;\n</code></pre> <p>Example:</p> <pre><code>oc adm policy remove-cluster-role-from-user cluster-admin arthur\n</code></pre>"},{"location":"OpenShift%20Castle/41_rbac_with_cli/#determining-user-permissions-with-who-can","title":"Determining User Permissions with <code>who-can</code>","text":"<p>To investigate whether a user can perform a specific action on a resource, the King can use the <code>who-can</code> command:</p> <pre><code>oc adm policy who-can &lt;verb&gt; &lt;resource&gt;\n</code></pre> <p>For example, to check if \"arthur\" can delete resources:</p> <pre><code>oc adm policy who-can delete arthur\n</code></pre>"},{"location":"OpenShift%20Castle/41_rbac_with_cli/#default-cluster-roles","title":"Default Cluster Roles","text":"<p>OpenShift comes with a set of default cluster roles that can be assigned to users. These include:</p> <ul> <li>admin</li> <li>basic-user</li> <li>cluster-admin</li> <li>cluster-status</li> <li>edit</li> <li>self-provisioner</li> <li>view</li> </ul>"},{"location":"OpenShift%20Castle/41_rbac_with_cli/#adding-a-specified-role-to-a-user-in-a-project","title":"Adding a Specified Role to a User in a Project","text":"<p>To grant a user a specific role within a project, the King uses the following command:</p> <pre><code>oc policy add-role-to-user &lt;role_name&gt; &lt;username&gt; -n &lt;project&gt;\n</code></pre> <p>For example, to grant \"arthur\" the \"edit\" role in the \"camelot\" project:</p> <pre><code>oc policy add-role-to-user edit arthur -n camelot\n</code></pre>"},{"location":"OpenShift%20Castle/41_rbac_with_cli/#conclusion","title":"Conclusion","text":"<p>Wise ruler of the OpenShift kingdom, you now possess the knowledge to manage roles and responsibilities within your domain. By judiciously assigning and revoking roles, you ensure that your kingdom remains well-governed and secure. Remember, the power of delegation is a mighty tool\u2014use it wisely to maintain order and prosperity in your realm.</p> <p>May your reign be long and your kingdom flourish!</p>"},{"location":"OpenShift%20Castle/42_user_types/","title":"User Types","text":""},{"location":"OpenShift%20Castle/42_user_types/#objective","title":"Objective","text":"<p>Learn the different types of users in Red Hat OpenShift Container Platform (RHOCP) and their unique roles within the system. You'll learn about regular users, system users, and service accounts, understanding their responsibilities and how to manage them effectively. Finally ensure that they have the appropriate permissions and access levels within your OpenShift environment.</p>"},{"location":"OpenShift%20Castle/42_user_types/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of OpenShift user roles and permissions.</li> <li>Familiarity with OpenShift CLI (<code>oc</code> commands) and user management concepts.</li> </ul>"},{"location":"OpenShift%20Castle/42_user_types/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, every citizen, be it a valiant knight, a humble farmer, or a diligent scribe, plays a vital role in maintaining the harmony and prosperity of the realm. Similarly, every interaction within the OpenShift platform is associated with a specific type of user. These users, much like the inhabitants of a bustling medieval castle, have distinct roles and responsibilities.</p> <p>This guide will introduce you to the different types of users in OpenShift and their unique roles within the system.</p>"},{"location":"OpenShift%20Castle/42_user_types/#user-types_1","title":"User Types","text":"<p>OpenShift recognizes three primary types of users:</p> <ol> <li>Regular Users</li> <li>System Users</li> <li>Service Accounts</li> </ol>"},{"location":"OpenShift%20Castle/42_user_types/#1-regular-users","title":"1. Regular Users","text":"<p>Regular users are the knights, nobles, and citizens of the OpenShift kingdom. They are the interactive users who access the platform to perform various tasks and activities. These users are represented by the User object in OpenShift and have specific permissions and access levels based on their roles.</p> <p>In the castle, regular users are like the advisors and artisans who interact directly with the king, providing counsel and crafting essential items for the kingdom's prosperity. They might create new applications, manage resources, or perform administrative tasks.</p> <p>Example command to list regular users: <pre><code>oc get users\n</code></pre></p>"},{"location":"OpenShift%20Castle/42_user_types/#2-system-users","title":"2. System Users","text":"<p>System users are the unsung heroes who work tirelessly behind the scenes to ensure the kingdom runs smoothly. These users are automatically created for infrastructure interactions, such as a cluster administrator or per-node users. Their names start with the \"system:\" prefix, indicating their special status.</p> <p>In the castle, system users are like the castle's keepers and sentinels. They ensure the castle's defenses are strong, the gates are functioning, and all mechanisms are in perfect working order. They handle the critical, automated tasks that keep the platform running seamlessly.</p> <p>Example of a system user name: <pre><code>system:admin\n</code></pre></p>"},{"location":"OpenShift%20Castle/42_user_types/#3-service-accounts","title":"3. Service Accounts","text":"<p>Service accounts are the specialized entities associated with projects. They are used by workloads to invoke Kubernetes APIs and perform automated tasks. Service accounts are created automatically by the system or by project administrators and have names that start with the \"system:serviceaccount:\" prefix.</p> <p>In the castle, service accounts are like the royal messengers and envoys who carry out specific missions on behalf of the kingdom. They perform tasks such as deploying applications, managing secrets, and ensuring that workloads have the necessary permissions to operate effectively.</p> <p>Example of a service account name: <pre><code>system:serviceaccount:my-project:default\n</code></pre></p>"},{"location":"OpenShift%20Castle/42_user_types/#managing-user-types","title":"Managing User Types","text":"<p>Understanding the different types of users is crucial for effective management and security in OpenShift. Just as a wise king must know the roles of his subjects, an OpenShift administrator must know how to manage these user types.</p>"},{"location":"OpenShift%20Castle/42_user_types/#creating-and-managing-regular-users","title":"Creating and Managing Regular Users","text":"<p>Regular users can be created and managed using identity providers. For example, using the HTPasswd identity provider, you can create and manage user credentials.</p>"},{"location":"OpenShift%20Castle/42_user_types/#managing-system-users","title":"Managing System Users","text":"<p>System users are automatically created and managed by OpenShift. They perform essential infrastructure tasks and typically do not require manual intervention.</p>"},{"location":"OpenShift%20Castle/42_user_types/#creating-and-managing-service-accounts","title":"Creating and Managing Service Accounts","text":"<p>Service accounts are created automatically when a new project is created. However, administrators can also create custom service accounts for specific tasks.</p> <p>Example command to create a service account: <pre><code>oc create serviceaccount my-service-account\n</code></pre></p>"},{"location":"OpenShift%20Castle/42_user_types/#assigning-roles-to-users","title":"Assigning Roles to Users","text":"<p>To ensure that each user type has the appropriate permissions, roles can be assigned using the <code>oc adm policy</code> command.</p> <p>Example command to assign a role to a user: <pre><code>oc adm policy add-role-to-user edit my-user -n my-project\n</code></pre></p>"},{"location":"OpenShift%20Castle/42_user_types/#conclusion","title":"Conclusion","text":"<p>In the kingdom of OpenShift, every user type plays a crucial role in maintaining the harmony and efficiency of the system. Whether they are regular users, system users, or service accounts, understanding their roles and managing their permissions is key to ensuring a secure and well-functioning platform.</p> <p>As the ruler of this digital realm, your knowledge of these user types will help you govern wisely, ensuring that each citizen of your kingdom performs their duties effectively and securely. May your reign be prosperous and your kingdom thrive!</p>"},{"location":"OpenShift%20Castle/43_group_management/","title":"Group Management","text":""},{"location":"OpenShift%20Castle/43_group_management/#objective","title":"Objective","text":"<p>Learn how to create groups, add users to these groups, and assign permissions efficiently.You will be equipped to organize and manage groups effectively, ensuring streamlined user management and enhanced collaboration within your OpenShift environment.</p>"},{"location":"OpenShift%20Castle/43_group_management/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Understanding of Kubernetes RBAC (Role-Based Access Control) and group management.</li> <li>Basic knowledge of YAML syntax for creating and editing configuration files.</li> </ul>"},{"location":"OpenShift%20Castle/43_group_management/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, just as in any well-organized castle, managing groups of people efficiently is key to maintaining order and productivity. Groups in OpenShift represent sets of users, allowing for streamlined management and permission assignment. The cluster administrator, akin to the castle's steward, has the authority to create new groups, add users to them, and assign necessary permissions.</p> <p>This guide will walk you through the essentials of group management in OpenShift, ensuring your digital realm runs as smoothly as a well-ordered medieval court.</p>"},{"location":"OpenShift%20Castle/43_group_management/#group-management_1","title":"Group Management","text":"<p>Groups in OpenShift serve as a means to collectively manage users, assign roles, and streamline permissions. Let's explore how to create and manage these groups, much like organizing the various guilds and factions within the castle walls.</p>"},{"location":"OpenShift%20Castle/43_group_management/#creating-a-new-group","title":"Creating a New Group","text":"<p>Creating a new group in OpenShift is akin to establishing a new guild in the castle. This guild, or group, can then be populated with members (users) who share common responsibilities or roles.</p> <p>To create a new group, use the following command: <pre><code>oc adm groups new lead-developers\n</code></pre></p> <p>In the castle, this is like forming the guild of lead developers, a group of master craftsmen and engineers responsible for the most critical and innovative projects in the realm.</p>"},{"location":"OpenShift%20Castle/43_group_management/#adding-users-to-a-group","title":"Adding Users to a Group","text":"<p>Once a group (or guild) is created, the next step is to add members to it. This is similar to enrolling skilled artisans into the guild, ensuring that all members can collaborate and share resources efficiently.</p> <p>To add a user to a group, use the following command: <pre><code>oc adm groups add-users lead-developers user1\n</code></pre></p> <p>Here, user1 is now a proud member of the lead-developers guild, ready to contribute their expertise to the kingdom\u2019s most important projects.</p>"},{"location":"OpenShift%20Castle/43_group_management/#example-scenario","title":"Example Scenario","text":"<p>Imagine you are the steward of the castle, tasked with overseeing a major project to construct a new tower. You decide to form a group of your best engineers and builders to manage this project efficiently.</p> <p>First, you create a group for the lead developers: <pre><code>oc adm groups new lead-developers\n</code></pre></p> <p>Next, you add your top engineers to this group: <pre><code>oc adm groups add-users lead-developers user1\noc adm groups add-users lead-developers user2\noc adm groups add-users lead-developers user3\n</code></pre></p> <p>With these commands, user1, user2, and user3 are now part of the lead-developers group, ready to collaborate on the tower construction.</p>"},{"location":"OpenShift%20Castle/43_group_management/#assigning-permissions-to-groups","title":"Assigning Permissions to Groups","text":"<p>To ensure that the group has the necessary permissions to carry out their tasks, you can assign roles to the entire group. This is similar to granting the guild of lead developers access to the royal armory, tools, and resources needed for their work.</p> <p>For example, to grant the edit role to the lead-developers group: <pre><code>oc policy add-role-to-group edit lead-developers -n my-project\n</code></pre></p> <p>With this command, the lead-developers group is now empowered with the edit role within the specified project, allowing them to make necessary changes and updates.</p>"},{"location":"OpenShift%20Castle/43_group_management/#conclusion","title":"Conclusion","text":"<p>Managing groups in OpenShift is crucial for maintaining order and efficiency within your digital kingdom. By creating and managing groups, adding users, and assigning permissions, you can ensure that your teams work collaboratively and effectively.</p> <p>As the steward of this modern castle, your ability to organize and manage groups will lead to a more productive and harmonious realm, where every user and group can contribute to the kingdom\u2019s success. May your administration be wise and your projects flourish!</p>"},{"location":"OpenShift%20Castle/44_external_access/","title":"Accessing from External Networks","text":""},{"location":"OpenShift%20Castle/44_external_access/#objective","title":"Objective","text":"<p>Expose and secure applications for access from external networks. You will learn about different methods such as NodePort, load balancer services, and OpenShift routes, as well as how to secure these routes to ensure safe and efficient external access to your applications.</p>"},{"location":"OpenShift%20Castle/44_external_access/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Familiarity with Kubernetes service types (NodePort, LoadBalancer) and OpenShift routes.</li> <li>Basic knowledge of network security concepts and TLS encryption.</li> </ul>"},{"location":"OpenShift%20Castle/44_external_access/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, connecting with the outside world is vital for trade, communication, and expansion. Just as a castle has gates and watchtowers to manage and secure traffic, OpenShift provides various methods to expose applications to external networks, ensuring secure and efficient access.</p>"},{"location":"OpenShift%20Castle/44_external_access/#exposing-applications","title":"Exposing Applications","text":"<p>You can expose your applications using different methods, including service types like NodePort or load balancer, and API resources such as Ingress and Route. OpenShift routes are particularly useful for providing a unique, publicly accessible hostname for your applications.</p>"},{"location":"OpenShift%20Castle/44_external_access/#nodeport-and-load-balancer-services","title":"NodePort and Load Balancer Services","text":"<p>These services act like the castle gates, allowing controlled access to the internal workings of your applications. However, for more sophisticated routing and secure access, OpenShift routes are the preferred method.</p>"},{"location":"OpenShift%20Castle/44_external_access/#openshift-routes","title":"OpenShift Routes","text":"<p>OpenShift routes are like the drawbridges of your castle, providing a way for external traffic to reach your applications with a unique hostname. These routes rely on a router plug-in to redirect traffic from the public IP to the appropriate pods.</p>"},{"location":"OpenShift%20Castle/44_external_access/#creating-a-route","title":"Creating a Route","text":"<p>To create a route, you might use a command like this: <pre><code>oc create route edge --service=api-frontend --hostname=api.apps.acme.com\n</code></pre></p> <p>This command sets up a basic route, exposing your application to the world. But in the kingdom of OpenShift, security is paramount.</p>"},{"location":"OpenShift%20Castle/44_external_access/#securing-routes","title":"Securing Routes","text":"<p>Secured routes encrypt traffic to and from the pods, specifying the TLS termination of the route. The available terminations are Edge, Passthrough, and Re-encryption.</p>"},{"location":"OpenShift%20Castle/44_external_access/#edge-routes","title":"Edge Routes","text":"<p>Edge routes encrypt traffic between the client and the router. It\u2019s like having guards inspect and secure all goods entering the castle gates, but once inside, the goods are not monitored.</p> <p>First, you need a TLS certificate. Then you can create the edge route with the certificate: <pre><code>oc create route edge --service=api-frontend --hostname=api.apps.acme.com --key=api.key --cert=api.crt\n</code></pre></p>"},{"location":"OpenShift%20Castle/44_external_access/#passthrough-routes","title":"Passthrough Routes","text":"<p>Passthrough routes are akin to a secret passage that ensures end-to-end encryption. The application exposes its TLS certificate, so traffic is encrypted from the client to the application directly.</p> <p>To set this up, you provide the certificate via OpenShift TLS secrets, exposing the secrets as a mount point into the container.</p>"},{"location":"OpenShift%20Castle/44_external_access/#re-encrypt-routes","title":"Re-encrypt Routes","text":"<p>Re-encrypt routes offer end-to-end encryption with an additional layer of security. It\u2019s like having a secure tunnel that encrypts the traffic both at the entrance and within the castle walls.</p> <p>Re-encrypt routes terminate external client-router encryption with a trusted certificate using a fully qualified domain name (FQDN), then re-encrypt connections to internal services using certificates with OpenShift FQDNs, generated by the OpenShift PKI and stored in service-specific secrets.</p>"},{"location":"OpenShift%20Castle/44_external_access/#conclusion","title":"Conclusion","text":"<p>In the digital kingdom of OpenShift, managing external access to your applications is as crucial as guarding the gates of a castle. By understanding and utilizing routes and securing them appropriately, you ensure that your applications are both accessible and protected, maintaining the integrity and security of your realm.</p> <p>May your applications flourish, and your connections to the outside world be both strong and secure!</p>"},{"location":"OpenShift%20Castle/45_network_policies/","title":"Network Policies","text":""},{"location":"OpenShift%20Castle/45_network_policies/#objective","title":"Objective","text":"<p>Learn to control traffic flow between pods using labels, define specific network policies for secure communication, and implement deny-all policies to enhance security.</p>"},{"location":"OpenShift%20Castle/45_network_policies/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Understanding of Kubernetes network policies and how they control pod traffic.</li> <li>Basic knowledge of YAML syntax for creating and editing configuration files.</li> </ul>"},{"location":"OpenShift%20Castle/45_network_policies/#introduction","title":"Introduction","text":"<p>In the grand kingdom of OpenShift, maintaining secure and efficient communication between the various inhabitants (pods) is crucial. Network policies act as the kingdom\u2019s intricate system of gates and pathways, controlling traffic flow and ensuring that only the right messages reach their intended destinations. Just as a wise ruler would design a castle with secure passages, OpenShift administrators use network policies to create logical zones within the Software-Defined Network (SDN) that map to their organization\u2019s network zones.</p>"},{"location":"OpenShift%20Castle/45_network_policies/#understanding-network-policies","title":"Understanding Network Policies","text":"<p>Kubernetes network policies control network traffic between pods using labels instead of IP addresses. This means you can separate traffic based on logical groupings, regardless of where the pods are running. To manage communication between pods in different namespaces, you assign labels to the namespaces that need to interact and create network policies to define the allowed traffic.</p>"},{"location":"OpenShift%20Castle/45_network_policies/#creating-network-policies","title":"Creating Network Policies","text":"<p>Imagine you have two sections in your castle, <code>network-1</code> and <code>network-2</code>. You want to allow communication between these sections while ensuring only specific traffic is permitted. To achieve this, you assign a label to each namespace and create corresponding network policies.</p> <p>First, label the namespaces: <pre><code>oc label namespace network-1 network=network-1\n</code></pre></p> <p>Next, define the network policies. Here are examples of network policies that allow communication between pods in the <code>network-1</code> and <code>network-2</code> namespaces:</p>"},{"location":"OpenShift%20Castle/45_network_policies/#network-policy-for-network-1","title":"Network Policy for <code>network-1</code>","text":"<pre><code>kind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\n  name: network-1-policy\n  namespace: network-1\nspec:\n  podSelector:\n    matchLabels:\n      deployment: my-app\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          network: network-2\n      podSelector:\n        matchLabels:\n          role: art\n    ports:\n    - port: 8080\n      protocol: TCP\n</code></pre>"},{"location":"OpenShift%20Castle/45_network_policies/#network-policy-for-network-2","title":"Network Policy for <code>network-2</code>","text":"<pre><code>kind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\n  name: network-2-policy\n  namespace: network-2\nspec:\n  podSelector: {}\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          network: network-1\n</code></pre> <p>These policies ensure that only pods in <code>network-1</code> with the label <code>deployment: my-app</code> can receive traffic from pods in <code>network-2</code> with the label <code>role: art</code>, and vice versa.</p>"},{"location":"OpenShift%20Castle/45_network_policies/#boolean-logic-in-network-policies","title":"Boolean Logic in Network Policies","text":"<p>Just as a castle might have different levels of access and security, you can use boolean logic to create more specific network policy rules. This ensures users and applications access only what they should, even between different projects.</p>"},{"location":"OpenShift%20Castle/45_network_policies/#deny-all-network-policies","title":"Deny-all Network Policies","text":"<p>In OpenShift, if a pod matches one or more network policies, it only accepts connections allowed by those policies. However, you might want to block all traffic by default and only allow specific communications. This is akin to closing all gates of the castle by default and only opening specific ones when needed.</p> <p>An empty pod selector applies the policy to all pods in a project. Here\u2019s an example of a policy that blocks all traffic because no ingress rules are defined:</p> <pre><code>kind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\n  name: default-deny\nspec:\n  podSelector: {}\n</code></pre> <p>If a pod does not match any network policies, OpenShift does not restrict traffic to that pod. This default behavior ensures that your applications remain accessible unless explicitly restricted.</p>"},{"location":"OpenShift%20Castle/45_network_policies/#conclusion","title":"Conclusion","text":"<p>Managing network policies in OpenShift is like designing the secure pathways and gates within a castle. By carefully labeling namespaces and creating specific network policies, you ensure secure and efficient communication between pods. Remember to consider the castle\u2019s overall security, not blocking essential services like router pods and monitoring services.</p> <p>With these strategies, your kingdom of OpenShift will be both secure and well-organized, allowing for seamless and protected communication between all its inhabitants. May your network policies be robust, and your castle gates well-guarded!</p>"},{"location":"OpenShift%20Castle/46_certificates_management/","title":"Certificates Management","text":""},{"location":"OpenShift%20Castle/46_certificates_management/#objective","title":"Objective","text":"<p>Learn to manage certificates in OpenShift to ensure secure communication. This includes generating service certificates, configuring client applications to trust these certificates, and handling key rotation. Additionally, explore alternatives such as service mesh and the cert-manager operator for advanced encryption solutions.</p>"},{"location":"OpenShift%20Castle/46_certificates_management/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Understanding of TLS/SSL certificates and their role in securing communication.</li> <li>Familiarity with OpenShift service CA and certificate management concepts.</li> </ul>"},{"location":"OpenShift%20Castle/46_certificates_management/#introduction","title":"Introduction","text":"<p>In the ancient kingdom of OpenShift, where the digital fortress stands tall, the mantra of zero-trust is the law of the land. Here, every communication is encrypted, every certificate is meticulously vetted, and trust is a privilege earned through rigorous validation. The king's court, comprising administrators and guardians, ensures that all network traffic is secure, safeguarding the kingdom from unseen threats.</p>"},{"location":"OpenShift%20Castle/46_certificates_management/#service-certificates-and-creation","title":"Service Certificates and Creation","text":"<p>In this fortified realm, the royal scribes, known as the service-ca controllers, generate and sign service certificates for internal traffic. These certificates, much like royal seals, authenticate and protect the messages exchanged within the kingdom.</p>"},{"location":"OpenShift%20Castle/46_certificates_management/#generating-a-certificate-and-key-pair","title":"Generating a Certificate and Key Pair","text":"<p>To obtain a royal seal, you must send a formal request to the scribes. This is done by annotating the service with <code>service.beta.openshift.io/serving-cert-secret-name=your-secret</code>. It's akin to placing a request in the royal register for a sealed document.</p> <pre><code>oc annotate service my-app service.beta.openshift.io/serving-cert-secret-name=my-app-secret\n</code></pre> <p>Once the scribes generate the secret, it must be securely delivered and mounted in the application deployment, just like delivering the sealed decree to its rightful place in the castle.</p> <pre><code>spec:\n  template:\n    spec:\n      containers:\n        - name: my-app\n          volumeMounts:\n            - name: my-app-volume\n              mountPath: /etc/pki/nginx/\n      volumes:\n        - name: my-app-volume\n          secret:\n            defaultMode: 420\n            secretName: my-app-secret\n            items:\n              - key: tls.crt\n                path: server.crt\n              - key: tls.key\n                path: private/server.key\n</code></pre>"},{"location":"OpenShift%20Castle/46_certificates_management/#client-service-application-configuration","title":"Client Service Application Configuration","text":"<p>For a client service application to trust a certificate, it needs the CA bundle that signed the certificate. The service-ca controller, acting as the royal notary, injects the CA bundle when you apply the <code>service.beta.openshift.io/inject-cabundle=true</code> annotation. This ensures that the client can verify the authenticity of the certificate, much like checking the royal seal on a document.</p> <pre><code>oc annotate configmap ca-bundle service.beta.openshift.io/inject-cabundle=true\n</code></pre>"},{"location":"OpenShift%20Castle/46_certificates_management/#key-rotation","title":"Key Rotation","text":"<p>In the kingdom of OpenShift, the validity of certificates is carefully managed. The service CA certificate is valid for 26 months and is automatically rotated after 13 months. There is a 13-month grace period where the original CA certificate remains valid, allowing for a seamless transition. This is much like updating royal decrees periodically to maintain their legitimacy and authority.</p> <p>Should the need arise, you can manually rotate the certificates by deleting existing secrets, akin to a royal edict declaring the replacement of old seals with new ones:</p> <pre><code>oc delete secret certificate-secret\noc delete secret/signing-key -n openshift-service-ca\n</code></pre>"},{"location":"OpenShift%20Castle/46_certificates_management/#alternatives-to-service-certificates","title":"Alternatives to Service Certificates","text":"<p>The kingdom of OpenShift also offers alternative methods to ensure TLS encryption within its borders, akin to various layers of protection around the castle.</p>"},{"location":"OpenShift%20Castle/46_certificates_management/#service-mesh","title":"Service Mesh","text":"<p>A service mesh creates a network of secured passageways within the castle, ensuring that every interaction between services is encrypted and protected. This is like having an intricate system of guarded tunnels connecting different parts of the fortress.</p>"},{"location":"OpenShift%20Castle/46_certificates_management/#cert-manager-operator","title":"Cert-Manager Operator","text":"<p>The cert-manager operator acts like a trusted envoy, delegating the task of certificate signing to a reliable external service. This allows the kingdom to maintain the integrity of its communications through trusted external partners.</p>"},{"location":"OpenShift%20Castle/46_certificates_management/#red-hat-openshift-service-mesh","title":"Red Hat OpenShift Service Mesh","text":"<p>Red Hat OpenShift Service Mesh provides advanced functionalities for encrypted communication between services. It is akin to having an elite team of royal guards dedicated to ensuring that every message and interaction within the kingdom is secure and trustworthy.</p>"},{"location":"OpenShift%20Castle/46_certificates_management/#conclusion","title":"Conclusion","text":"<p>In the realm of OpenShift, zero-trust environments are the cornerstone of security. By using trusted certificates, automating key rotations, and exploring advanced options like service mesh and cert-manager, the kingdom remains vigilant and well-protected from external threats. As guardians of this digital fortress, administrators must continuously ensure the integrity and security of all communications within the castle walls.</p>"},{"location":"OpenShift%20Castle/47_non_http_services/","title":"Exposing Non-HTTP Services","text":""},{"location":"OpenShift%20Castle/47_non_http_services/#objective","title":"Objective","text":"<p>Expose non-HTTP services in Kubernetes and OpenShift, including the use of Load Balancer services and MetalLB for environments that do not have cloud provider support.</p>"},{"location":"OpenShift%20Castle/47_non_http_services/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Understanding of Kubernetes service types and their roles in exposing applications.</li> <li>Basic knowledge of network debugging tools (e.g., <code>ping</code>, <code>traceroute</code>) for testing connectivity.</li> </ul>"},{"location":"OpenShift%20Castle/47_non_http_services/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, not all services communicate through the familiar HTTP gateways. Some require their own unique paths, reminiscent of secret tunnels used by messengers in ancient castles. These paths ensure that even non-HTTP protocols can reach their destinations safely and efficiently, much like how the castle's messengers used to navigate through hidden passages.</p>"},{"location":"OpenShift%20Castle/47_non_http_services/#kubernetes-services","title":"Kubernetes Services","text":"<p>To provide transparent access to workload services that run on multiple pods, Kubernetes uses resources of the Service type. These services are akin to the royal messengers, ensuring that messages (network requests) reach their intended recipients (pods) efficiently.</p> <p>A Kubernetes Service contains the following information: - A selector that describes the pods running the service. - A list of the ports that provide the service on the pods.</p>"},{"location":"OpenShift%20Castle/47_non_http_services/#load-balancer-services","title":"Load Balancer Services","text":"<p>In the castle, large-scale announcements were made using the grand balconies, allowing messages to reach everyone. Similarly, load balancer services in Kubernetes act as grand broadcasters for network traffic, ensuring that services are accessible from outside the cluster.</p> <p>Load balancer services require the use of network features that are not available in all environments. Typically, cloud providers offer their own load balancer services, but what if your castle (cluster) is on bare metal or in a private datacenter?</p>"},{"location":"OpenShift%20Castle/47_non_http_services/#metallb","title":"MetalLB","text":"<p>For those castles that do not have cloud support, there is MetalLB, a loyal knight ready to provide load balancing services. MetalLB can be installed with the Operator Lifecycle Manager and operates in two modes: Layer 2 and Border Gateway Protocol (BGP). These modes have different properties and requirements, akin to how different types of knights have varying skills and armor.</p>"},{"location":"OpenShift%20Castle/47_non_http_services/#using-load-balancer-services","title":"Using Load Balancer Services","text":"<p>Once you have configured a Load Balancer component, you can create services of the LoadBalancer type to expose non-HTTP services outside the cluster. This is like assigning a special herald (LoadBalancer service) to ensure your messages get through even the most secure castle walls.</p> <p>Here is an example of creating a LoadBalancer service:</p> example_lb.service.yaml<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: example-lb\n  namespace: example\nspec:\n  ports:\n  - port: 1234\n    protocol: TCP\n    targetPort: 1234\n  selector:\n    name: example\n  type: LoadBalancer\n</code></pre> <p>After creating the service, you can check the public IP with commands like:</p> <pre><code>kubectl get service\noc get example-lb -o jsonpath=\"{.status.loadBalancer.ingress}\"\n</code></pre> <p>Then use network debugging tools, such as the ping and traceroute commands, to examine connectivity. These tools act like scouts, ensuring that the paths are clear and the messages can travel without interruption.</p>"},{"location":"OpenShift%20Castle/47_non_http_services/#conclusion","title":"Conclusion","text":"<p>In the realm of OpenShift, exposing non-HTTP services requires a bit more effort, much like navigating secret tunnels in a castle. Whether you use cloud provider load balancers or the MetalLB operator for bare metal clusters, these tools ensure that all your services, HTTP or not, can communicate securely and efficiently. Just as every castle had its unique passages, every OpenShift cluster has its methods for exposing and managing services.</p>"},{"location":"OpenShift%20Castle/48_using_different_networks/","title":"Using Different Networks","text":""},{"location":"OpenShift%20Castle/48_using_different_networks/#objective","title":"Objective","text":"<p>Learn to manage and configure secondary networks in Kubernetes and OpenShift using the Multus CNI plug-in to attach pods to custom networks, both internal and external.</p>"},{"location":"OpenShift%20Castle/48_using_different_networks/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Kubernetes and OpenShift networking concepts.</li> <li>Familiarity with the Multus CNI plug-in and its configuration.</li> <li>Knowledge of YAML syntax for creating and editing configuration files.</li> <li>Basic command-line skills for using the OpenShift CLI (<code>oc</code> commands).</li> </ul>"},{"location":"OpenShift%20Castle/48_using_different_networks/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, just as different guilds and factions need their own unique paths and communication channels within the vast castle, sometimes certain pods require their own distinct networks. The Multus CNI plug-in acts like a master architect, creating these specialized pathways to ensure secure and efficient communication for every pod.</p>"},{"location":"OpenShift%20Castle/48_using_different_networks/#configuring-secondary-networks","title":"Configuring Secondary Networks","text":"<p>Before you can attach pods to these specialized networks, you must first make these networks available on the cluster nodes. This is akin to laying the groundwork for new secret tunnels within the castle.</p>"},{"location":"OpenShift%20Castle/48_using_different_networks/#network-operators","title":"Network Operators","text":"<p>Operators such as Kubernetes NMState or the SR-IOV (Single Root I/O Virtualization) are used to customize node network configurations, ensuring that the infrastructure is in place for these secondary networks.</p>"},{"location":"OpenShift%20Castle/48_using_different_networks/#attaching-secondary-networks","title":"Attaching Secondary Networks","text":"<p>Once the groundwork is laid, you can begin attaching pods to these new networks, much like assigning specific guilds to their designated secret passageways.</p>"},{"location":"OpenShift%20Castle/48_using_different_networks/#networkattachmentdefinition-resource","title":"NetworkAttachmentDefinition Resource","text":"<p>To configure secondary networks, create a NetworkAttachmentDefinition resource or update the cluster network operator configuration to add a secondary network.</p>"},{"location":"OpenShift%20Castle/48_using_different_networks/#pod-annotations","title":"Pod Annotations","text":"<p>Network attachment resources are namespaced, meaning they are available only to pods within their namespace. When additional networks are available, you can add the <code>k8s.v1.cni.cncf.io/networks</code> annotation to the pod's template to specify which network to use.</p> <p>Here is an example of how to annotate a pod to use an additional network:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: example\n  namespace: example\nspec:\n  selector:\n    matchLabels:\n      app: example\n      name: example\n  template:\n    metadata:\n      annotations:\n        k8s.v1.cni.cncf.io/networks: example\n      labels:\n        app: example\n        name: example\n  spec:\n    containers:\n    - name: example-container\n      image: example-image\n</code></pre> <p>In this example, the <code>k8s.v1.cni.cncf.io/networks</code> annotation is used to attach the pod to the <code>example</code> network, much like how a royal decree assigns a guild to a specific tunnel within the castle.</p>"},{"location":"OpenShift%20Castle/48_using_different_networks/#checking-network-status","title":"Checking Network Status","text":"<p>Multus updates the <code>k8s.v1.cni.cncf.io/networks-status</code> annotation with the status of the additional networks. You can check the status with the following command:</p> <pre><code>oc get pod example -o jsonpath='{.metadata.annotations.k8s\\.v1\\.cni\\.cncf\\.io/networks-status}'\n</code></pre> <p>This is akin to the castle's chief architect reviewing the progress and status of newly constructed secret tunnels, ensuring everything is in order.</p>"},{"location":"OpenShift%20Castle/48_using_different_networks/#conclusion","title":"Conclusion","text":"<p>In the realm of OpenShift, managing and configuring secondary networks allows for specialized and secure communication channels, much like the secret tunnels of a grand castle. By using tools like the Multus CNI plug-in, Kubernetes NMState, and SR-IOV, administrators can ensure that every pod has access to the networks it needs, maintaining the efficiency and security of the entire digital kingdom.</p>"},{"location":"OpenShift%20Castle/49_network_attachment/","title":"Network Attachment Custom Resource","text":""},{"location":"OpenShift%20Castle/49_network_attachment/#objective","title":"Objective","text":"<p>Understand how to create and use NetworkAttachmentDefinition resources in Kubernetes and OpenShift for different types of network interfaces such as host device, bridge, IPVLAN, and MACVLAN.</p>"},{"location":"OpenShift%20Castle/49_network_attachment/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Kubernetes CNI (Container Network Interface) plug-ins.</li> <li>Familiarity with different network attachment types such as host device, bridge, IPVLAN, and MACVLAN.</li> <li>Knowledge of YAML syntax for creating and editing configuration files.</li> <li>Basic command-line skills for using the OpenShift CLI (<code>oc</code> commands).</li> </ul>"},{"location":"OpenShift%20Castle/49_network_attachment/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, different guilds and factions often require specialized communication channels. The NetworkAttachmentDefinition resource acts as the master plan, detailing the construction and connection of these unique pathways. Each type of network interface serves a distinct purpose, ensuring that every guild can communicate effectively within the vast castle.</p>"},{"location":"OpenShift%20Castle/49_network_attachment/#types-of-network-attachment-definitions","title":"Types of Network Attachment Definitions","text":""},{"location":"OpenShift%20Castle/49_network_attachment/#host-device","title":"Host Device","text":"<p>The host device type attaches a network interface directly to a single pod. This is akin to giving a messenger a direct, private passageway to ensure their messages are delivered without interference.</p>"},{"location":"OpenShift%20Castle/49_network_attachment/#bridge","title":"Bridge","text":"<p>The bridge type utilizes an existing bridge interface on the node or sets up a new bridge interface. Pods attached to this network can communicate with each other through the bridge and with any other networks attached to the bridge. This is like constructing a new courtyard where guilds can gather and interact freely.</p>"},{"location":"OpenShift%20Castle/49_network_attachment/#ipvlan","title":"IPVLAN","text":"<p>The IPVLAN type establishes a network attached to a network interface using IPVLAN. This configuration allows for efficient network communication by segmenting traffic based on IP addresses, much like having separate hallways for different guilds within the castle.</p>"},{"location":"OpenShift%20Castle/49_network_attachment/#macvlan","title":"MACVLAN","text":"<p>The MACVLAN type establishes a network attached to a network interface using MAC addresses. This is similar to having dedicated pathways for specific guild members, ensuring secure and efficient communication.</p>"},{"location":"OpenShift%20Castle/49_network_attachment/#example-networkattachmentdefinition-for-a-host-device","title":"Example: NetworkAttachmentDefinition for a Host Device","text":"<p>Here is an example of a NetworkAttachmentDefinition resource for a host device:</p> <pre><code>apiVersion: k8s.cni.cncf.io/v1\nkind: NetworkAttachmentDefinition\nmetadata:\n  name: example\nspec:\n  config: |-\n  {\n    \"cniVersion\": \"0.3.1\",\n    \"name\": \"example\",\n    \"type\": \"host-device\",\n    \"device\": \"ens4\",\n    \"ipam\": {\n      \"type\": \"dhcp\"\n    }\n  }\n</code></pre>"},{"location":"OpenShift%20Castle/49_network_attachment/#explanation","title":"Explanation","text":"<ul> <li>apiVersion: Specifies the API version for the resource.</li> <li>kind: Defines the type of resource, in this case, NetworkAttachmentDefinition.</li> <li>metadata: Contains metadata for the resource, such as the name.</li> <li>spec: Defines the configuration for the network attachment.<ul> <li>cniVersion: Specifies the CNI (Container Network Interface) version.</li> <li>name: Names the network.</li> <li>type: Defines the type of network, here it is <code>host-device</code>.</li> <li>device: Specifies the network device to attach, e.g., <code>ens4</code>.</li> <li>ipam: Configures the IP address management, here it uses DHCP.</li> </ul> </li> </ul> <p>This setup is like providing a dedicated and secure passageway for a specific guild member, ensuring they have direct access to their destination.</p>"},{"location":"OpenShift%20Castle/49_network_attachment/#conclusion","title":"Conclusion","text":"<p>In the realm of OpenShift, creating and configuring NetworkAttachmentDefinition resources allows for the establishment of specialized and efficient communication channels. Whether using host devices, bridges, IPVLAN, or MACVLAN, these custom resources ensure that every pod has the network access it needs. By mastering these configurations, administrators can maintain the efficiency and security of the entire digital kingdom, ensuring smooth and effective communication throughout the castle.</p>"},{"location":"OpenShift%20Castle/50_network_operator_settings/","title":"Network Operator Settings","text":""},{"location":"OpenShift%20Castle/50_network_operator_settings/#objective","title":"Objective","text":"<p>Learn how to create network attachments by editing the cluster network operator configuration in OpenShift, including configuring IP Address Management (IPAM) settings for custom networks.</p>"},{"location":"OpenShift%20Castle/50_network_operator_settings/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Understanding of Kubernetes networking and CNI plug-ins.</li> <li>Familiarity with OpenShift's network operator and its configuration.</li> <li>Knowledge of YAML syntax for creating and editing configuration files.</li> <li>Basic command-line skills for using the OpenShift CLI (<code>oc</code> commands).</li> </ul>"},{"location":"OpenShift%20Castle/50_network_operator_settings/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, the network operator acts like the castle's chief engineer, overseeing and managing the intricate web of pathways that connect different guilds and factions. By configuring the network operator, administrators can establish new custom networks, ensuring that every pod has the network access it needs, much like creating new secret tunnels within the castle walls.</p>"},{"location":"OpenShift%20Castle/50_network_operator_settings/#creating-network-attachments-through-network-operator-configuration","title":"Creating Network Attachments through Network Operator Configuration","text":"<p>To create a network attachment, you can edit the cluster network operator configuration. This method allows you to define additional networks in a centralized manner, ensuring that all nodes and pods have access to these custom pathways.</p>"},{"location":"OpenShift%20Castle/50_network_operator_settings/#example-configuration","title":"Example Configuration","text":"<p>Here is an example of how to create a network attachment by editing the cluster network operator configuration:</p> <pre><code>apiVersion: operator.openshift.io/v1\nkind: Network\nmetadata:\n  name: cluster\nspec:\n  ...\n  additionalNetworks:\n  - name: example\n    namespace: example\n    rawCNIConfig: |-\n      {\n        \"cniVersion\": \"0.3.1\",\n        \"name\": \"example\",\n        \"type\": \"host-device\",\n        \"device\": \"ens4\",\n        \"ipam\": {\n          \"type\": \"dhcp\"\n        }\n      }\n    type: Raw\n</code></pre>"},{"location":"OpenShift%20Castle/50_network_operator_settings/#explanation","title":"Explanation","text":"<ul> <li>apiVersion: Specifies the API version for the resource.</li> <li>kind: Defines the type of resource, in this case, Network.</li> <li>metadata: Contains metadata for the resource, such as the name (<code>cluster</code>).</li> <li>spec: Defines the specifications for the network configuration.<ul> <li>additionalNetworks: Lists the additional networks to be configured.<ul> <li>name: Names the additional network.</li> <li>namespace: Specifies the namespace where the network will be available.</li> <li>rawCNIConfig: Provides the raw CNI configuration in JSON format.</li> <li>type: Specifies the type of network configuration, here it is <code>Raw</code>.</li> </ul> </li> </ul> </li> </ul> <p>This configuration is like the chief engineer's blueprint for a new tunnel, detailing every aspect from the tunnel's entrance to its path through the castle.</p>"},{"location":"OpenShift%20Castle/50_network_operator_settings/#configuring-ip-address-management-ipam","title":"Configuring IP Address Management (IPAM)","text":"<p>The IPAM CNI plug-in provides IP addresses for other CNI plug-ins. In the previous example, the ipam key contains a network configuration that uses DHCP. However, you can provide more complex network configurations in the ipam key.</p>"},{"location":"OpenShift%20Castle/50_network_operator_settings/#using-static-ip-addresses","title":"Using Static IP Addresses","text":"<p>For example, here is how you can configure a static IP address:</p> <pre><code>\"ipam\": {\n  \"type\": \"static\",\n  \"addresses\": [\n    {\"address\": \"192.168.X.X/24\"}\n  ]\n}\n</code></pre> <p>This configuration assigns a static IP address to the network interface, much like assigning a permanent residence to a specific guild member within the castle.</p>"},{"location":"OpenShift%20Castle/50_network_operator_settings/#flexibility-in-network-configuration","title":"Flexibility in Network Configuration","text":"<p>You can define more than one additional network for your cluster, giving you flexibility when configuring pods that deliver network functions. This is akin to constructing multiple secret tunnels within the castle, each serving a unique purpose and ensuring efficient communication across the kingdom.</p>"},{"location":"OpenShift%20Castle/50_network_operator_settings/#conclusion","title":"Conclusion","text":"<p>In the realm of OpenShift, configuring network attachments through the network operator allows administrators to create and manage custom networks efficiently. By utilizing IPAM settings, whether through DHCP or static IP addresses, you can ensure that every pod has the network access it needs. This centralized approach to network configuration is essential for maintaining the efficiency and security of the entire digital kingdom.</p>"},{"location":"OpenShift%20Castle/51_limiting_workloads/","title":"Limiting Workloads","text":""},{"location":"OpenShift%20Castle/51_limiting_workloads/#objective","title":"Objective","text":"<p>Learn how to manage and limit workloads in Kubernetes and OpenShift by using resource limits, requests, and quotas to ensure cluster efficiency and prevent resource contention.</p>"},{"location":"OpenShift%20Castle/51_limiting_workloads/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Kubernetes and OpenShift resource management concepts.</li> <li>Familiarity with ResourceQuotas, limits, and requests.</li> <li>Knowledge of YAML syntax for creating and editing configuration files.</li> <li>Basic command-line skills for using the OpenShift CLI (<code>oc</code> commands).</li> </ul>"},{"location":"OpenShift%20Castle/51_limiting_workloads/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, managing resources efficiently is crucial for maintaining harmony and preventing conflicts among the various guilds (workloads). Administrators, akin to wise stewards, use tools such as Role-Based Access Control (RBAC) to grant permissions for workload creation. However, to ensure the kingdom's resources are used wisely and fairly, additional measures such as resource limits, requests, and quotas are implemented. These measures act as the kingdom's laws, ensuring that no single guild consumes excessive resources or impacts others negatively.</p>"},{"location":"OpenShift%20Castle/51_limiting_workloads/#resource-quotas","title":"Resource Quotas","text":"<p>Resource quotas are established within namespaces to ensure that workloads do not exceed predefined resource usage limits. This is similar to allocating specific amounts of resources to different guilds within the castle, ensuring that each guild has enough to operate but not so much that they deplete the kingdom's resources.</p>"},{"location":"OpenShift%20Castle/51_limiting_workloads/#example-resource-quota","title":"Example Resource Quota","text":"<p>Here is an example of creating a resource quota in a namespace:</p> <pre><code>apiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: memory\n  namespace: example\nspec:\n  hard:\n    limits.memory: 4Gi\n    requests.memory: 2Gi\n  scopes: {}\n  scopeSelector: {}\n</code></pre>"},{"location":"OpenShift%20Castle/51_limiting_workloads/#explanation","title":"Explanation","text":"<ul> <li>apiVersion: Specifies the API version for the resource.</li> <li>kind: Defines the type of resource, in this case, ResourceQuota.</li> <li>metadata: Contains metadata for the resource, such as the name (<code>memory</code>) and the namespace (<code>example</code>).</li> <li>spec: Defines the specifications for the resource quota.</li> <li>hard: Lists the hard limits for resource usage.<ul> <li>limits.memory: Maximum amount of memory that workloads in the namespace can use.</li> <li>requests.memory: Maximum amount of memory that workloads in the namespace can request.</li> </ul> </li> <li>scopes and scopeSelector: Define which namespace resources the quota applies to.</li> </ul> <p>The hard key lists the restrictions, much like decrees from the king limiting how much of a certain resource each guild can consume.</p>"},{"location":"OpenShift%20Castle/51_limiting_workloads/#compute-quotas","title":"Compute Quotas","text":"<p>Compute quotas that you can include in the hard key are: - limits.cpu - limits.memory - requests.cpu - requests.memory</p> <p>Limit quotas control the maximum compute resources that workloads in a namespace can consume, while request quotas control the maximum resources that workloads in a namespace can reserve. Excessive quotas can cause resource underutilization and unnecessarily limit workload performance. Therefore, it's crucial to balance these quotas carefully.</p>"},{"location":"OpenShift%20Castle/51_limiting_workloads/#object-count-quotas","title":"Object Count Quotas","text":"<p>In addition to compute quotas, a quota can also limit the number of resources of a given type in a namespace. Setting object count quotas can limit the damage from accidents and maintain adequate cluster performance. This is akin to limiting the number of guild members to prevent overcrowding in the castle.</p>"},{"location":"OpenShift%20Castle/51_limiting_workloads/#example-object-count-quota","title":"Example Object Count Quota","text":"<p>To set a quota for resources of the core group, use the <code>count/resource_type</code> syntax. Use the <code>oc api-resources</code> command with an empty api-group parameter to list resources of the core group:</p> <pre><code>oc api-resources --api-group=\"\" --namespaced=true\n</code></pre> <p>This command helps you determine the resource types available for setting quotas, ensuring that you have a comprehensive understanding of the resources within your cluster.</p>"},{"location":"OpenShift%20Castle/51_limiting_workloads/#conclusion","title":"Conclusion","text":"<p>In the realm of OpenShift, managing and limiting workloads through resource quotas, limits, and requests ensures that the kingdom's resources are used efficiently and fairly. By setting these boundaries, administrators can prevent resource contention and ensure smoother cluster operation, much like a wise steward managing the resources of a vast and bustling castle.</p>"},{"location":"OpenShift%20Castle/52_project_quotas_intro/","title":"Apply and Troubleshoot Project Quotas","text":""},{"location":"OpenShift%20Castle/52_project_quotas_intro/#objective","title":"Objective","text":"<p>Learn to apply and manage project quotas in OpenShift using both the web console and command-line interface to ensure efficient resource utilization and adherence to organizational policies.</p>"},{"location":"OpenShift%20Castle/52_project_quotas_intro/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Kubernetes and OpenShift resource management and quota concepts.</li> <li>Familiarity with both the OpenShift web console and command-line interface.</li> <li>Knowledge of YAML syntax for creating and editing configuration files.</li> <li>Basic command-line skills for using the OpenShift CLI (<code>oc</code> commands).</li> </ul>"},{"location":"OpenShift%20Castle/52_project_quotas_intro/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, administrators must ensure that resources are allocated fairly among the various guilds (projects) to maintain harmony and efficiency. Project quotas serve as the laws that dictate how much of each resource a guild can consume, preventing any single guild from monopolizing the kingdom's resources.</p>"},{"location":"OpenShift%20Castle/52_project_quotas_intro/#applying-project-quotas","title":"Applying Project Quotas","text":"<p>Administrators can apply project quotas using the OpenShift web console or the command-line interface, ensuring flexibility and ease of management.</p>"},{"location":"OpenShift%20Castle/52_project_quotas_intro/#using-the-web-console","title":"Using the Web Console","text":"<p>Navigate to Administration &gt; ResourceQuotas to create a resource quota from the web console. This method provides a user-friendly interface for managing quotas, much like how a royal scribe would use a detailed ledger to record resource allocations. The web console acts as a grand chamber where the kingdom's overseers (administrators) can decree the resource limits for each guild.</p>"},{"location":"OpenShift%20Castle/52_project_quotas_intro/#using-the-command-line-interface","title":"Using the Command-Line Interface","text":"<p>Alternatively, you can use the <code>oc create resourcequota</code> command to create a resource quota. For example:</p> <pre><code>oc create resourcequota example --hard=count/pods=1\n</code></pre> <p>This command is like issuing a royal decree that sets the boundaries for resource usage within a guild, ensuring no guild can hoard resources at the expense of others.</p>"},{"location":"OpenShift%20Castle/52_project_quotas_intro/#example-explanation","title":"Example Explanation","text":"<ul> <li>oc create resourcequota example: Creates a resource quota named <code>example</code>.</li> <li>--hard=count/pods=1: Sets a hard limit of 1 pod for this quota, ensuring that only one pod can be created within the project. This is akin to granting a guild permission to use a single workshop within the castle walls.</li> </ul>"},{"location":"OpenShift%20Castle/52_project_quotas_intro/#retrieving-quota-information","title":"Retrieving Quota Information","text":"<p>After creating a resource quota, you can retrieve information about its status with commands like:</p> <pre><code>oc get quota example -o yaml\noc get quota\n</code></pre> <p>These commands allow you to view detailed information about the resource quotas, much like how the royal scribe reviews the resource ledger to ensure compliance with the kingdom's laws. The status of these quotas reflects the real-time usage and availability of resources within the kingdom.</p>"},{"location":"OpenShift%20Castle/52_project_quotas_intro/#troubleshooting-resource-quotas","title":"Troubleshooting Resource Quotas","text":"<p>Resource quotas in Kubernetes are extensible, meaning that Kubernetes cannot always verify if a resource quota is correct. This can lead to scenarios where a quota command is issued but not effectively enforced, without providing negative feedback.</p>"},{"location":"OpenShift%20Castle/52_project_quotas_intro/#ensuring-correct-quotas","title":"Ensuring Correct Quotas","text":"<p>To ensure a quota is correctly applied, you can create a quota with an artificially low value in a testing environment. This approach allows you to generate an error as soon as the quota is exceeded, confirming that the quota is being enforced as expected. It's like testing a new law in a small part of the kingdom before rolling it out across all the guilds.</p> <p>For example, set a low quota value and attempt to exceed it:</p> <pre><code>oc create resourcequota test-quota --hard=cpu=1m\n</code></pre> <p>Then, create a resource that requests more than 1 millicore of CPU:</p> <pre><code>oc run test-pod --image=busybox --requests=cpu=10m -- /bin/sh -c \"sleep 1000\"\n</code></pre> <p>If the quota is correctly enforced, you should receive an error indicating that the resource creation failed due to exceeding the quota. This trial and error process ensures that the kingdom's laws are fair and effective.</p> <p>In the kingdom of OpenShift, this is akin to the royal guards (administrators) setting up a trial scenario in the castle courtyard to test if the newly issued laws are effective. By observing the reactions (errors) when the laws are broken, they can ensure that the rules are robust and enforceable, maintaining order and fairness in the realm.</p>"},{"location":"OpenShift%20Castle/52_project_quotas_intro/#conclusion","title":"Conclusion","text":"<p>Applying and managing project quotas in OpenShift ensures that resources are allocated fairly and efficiently among projects. By using the web console or command-line interface, administrators can easily create and monitor resource quotas, maintaining harmony within the digital kingdom. Troubleshooting techniques, such as setting low quotas in a test environment, help verify that quotas are correctly enforced, ensuring smooth and effective resource management. Just as a well-governed kingdom thrives on fair laws and resource management, an efficiently managed OpenShift cluster ensures optimal performance and resource utilization.</p>"},{"location":"OpenShift%20Castle/53_creating_quotas/","title":"Creating Quotas Across Multiple Projects","text":""},{"location":"OpenShift%20Castle/53_creating_quotas/#objective","title":"Objective","text":"<p>Learn to create and manage cluster resource quotas in OpenShift to ensure fair resource allocation across multiple projects, using both the web console and command-line interface.</p>"},{"location":"OpenShift%20Castle/53_creating_quotas/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Kubernetes and OpenShift resource management concepts.</li> <li>Familiarity with ClusterResourceQuota and its configuration.</li> <li>Knowledge of YAML syntax for creating and editing configuration files.</li> <li>Basic command-line skills for using the OpenShift CLI (<code>oc</code> commands).</li> </ul>"},{"location":"OpenShift%20Castle/53_creating_quotas/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, managing resources fairly across multiple projects (guilds) is crucial for maintaining harmony and efficiency. Cluster resource quotas are the kingdom's overarching laws, ensuring that no single guild consumes more than its fair share of resources, thus preserving balance and order throughout the realm.</p>"},{"location":"OpenShift%20Castle/53_creating_quotas/#creating-cluster-resource-quotas","title":"Creating Cluster Resource Quotas","text":"<p>Cluster resource quotas in OpenShift follow a structure similar to namespace resource quotas but include selectors to specify which namespaces the quota applies to. These quotas act like royal decrees that apply across multiple guilds, ensuring equitable resource distribution throughout the kingdom.</p>"},{"location":"OpenShift%20Castle/53_creating_quotas/#example-of-clusterresourcequota","title":"Example of ClusterResourceQuota","text":"<p>Here is an example of a <code>ClusterResourceQuota</code> resource:</p> <pre><code>apiVersion: quota.openshift.io/v1\nkind: ClusterResourceQuota\nmetadata:\n  name: example\nspec:\n  quota:\n    hard:\n      limits.cpu: 4\n  selector:\n    annotations: {}\n    labels:\n      matchLabels:\n        kubernetes.io/metadata.name: example\n</code></pre>"},{"location":"OpenShift%20Castle/53_creating_quotas/#explanation","title":"Explanation","text":"<ul> <li>apiVersion: Specifies the API version.</li> <li>kind: Defines the resource type, which is <code>ClusterResourceQuota</code>.</li> <li>metadata: Contains metadata about the resource, such as its name.</li> <li>spec: Contains the specifications for the quota.</li> <li>quota: Defines the resource limits.<ul> <li>hard: Lists the resource limits, such as CPU.</li> </ul> </li> <li>selector: Specifies which namespaces the quota applies to, using annotations and labels to match namespaces.</li> </ul>"},{"location":"OpenShift%20Castle/53_creating_quotas/#using-the-web-console","title":"Using the Web Console","text":"<p>To create a cluster resource quota using the web console, navigate to Administration &gt; CustomResourceDefinitions. This method provides a user-friendly interface, much like the grand chamber where the kingdom's overseers (administrators) draft and implement royal decrees.</p>"},{"location":"OpenShift%20Castle/53_creating_quotas/#using-the-command-line-interface","title":"Using the Command-Line Interface","text":"<p>Alternatively, you can use the <code>oc create clusterresourcequota</code> command to create a cluster resource quota. For example:</p> <pre><code>oc create clusterresourcequota example --project-label-selector=group=dev --hard=requests.cpu=10\n</code></pre> <p>This command is akin to issuing a royal decree that applies across multiple guilds, ensuring fair resource allocation throughout the kingdom.</p>"},{"location":"OpenShift%20Castle/53_creating_quotas/#example-explanation","title":"Example Explanation","text":"<ul> <li>oc create clusterresourcequota example: Creates a cluster resource quota named <code>example</code>.</li> <li>--project-label-selector=group=dev: Applies the quota to projects with the label <code>group=dev</code>.</li> <li>--hard=requests.cpu=10: Sets a hard limit of 10 CPU requests for the selected projects.</li> </ul>"},{"location":"OpenShift%20Castle/53_creating_quotas/#reviewing-quota-usage","title":"Reviewing Quota Usage","text":"<p>OpenShift creates resources of the <code>AppliedClusterResourceQuota</code> type in namespaces affected by cluster resource quotas. Project administrators can review quota usage by examining these resources, much like how royal inspectors review compliance with the kingdom's laws.</p> <p>For example, use the following command to describe an <code>AppliedClusterResourceQuota</code>:</p> <pre><code>oc describe AppliedClusterResourceQuota -n example-2\n</code></pre> <p>This command provides detailed information about the quota usage in the specified namespace, ensuring transparency and accountability in resource allocation.</p>"},{"location":"OpenShift%20Castle/53_creating_quotas/#conclusion","title":"Conclusion","text":"<p>Creating and managing cluster resource quotas in OpenShift ensures fair resource distribution across multiple projects, maintaining harmony and efficiency in the digital kingdom. By using both the web console and command-line interface, administrators can easily implement and monitor these quotas. Reviewing <code>AppliedClusterResourceQuota</code> resources helps ensure compliance with the quotas, much like royal inspectors ensuring that guilds adhere to the kingdom's laws. This balanced approach ensures that all projects have the resources they need to thrive, preserving the kingdom's stability and prosperity.</p>"},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/","title":"Limit Ranges in Namespace","text":""},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/#objective","title":"Objective","text":"<p>Understand how to manage and enforce resource usage limits within namespaces using LimitRange objects in Kubernetes and OpenShift.</p>"},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Kubernetes resource management and namespaces.</li> <li>Familiarity with YAML syntax for creating and editing configuration files.</li> </ul>"},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, just as there are rules and regulations to ensure that no guild or faction uses more resources than necessary, LimitRanges are set to enforce resource usage limits within namespaces. These limits ensure that all workloads operate efficiently, without overconsuming resources and disrupting the harmony of the digital kingdom.</p>"},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/#limit-ranges","title":"Limit Ranges","text":"<p>LimitRange objects define resource usage limits for workloads within a namespace. They are like the kingdom's laws that set boundaries on how much resources each guild (namespace) can use, ensuring fair and efficient resource distribution.</p>"},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/#example-configuration","title":"Example Configuration","text":"<p>Here is an example of a <code>LimitRange</code> configuration:</p> <pre><code>apiVersion: v1\nkind: LimitRange\nmetadata:\n  name: mem-limit-range\n  namespace: default\nspec:\n  limits:\n    - default:\n        memory: 512Mi\n      defaultRequest:\n        memory: 256Mi\n      type: Container\n</code></pre>"},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/#explanation","title":"Explanation","text":"<ul> <li>apiVersion: Specifies the API version.</li> <li>kind: Defines the resource type, which is <code>LimitRange</code>.</li> <li>metadata: Contains metadata about the resource, such as its name and namespace.</li> <li>spec: Contains the specifications for the limit range.</li> <li>limits: Defines the resource limits.<ul> <li>default: Specifies the default limits for containers.</li> <li>defaultRequest: Specifies the default resource requests for containers.</li> <li>type: Indicates the type of resource the limit applies to, such as <code>Container</code>.</li> </ul> </li> </ul>"},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/#additional-fields","title":"Additional Fields","text":"<ul> <li>max and min: Specify the maximum and minimum values for both limits and requests.</li> <li>maxLimitRequestRatio: Controls the relationship between limits and requests.</li> </ul> <p>Limit ranges can apply to various resources, including containers, pods, images, image streams, and persistent volume claims. However, they do not affect existing pods, much like new laws that only apply to future actions and not past deeds.</p>"},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/#enforcing-limit-ranges","title":"Enforcing Limit Ranges","text":"<p>Even when a limit is not explicitly declared, the Kubernetes API server includes an admission controller that enforces limit ranges. This controller affects pod definitions but not deployments, stateful sets, or other workloads. It's akin to a royal enforcer ensuring that all new guild members adhere to the kingdom's laws from the moment they join.</p>"},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/#updating-resource-limits","title":"Updating Resource Limits","text":"<p>To update the CPU limit or add other resource specifications, you can use the <code>oc set resources</code> command. For example:</p> <pre><code>oc set resources deployment example --limits=cpu=new-cpu-limit\n</code></pre> <p>This command is like issuing a new decree that adjusts the resource usage for specific guilds within the kingdom.</p>"},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/#handling-out-of-range-requests","title":"Handling Out-of-Range Requests","text":"<p>If you request CPU values outside the range defined by the <code>min</code> and <code>max</code> keys, Kubernetes will not create the pods and will log warnings. This is similar to the kingdom rejecting guild requests that exceed the allowed resource limits and issuing warnings to the guild leaders.</p>"},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/#resource-quota-considerations","title":"Resource Quota Considerations","text":"<p>When doing a deployment rollout, the pods of both replica sets count towards the resource quota. If the quota is exceeded, the rollout will not complete. This ensures that resource allocation remains balanced, much like ensuring that no guild can monopolize the kingdom's resources during an expansion or new project.</p>"},{"location":"OpenShift%20Castle/54_limiting_ranges_in_namespace/#conclusion","title":"Conclusion","text":"<p>Managing namespace resources with LimitRange objects in OpenShift helps ensure fair and efficient resource usage across the digital kingdom. By setting clear boundaries and enforcing them through admission controllers, administrators can maintain harmony and prevent resource contention among workloads. Adjusting resource limits and handling out-of-range requests further ensures that all guilds (namespaces) operate within their allocated resources, preserving the kingdom's stability and prosperity.</p>"},{"location":"OpenShift%20Castle/55_project_creation/","title":"Project Creation","text":""},{"location":"OpenShift%20Castle/55_project_creation/#objective","title":"Objective","text":"<p>Understand how to create and manage projects in OpenShift to improve security and user experience, utilizing project templates to customize namespace creation.</p>"},{"location":"OpenShift%20Castle/55_project_creation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Understanding of Kubernetes namespaces and their role in resource isolation.</li> <li>Familiarity with OpenShift CLI (<code>oc</code> commands) for managing resources.</li> </ul>"},{"location":"OpenShift%20Castle/55_project_creation/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, creating and managing projects (or namespaces) is akin to establishing new territories within the realm. Each territory must be governed by specific rules and regulations to ensure smooth and secure operations. OpenShift introduces projects to enhance security and improve users' experience when working with namespaces. This approach ensures that territories are well-defined and managed efficiently.</p>"},{"location":"OpenShift%20Castle/55_project_creation/#projects-and-project-requests","title":"Projects and Project Requests","text":""},{"location":"OpenShift%20Castle/55_project_creation/#differentiating-resource-listing-and-viewing","title":"Differentiating Resource Listing and Viewing","text":"<p>Listing resources and viewing individual resources are distinct operations. Just as a king might grant different levels of access to his courtiers, administrators can grant users permissions to view specific namespaces. However, listing all namespaces requires a separate permission, ensuring that users only see what they are authorized to see.</p>"},{"location":"OpenShift%20Castle/55_project_creation/#introducing-projects","title":"Introducing Projects","text":"<p>OpenShift introduces the Project resource type to improve security and user experience. When users query to list projects, the OpenShift API server lists namespaces, filters the ones visible to the user, and returns them in project format. This filtering mechanism ensures that users only see the projects they have access to, much like how citizens in the kingdom only have access to their own territories.</p>"},{"location":"OpenShift%20Castle/55_project_creation/#projectrequest-resource-type","title":"ProjectRequest Resource Type","text":"<p>Additionally, OpenShift introduces the ProjectRequest resource type. When users create a project request, the OpenShift API server creates a namespace from a template. This feature allows cluster administrators to customize namespace creation, enabling a self-service management model for namespaces. Users can create namespaces without the ability to modify namespace metadata, ensuring a controlled and secure environment.</p>"},{"location":"OpenShift%20Castle/55_project_creation/#planning-a-project-template","title":"Planning a Project Template","text":"<p>When planning a project template, you can add any namespaced resource to it. These resources help define the rules and limits for the new territories within the kingdom.</p>"},{"location":"OpenShift%20Castle/55_project_creation/#typical-resources-to-include","title":"Typical Resources to Include","text":"<ol> <li>Roles and Role Bindings:</li> <li>Grant specific permissions in new projects.</li> <li>The default template grants the admin role to the user who requests the project.</li> <li> <p>Additional granular permissions can be added over specific resource types, ensuring that users have the appropriate level of access, much like assigning different roles to members of the royal court.</p> </li> <li> <p>Resource Quotas and Limit Ranges:</p> </li> <li>Suggested to add quotas to the project template to ensure that all new projects have resource limits.</li> <li> <p>Adding cluster resource quotas is also beneficial, similar to setting boundaries for the territories to prevent resource overuse and ensure fair distribution.</p> </li> <li> <p>Network Policies:</p> </li> <li>Add network policies to the template to enforce organizational network isolation requirements.</li> <li>These policies ensure secure and isolated communication channels, akin to setting up guarded paths and gates within the kingdom.</li> </ol>"},{"location":"OpenShift%20Castle/55_project_creation/#example-of-a-project-template","title":"Example of a Project Template","text":"<p>Here is an example of a project template configuration:</p> <pre><code>apiVersion: template.openshift.io/v1\nkind: Template\nmetadata:\n  name: project-template\nobjects:\n  - apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: ${PROJECT_NAME}\n  - apiVersion: v1\n    kind: ResourceQuota\n    metadata:\n      name: ${PROJECT_NAME}-quota\n      namespace: ${PROJECT_NAME}\n    spec:\n      hard:\n        requests.cpu: \"1\"\n        requests.memory: 1Gi\n        limits.cpu: \"2\"\n        limits.memory: 2Gi\n  - apiVersion: v1\n    kind: LimitRange\n    metadata:\n      name: ${PROJECT_NAME}-limit-range\n      namespace: ${PROJECT_NAME}\n    spec:\n      limits:\n        - default:\n            memory: 512Mi\n          defaultRequest:\n            memory: 256Mi\n          type: Container\n  - apiVersion: networking.k8s.io/v1\n    kind: NetworkPolicy\n    metadata:\n      name: allow-all\n      namespace: ${PROJECT_NAME}\n    spec:\n      podSelector: {}\n      policyTypes:\n      - Ingress\n      - Egress\nparameters:\n  - name: PROJECT_NAME\n    description: The name of the project\n    required: true\n</code></pre> <p>In this example, the project template includes configurations for a namespace, resource quotas, limit ranges, and network policies. These elements are essential for maintaining order and ensuring that each new territory adheres to the kingdom's regulations.</p>"},{"location":"OpenShift%20Castle/55_project_creation/#conclusion","title":"Conclusion","text":"<p>Creating and managing projects in OpenShift is a crucial task that ensures secure and efficient operations within the cluster. By utilizing project templates, administrators can enforce consistent rules and limits across all new namespaces. This approach not only improves security but also enhances user experience, providing a well-organized and controlled environment akin to a well-governed kingdom.</p>"},{"location":"OpenShift%20Castle/56_project_template_creation_and_config/","title":"Creating and Configuring a Project Template","text":""},{"location":"OpenShift%20Castle/56_project_template_creation_and_config/#objective","title":"Objective","text":"<p>Learn to create and configure project templates in OpenShift to customize namespace creation, ensuring that new projects adhere to organizational standards and resource limits.</p>"},{"location":"OpenShift%20Castle/56_project_template_creation_and_config/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Kubernetes namespaces and resource management.</li> <li>Familiarity with OpenShift CLI (<code>oc</code> commands) and YAML syntax for configuration files.</li> </ul>"},{"location":"OpenShift%20Castle/56_project_template_creation_and_config/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, creating project templates is akin to crafting blueprints for new territories. These templates ensure that every new project is established with the necessary resources, roles, and policies, much like how a wise ruler ensures that new settlements are well-planned and governed.</p>"},{"location":"OpenShift%20Castle/56_project_template_creation_and_config/#creating-a-project-template","title":"Creating a Project Template","text":"<p>Project templates in OpenShift use the same template feature as the <code>oc new-app</code> command. This flexibility allows administrators to create comprehensive templates that can be reused whenever a new project is requested.</p>"},{"location":"OpenShift%20Castle/56_project_template_creation_and_config/#generating-an-initial-template","title":"Generating an Initial Template","text":"<p>To create an initial project template, use the following command:</p> <pre><code>oc adm create-bootstrap-project-template -o yaml &gt; file\n</code></pre> <p>This command generates a basic template and outputs it to a file. This file can then be modified to include the required resources for new namespaces.</p>"},{"location":"OpenShift%20Castle/56_project_template_creation_and_config/#modifying-the-template","title":"Modifying the Template","text":"<p>It's often beneficial to create the namespace and manually adjust the resources in YAML format until the desired behavior is achieved. Once you have finalized the configuration, replace the namespace name with the project name placeholder.</p> <p>Here is an example of how you can modify the template:</p> <pre><code>apiVersion: template.openshift.io/v1\nkind: Template\nmetadata:\n  name: project-template\nobjects:\n  - apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: ${PROJECT_NAME}\n  - apiVersion: v1\n    kind: ResourceQuota\n    metadata:\n      name: ${PROJECT_NAME}-quota\n      namespace: ${PROJECT_NAME}\n    spec:\n      hard:\n        requests.cpu: \"1\"\n        requests.memory: 1Gi\n        limits.cpu: \"2\"\n        limits.memory: 2Gi\n  - apiVersion: v1\n    kind: LimitRange\n    metadata:\n      name: ${PROJECT_NAME}-limit-range\n      namespace: ${PROJECT_NAME}\n    spec:\n      limits:\n        - default:\n            memory: 512Mi\n          defaultRequest:\n            memory: 256Mi\n          type: Container\n  - apiVersion: networking.k8s.io/v1\n    kind: NetworkPolicy\n    metadata:\n      name: allow-all\n      namespace: ${PROJECT_NAME}\n    spec:\n      podSelector: {}\n      policyTypes:\n      - Ingress\n      - Egress\nparameters:\n  - name: PROJECT_NAME\n    description: The name of the project\n    required: true\n</code></pre>"},{"location":"OpenShift%20Castle/56_project_template_creation_and_config/#creating-the-template-resource","title":"Creating the Template Resource","text":"<p>Once the template is ready, create the template resource in the <code>openshift-config</code> namespace with the following command:</p> <pre><code>oc create -f template -n openshift-config\n</code></pre> <p>This command registers the new template, making it available for use when creating projects.</p>"},{"location":"OpenShift%20Castle/56_project_template_creation_and_config/#configuring-the-project-template","title":"Configuring the Project Template","text":"<p>To configure OpenShift to use the new project template, update the <code>projects.config.openshift.io/cluster</code> resource. Modify the <code>spec</code> section to reference the new template.</p> <p>Here is an example of the configuration:</p> <pre><code>apiVersion: config.openshift.io/v1\nkind: Project\nmetadata:\n  name: cluster\nspec:\n  projectRequestTemplate:\n    name: project-request\n</code></pre>"},{"location":"OpenShift%20Castle/56_project_template_creation_and_config/#reverting-to-the-original-template","title":"Reverting to the Original Template","text":"<p>If you need to revert to the original project template, clear the <code>spec</code> resource to match the <code>spec: {}</code> format:</p> <pre><code>apiVersion: config.openshift.io/v1\nkind: Project\nmetadata:\n  name: cluster\nspec: {}\n</code></pre>"},{"location":"OpenShift%20Castle/56_project_template_creation_and_config/#conclusion","title":"Conclusion","text":"<p>Creating and configuring project templates in OpenShift is a powerful way to standardize and control the creation of new namespaces. By carefully crafting these templates, administrators can ensure that new projects are established with the necessary resources, roles, and policies. This approach promotes consistency and security, much like a well-governed kingdom ensures that new settlements are well-planned and managed.</p>"},{"location":"OpenShift%20Castle/57_managing_self-provisionig_permissions/","title":"Managing Self-Provisioning Permissions","text":""},{"location":"OpenShift%20Castle/57_managing_self-provisionig_permissions/#objective","title":"Objective","text":"<p>Learn to manage self-provisioning permissions in OpenShift to control which users can create new projects, ensuring better governance and resource management.</p>"},{"location":"OpenShift%20Castle/57_managing_self-provisionig_permissions/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of OpenShift roles and role bindings.</li> <li>Familiarity with Kubernetes Role-Based Access Control (RBAC) concepts.</li> </ul>"},{"location":"OpenShift%20Castle/57_managing_self-provisionig_permissions/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, the ability for users to create new projects is akin to granting citizens the power to establish new settlements. While this can foster growth and innovation, it also requires oversight to ensure that these new territories are well-planned and do not strain the kingdom's resources. By managing self-provisioning permissions, administrators can control who has the power to create new projects, maintaining order and efficiency within the cluster.</p>"},{"location":"OpenShift%20Castle/57_managing_self-provisionig_permissions/#managing-self-provisioning-permissions_1","title":"Managing Self-Provisioning Permissions","text":"<p>By default, the <code>selfprovisioner</code> role in OpenShift is bound to all authenticated users, allowing them to create projects. However, to maintain better control and governance, it may be necessary to limit which users can request new projects.</p>"},{"location":"OpenShift%20Castle/57_managing_self-provisionig_permissions/#viewing-role-bindings","title":"Viewing Role Bindings","text":"<p>To see the role bindings for the <code>selfprovisioner</code> role, use the following command:</p> <pre><code>oc describe clusterrolebinding.rbac self-provisioners\n</code></pre> <p>This command provides details about the role binding, including the subjects (users or groups) that are bound to the role.</p>"},{"location":"OpenShift%20Castle/57_managing_self-provisionig_permissions/#understanding-the-auto-update-annotation","title":"Understanding the Auto-Update Annotation","text":"<p>The <code>selfprovisioner</code> role binding includes an <code>rbac.authorization.kubernetes.io/autoupdate</code> annotation. This annotation protects roles and bindings from modifications that could interfere with the cluster's operation. When the API server starts, the cluster restores resources with this annotation automatically, unless it is set to <code>false</code>.</p>"},{"location":"OpenShift%20Castle/57_managing_self-provisionig_permissions/#modifying-the-role-binding","title":"Modifying the Role Binding","text":"<p>To effectively edit the subjects in the <code>selfprovisioner</code> role binding, follow these steps:</p> <ol> <li>Disable Auto-Update</li> </ol> <p>First, disable the auto-update feature for the <code>selfprovisioner</code> role binding:</p> <pre><code>oc annotate clusterrolebinding/self-provisioners --overwrite rbac.authorization.kubernetes.io/autoupdate=false\n</code></pre> <p>This command ensures that your modifications will not be overwritten by the cluster's automatic restoration process.</p> <ol> <li>Patch the Role Binding</li> </ol> <p>Next, remove the current subjects from the role binding:</p> <pre><code>oc patch clusterrolebinding.rbac self-provisioners -p '{\"subjects\": null}'\n</code></pre> <p>This command sets the subjects to <code>null</code>, effectively removing all users and groups from the <code>selfprovisioner</code> role.</p>"},{"location":"OpenShift%20Castle/57_managing_self-provisionig_permissions/#example-scenario","title":"Example Scenario","text":"<p>Imagine the kingdom decides that only members of the royal council should be able to establish new settlements. By following the steps above, the administrator can remove the self-provisioning permissions from all users and then create a new role binding specifically for the council members.</p> <pre><code>oc create clusterrolebinding council-self-provisioners --clusterrole=self-provisioner --group=royal-council\n</code></pre> <p>In this scenario, only users in the <code>royal-council</code> group would have the permissions to create new projects, ensuring that new settlements are planned and managed according to the kingdom's guidelines.</p>"},{"location":"OpenShift%20Castle/57_managing_self-provisionig_permissions/#conclusion","title":"Conclusion","text":"<p>Managing self-provisioning permissions in OpenShift allows administrators to control which users can create new projects. By carefully managing role bindings and leveraging the auto-update annotation, administrators can ensure that only authorized users can establish new projects, maintaining order and efficiency within the cluster. This governance ensures that the kingdom of OpenShift remains well-organized and its resources are used effectively.</p>"},{"location":"OpenShift%20Castle/58_operator_pattern/","title":"The Operator Pattern","text":""},{"location":"OpenShift%20Castle/58_operator_pattern/#objective","title":"Objective","text":"<p>Understand the Operator pattern in Kubernetes and OpenShift, and learn how to deploy and manage operators to handle complex workloads effectively.</p>"},{"location":"OpenShift%20Castle/58_operator_pattern/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Kubernetes operators and their purpose.</li> <li>Familiarity with OpenShift CLI (<code>oc</code> commands) and operator management concepts.</li> </ul>"},{"location":"OpenShift%20Castle/58_operator_pattern/#introduction","title":"Introduction","text":"<p>In the grand kingdom of OpenShift, managing complex workloads requires more than just basic resources\u2014it demands the expertise of specialized agents known as Operators. These Operators, much like skilled artisans in the castle, understand the intricate details of their specific tasks, ensuring that everything runs smoothly and efficiently within the digital realm.</p>"},{"location":"OpenShift%20Castle/58_operator_pattern/#the-operator-pattern_1","title":"The Operator Pattern","text":"<p>The Operator pattern is a design used to create reusable software that manages complex workloads. Operators define Custom Resources (CRs), which contain the necessary information to deploy and manage these workloads. Think of Operators as master architects in the castle who not only design the structures but also ensure their ongoing maintenance and upgrades, keeping the kingdom in perfect working order.</p>"},{"location":"OpenShift%20Castle/58_operator_pattern/#deploying-operators","title":"Deploying Operators","text":"<p>Various pieces of software implement the Operator pattern in different ways, providing flexible and powerful tools to manage your workloads, akin to having different guilds of craftsmen working together to maintain and enhance the castle.</p>"},{"location":"OpenShift%20Castle/58_operator_pattern/#cluster-operators","title":"Cluster Operators","text":"<p>Cluster operators provide essential platform services in OpenShift, such as the web console and the OAuth server. The Cluster Version Operator (CVO) acts as the kingdom's chief engineer, handling the installation and updating of cluster operators during the OpenShift installation and update processes.</p> <p>To check the status of cluster operators, you can use the following command, much like a royal decree to gather status reports from various parts of the kingdom:</p> <pre><code>oc get clusteroperator\n</code></pre> <p>Alternatively, from the web console, navigate to Administration &gt; Cluster Settings, and then click the ClusterOperators tab. This view provides a comprehensive overview of the current state of all cluster operators, similar to a council meeting where all updates are reviewed.</p>"},{"location":"OpenShift%20Castle/58_operator_pattern/#add-on-operators","title":"Add-on Operators","text":"<p>OpenShift includes the Operator Lifecycle Manager (OLM) to assist users in installing and updating operators within a cluster. These operators, managed by the OLM, are referred to as add-on operators, distinguishing them from cluster operators that provide core platform services. Think of these add-on operators as specialized guilds that bring new capabilities to the castle.</p> <p>The OLM uses operator catalogs\u2014container images that contain information about available operators, including descriptions and versions. For each available operator, the OLM creates a resource of the PackageManifest type. The web console also displays available operators and provides a wizard to simplify the installation process. Alternatively, operators can be installed using the Subscription Custom Resource (CR) and other related CRs.</p> <p>Operators installed via the OLM have a distinct lifecycle, allowing administrators to manage installations, updates, and removals independently from cluster updates. This independence is like having guilds that can operate autonomously, ensuring that the kingdom continues to function smoothly even as new improvements are made.</p>"},{"location":"OpenShift%20Castle/58_operator_pattern/#other-operators","title":"Other Operators","text":"<p>Software providers can create software that follows the Operator pattern and distribute it as manifests, Helm charts, or other mechanisms. This flexibility allows for a wide range of applications and tools to be integrated into the OpenShift ecosystem, each managed by its specialized operator. Imagine this as various craftsmen and experts from distant lands bringing their unique skills to enhance the castle's operations.</p>"},{"location":"OpenShift%20Castle/58_operator_pattern/#conclusion","title":"Conclusion","text":"<p>The Operator pattern in OpenShift is a powerful method for managing complex workloads by leveraging the expertise of specialized agents known as Operators. Whether deploying core platform services with cluster operators or adding new capabilities with add-on operators, the Operator Lifecycle Manager (OLM) provides a robust framework for managing these essential components. By understanding and utilizing the Operator pattern, administrators can ensure their clusters are as well-maintained and efficient as the most meticulously run kingdom, with each guild and artisan contributing to the prosperity and stability of the digital realm.</p>"},{"location":"OpenShift%20Castle/59_using_operators/","title":"Using Operators","text":""},{"location":"OpenShift%20Castle/59_using_operators/#objective","title":"Objective","text":"<p>Learn how to use and troubleshoot operators in Kubernetes by examining custom resource definitions and understanding operator workloads.</p>"},{"location":"OpenShift%20Castle/59_using_operators/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic knowledge of Kubernetes, including custom resource definitions (CRDs).</li> <li>Familiarity with YAML syntax for configuration files.</li> </ul>"},{"location":"OpenShift%20Castle/59_using_operators/#introduction","title":"Introduction","text":"<p>In the bustling kingdom of OpenShift, operators are the master craftsmen who bring complex tasks to life. They handle intricate workloads and ensure everything runs smoothly within the kingdom. To effectively use these operators, administrators need to understand how to create and manage custom resources, as well as how to troubleshoot any issues that arise.</p>"},{"location":"OpenShift%20Castle/59_using_operators/#using-operators_1","title":"Using Operators","text":"<p>To make the most of an operator, it's essential to review its documentation. This documentation often guides administrators on how to use the operator by creating instances of its custom resources, much like following a detailed manual to build a complex structure.</p>"},{"location":"OpenShift%20Castle/59_using_operators/#learning-about-custom-resource-definitions","title":"Learning About Custom Resource Definitions","text":"<p>To learn about the available custom resource definitions (CRDs) provided by an operator, you can examine the operator's details. This is akin to reviewing the blueprints and specifications of the tasks the craftsmen can perform.</p> <p>For example, you can examine the custom resource definitions owned by the <code>metallb-operator</code> using the following command:</p> <pre><code>oc get csv metallb-operator.4.14.0-202405201438 -o jsonpath=\"{.spec.customresourcedefinitions.owned[*].name}\"\n</code></pre> <p>This command retrieves the names of the custom resource definitions owned by the specified operator. Additionally, you can use <code>oc explain</code> to view detailed descriptions of individual custom resource definitions, much like consulting a detailed guidebook for each tool and resource available in the kingdom.</p>"},{"location":"OpenShift%20Castle/59_using_operators/#troubleshooting-operators","title":"Troubleshooting Operators","text":"<p>Operators typically manage two kinds of workloads within the kingdom:</p> <ol> <li>Operator Workload: This workload monitors custom resources and ensures they are properly managed and maintained. It's like the master craftsman overseeing various projects.</li> <li>Instance Workloads: These are the workloads created by individual instances of the custom resources. They represent the actual tasks being carried out based on the operator's instructions.</li> </ol> <p>To troubleshoot these workloads, it's important to understand the deployments created by the Operator Lifecycle Manager (OLM) during the installation of an operator. These deployments often correspond to the operator workload, detailing how the master craftsman sets up their operations.</p>"},{"location":"OpenShift%20Castle/59_using_operators/#examining-operator-workloads","title":"Examining Operator Workloads","text":"<p>The <code>spec.install.spec.deployments</code> field in the ClusterServiceVersion (CSV) contains the deployments that the OLM creates when installing an operator. This is where you can find the details of the operator workload, much like examining the organizational chart of the craftsmen and their assigned tasks.</p> <p>To view this information, you can use a command like:</p> <pre><code>oc get csv metallb-operator.4.14.0-202405201438 -o jsonpath=\"{.spec.install.spec.deployments[*].name}\"\n</code></pre> <p>This command retrieves the names of the deployments specified in the CSV, providing insights into the operator's setup.</p>"},{"location":"OpenShift%20Castle/59_using_operators/#conclusion","title":"Conclusion","text":"<p>In the kingdom of OpenShift, understanding how to use and troubleshoot operators is crucial for maintaining a well-managed and efficient environment. By reviewing operator documentation, examining custom resource definitions, and understanding the workloads managed by operators, administrators can ensure that their digital realm operates smoothly. This knowledge equips administrators with the tools needed to manage complex tasks and resolve issues, ensuring that the kingdom of OpenShift remains prosperous and secure.</p>"},{"location":"OpenShift%20Castle/60_scc/","title":"Security Context Constraints (SCCs)","text":""},{"location":"OpenShift%20Castle/60_scc/#objective","title":"Objective","text":"<p>Understand how to use Security Context Constraints (SCCs) in OpenShift to limit access from running pods to the host environment and ensure secure operations within the cluster.</p>"},{"location":"OpenShift%20Castle/60_scc/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Kubernetes security concepts, such as SCCs and Role-Based Access Control (RBAC).</li> <li>Knowledge of YAML syntax for editing and creating configuration files.</li> </ul>"},{"location":"OpenShift%20Castle/60_scc/#introduction","title":"Introduction","text":"<p>In the fortified kingdom of OpenShift, security is paramount. To protect the realm from potential threats, the castle employs Security Context Constraints (SCCs) as gatekeepers. These SCCs control how pods interact with the host environment, ensuring that only trusted entities have access to sensitive resources.</p>"},{"location":"OpenShift%20Castle/60_scc/#understanding-security-context-constraints-sccs","title":"Understanding Security Context Constraints (SCCs)","text":"<p>SCCs are security mechanisms in OpenShift that restrict the capabilities of pods, much like royal decrees that limit what different guilds and factions can do within the castle walls. They control access to host resources, ensuring that each pod operates within its assigned boundaries.</p>"},{"location":"OpenShift%20Castle/60_scc/#key-controls-of-sccs","title":"Key Controls of SCCs","text":"<p>SCCs regulate the following aspects of pod behavior:</p> <ul> <li>Running Privileged Containers: Controlling which pods can operate with elevated privileges.</li> <li>Requesting Extra Capabilities for a Container: Defining what additional capabilities a pod can request.</li> <li>Using Host Directories as Volumes: Restricting the use of host directories within pods.</li> <li>Changing the SELinux Context of a Container: Managing how pods can alter their SELinux security context.</li> <li>Changing the User ID: Controlling the user ID under which a pod operates.</li> </ul> <p>Cluster administrators can list the SCCs defined by OpenShift with the following command:</p> <pre><code>oc get scc\n</code></pre> <p>For detailed information about a specific SCC, use:</p> <pre><code>oc describe scc anyuid\n</code></pre>"},{"location":"OpenShift%20Castle/60_scc/#viewing-the-scc-used-by-a-pod","title":"Viewing the SCC Used by a Pod","text":"<p>To determine which SCC a pod is using, you can inspect the pod's details. For example, to check the SCC for a specific pod:</p> <pre><code>oc describe pod console-5df4fcbb47-67c52 -n openshift-console | grep scc\n</code></pre>"},{"location":"OpenShift%20Castle/60_scc/#managing-sccs","title":"Managing SCCs","text":"<p>Most pods created by OpenShift use the restricted-v2 SCC, which provides limited access to resources outside of OpenShift. However, some workloads may require more permissive SCCs. To list all SCCs that can overcome limitations hindering a container:</p> <pre><code>oc get deployment &lt;deployment-name&gt; -o yaml | oc adm policy scc-subject-review -f -\n</code></pre>"},{"location":"OpenShift%20Castle/60_scc/#using-the-anyuid-scc","title":"Using the anyuid SCC","text":"<p>The anyuid SCC allows a pod to run as any available user ID in the container, which is useful for containers that need to operate as a specific user. This flexibility is akin to granting a trusted craftsman permission to use any workshop within the castle.</p> <p>To allow a container to run with a different SCC, follow these steps:</p> <ol> <li> <p>Create a Service Account: First, create a service account that will be used by the pod. Use the <code>-n</code> option to specify the namespace if needed.</p> <pre><code>oc create serviceaccount service-account-name -n namespace\n</code></pre> </li> <li> <p>Associate the Service Account with an SCC: Add the service account to the desired SCC using the <code>-z</code> option.</p> <pre><code>oc adm policy add-scc-to-user SCC -z &lt;service-account&gt;\n</code></pre> </li> <li> <p>Update the Deployment: Modify the existing deployment or deployment configuration to use the new service account.</p> <pre><code>oc set serviceaccount deployment/&lt;deployment-name&gt; &lt;service-account-name&gt;\n</code></pre> </li> </ol>"},{"location":"OpenShift%20Castle/60_scc/#conclusion","title":"Conclusion","text":"<p>In the kingdom of OpenShift, SCCs are vital for maintaining the security and integrity of the environment. By understanding and managing SCCs effectively, administrators can ensure that pods operate safely within their designated boundaries, much like ensuring that all guilds and craftsmen within the castle adhere to the king's security protocols. This approach helps maintain a secure and well-functioning realm, protecting both the infrastructure and its inhabitants from potential threats.</p>"},{"location":"OpenShift%20Castle/61_privileged_containers/","title":"Privileged Containers and Application Authorization with Service Accounts","text":""},{"location":"OpenShift%20Castle/61_privileged_containers/#objective","title":"Objective","text":"<p>Learn how to manage privileged containers and use service accounts for application authorization in OpenShift.</p>"},{"location":"OpenShift%20Castle/61_privileged_containers/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Kubernetes security mechanisms, including SCCs and RBAC.</li> <li>Familiarity with YAML syntax for configuring service accounts and roles.</li> </ul>"},{"location":"OpenShift%20Castle/61_privileged_containers/#introduction","title":"Introduction","text":"<p>In the fortified kingdom of OpenShift, some tasks require elevated privileges, much like certain castle tasks needing access to restricted areas. While these tasks pose security risks, proper management through Security Context Constraints (SCCs) and Role-Based Access Control (RBAC) ensures that only trusted entities gain such access. This section delves into handling privileged containers and authorizing applications using service accounts.</p>"},{"location":"OpenShift%20Castle/61_privileged_containers/#privileged-containers","title":"Privileged Containers","text":"<p>Privileged containers are akin to granting a select few individuals access to the castle's secret tunnels and armory. These containers require access to the host's runtime environment, which introduces security risks. To mitigate these risks, SCCs are used to enable and manage privileged access.</p>"},{"location":"OpenShift%20Castle/61_privileged_containers/#enabling-privileged-access","title":"Enabling Privileged Access","text":"<p>To allow containers to run with privileged access, you need to create service accounts specifically configured for this purpose.</p> <ol> <li> <p>Create a Service Account: First, create a service account for the application needing privileged access. Specify the namespace if required:</p> <pre><code>oc create serviceaccount privileged-account -n namespace\n</code></pre> </li> <li> <p>Grant Privileged SCC: Associate the service account with the <code>privileged</code> SCC:</p> <pre><code>oc adm policy add-scc-to-user privileged -z privileged-account -n namespace\n</code></pre> </li> <li> <p>Assign the Service Account to a Pod: Modify the pod or deployment to use the newly created service account:</p> <pre><code>oc set serviceaccount deployment/&lt;deployment-name&gt; privileged-account -n namespace\n</code></pre> </li> </ol> <p>By following these steps, you ensure that only designated containers gain the necessary privileges, much like a trusted knight given keys to the castle's armory.</p>"},{"location":"OpenShift%20Castle/61_privileged_containers/#application-authorization-with-service-accounts","title":"Application Authorization with Service Accounts","text":"<p>In the kingdom of OpenShift, applications need explicit permission to access certain areas, much like artisans needing permits to work in specialized workshops. This is managed through RBAC and service accounts.</p>"},{"location":"OpenShift%20Castle/61_privileged_containers/#role-based-access-control-rbac","title":"Role-Based Access Control (RBAC)","text":"<p>RBAC in OpenShift is preconfigured to control access to the Kubernetes API. Applications require explicit RBAC authorization to access restricted APIs, ensuring that only authorized entities interact with sensitive resources.</p>"},{"location":"OpenShift%20Castle/61_privileged_containers/#using-service-accounts-for-authorization","title":"Using Service Accounts for Authorization","text":"<p>A service account in Kubernetes represents the identity of an application running in a pod. Here's how to grant an application access to the Kubernetes API using service accounts:</p> <ol> <li> <p>Create a Service Account: Create a service account within the project:</p> <pre><code>oc create serviceaccount app-service-account -n namespace\n</code></pre> </li> <li> <p>Grant API Access: Assign the necessary roles to the service account to grant access to the Kubernetes API:</p> <pre><code>oc adm policy add-role-to-user &lt;role&gt; -z app-service-account -n namespace\n</code></pre> </li> <li> <p>Assign the Service Account to Pods: Update the application's pods or deployments to use the service account:</p> <pre><code>oc set serviceaccount deployment/&lt;deployment-name&gt; app-service-account -n namespace\n</code></pre> </li> </ol>"},{"location":"OpenShift%20Castle/61_privileged_containers/#default-service-account","title":"Default Service Account","text":"<p>If a service account is not explicitly assigned to a pod, the pod uses the <code>default</code> service account, which typically has no special permissions in OpenShift. This ensures a baseline level of security, preventing unintended access to sensitive resources.</p>"},{"location":"OpenShift%20Castle/61_privileged_containers/#conclusion","title":"Conclusion","text":"<p>Managing privileged containers and application authorization in OpenShift is crucial for maintaining security and control within the cluster, much like safeguarding the inner workings of a castle. By properly using SCCs and service accounts, administrators can ensure that only trusted applications and containers gain the access they need while minimizing security risks. This approach helps maintain a secure and well-functioning environment, protecting both the infrastructure and its inhabitants from potential threats.</p>"},{"location":"OpenShift%20Castle/62_k8s_api_access/","title":"Use Cases for Kubernetes API Access","text":""},{"location":"OpenShift%20Castle/62_k8s_api_access/#objective","title":"Objective","text":"<p>Understand how to manage Kubernetes API access for different types of infrastructure applications in OpenShift, including monitoring applications, controllers, and operators.</p>"},{"location":"OpenShift%20Castle/62_k8s_api_access/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Understanding of Kubernetes API and role-based access control.</li> <li>Basic knowledge of YAML syntax for defining roles and bindings in Kubernetes.</li> </ul>"},{"location":"OpenShift%20Castle/62_k8s_api_access/#introduction","title":"Introduction","text":"<p>In the OpenShift kingdom, various entities require special permissions to monitor or modify the cluster, much like how different roles in a castle\u2014guards, overseers, and engineers\u2014need specific access rights to perform their duties. These entities are categorized into monitoring applications, controllers, and operators, each needing tailored access to the Kubernetes API.</p>"},{"location":"OpenShift%20Castle/62_k8s_api_access/#application-kubernetes-api-authorization-with-roles","title":"Application Kubernetes API Authorization with Roles","text":"<p>To provide applications with the necessary permissions while adhering to the principle of least privilege, you can create roles or cluster roles. These roles describe the specific permissions required by the application, similar to how a castle might grant different keys to its staff to access only the areas they need for their duties.</p>"},{"location":"OpenShift%20Castle/62_k8s_api_access/#example-creating-a-cluster-role","title":"Example: Creating a Cluster Role","text":"<p>A cluster role might be necessary for an application that needs to read secrets across all namespaces. This is akin to giving the castle's master key to a trusted advisor who needs to access various rooms for inspection:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: secret-reader\nrules:\n- apiGroups: [\"\"]\n  resources: [\"secrets\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n</code></pre> <p>In this configuration: - <code>apiGroups: [\"\"]</code> refers to the core API group. - The role grants permissions to <code>get</code>, <code>watch</code>, and <code>list</code> secrets.</p> <p>OpenShift includes predefined cluster roles such as <code>edit</code>, which allows applications to create and update most objects, much like how the castle steward can modify room arrangements as needed.</p>"},{"location":"OpenShift%20Castle/62_k8s_api_access/#binding-roles-to-service-accounts","title":"Binding Roles to Service Accounts","text":"<p>To grant an application the permissions defined in a role, you must bind the role to the application's service account. This is similar to officially assigning keys to different castle staff.</p>"},{"location":"OpenShift%20Castle/62_k8s_api_access/#binding-a-role-to-a-service-account","title":"Binding a Role to a Service Account","text":"<p>Use the following command to bind a role to a service account, akin to handing over the key to a specific room:</p> <pre><code>oc adm policy add-role-to-user secret-reader -z app-service-account\n</code></pre>"},{"location":"OpenShift%20Castle/62_k8s_api_access/#creating-a-cluster-role-binding","title":"Creating a Cluster Role Binding","text":"<p>For cluster-wide permissions, use this command to grant broader access, like giving the head guard keys to multiple sections of the castle:</p> <pre><code>oc adm policy add-cluster-role-to-user secret-reader app-service-account\n</code></pre>"},{"location":"OpenShift%20Castle/62_k8s_api_access/#assigning-an-application-service-account-to-pods","title":"Assigning an Application Service Account to Pods","text":"<p>OpenShift uses RBAC to manage resource access based on the roles associated with the service account. To ensure that an application uses the assigned permissions, you need to specify the service account in the pod definition. This ensures that the right person is accessing the right part of the castle.</p>"},{"location":"OpenShift%20Castle/62_k8s_api_access/#specifying-the-service-account-in-the-pod-definition","title":"Specifying the Service Account in the Pod Definition","text":"<p>In the pod definition, set the <code>spec.serviceAccountName</code> field to the name of the service account, like assigning a staff member to a specific duty:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: example-pod\nspec:\n  serviceAccountName: app-service-account\n  containers:\n  - name: example-container\n    image: example-image\n</code></pre>"},{"location":"OpenShift%20Castle/62_k8s_api_access/#using-the-service-account-token","title":"Using the Service Account Token","text":"<p>Applications must use the service account token to access the Kubernetes API. Generate and mount the token as a pod volume using the <code>TokenRequest</code> API, akin to ensuring the guard has the right key for their assigned post.</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: example-pod\nspec:\n  serviceAccountName: app-service-account\n  containers:\n  - name: example-container\n    image: example-image\n    volumeMounts:\n    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount\n      name: token\n  volumes:\n  - name: token\n    projected:\n      sources:\n      - serviceAccountToken:\n          path: token\n          expirationSeconds: 7200\n</code></pre> <p>In this example: - The service account token is mounted as a volume, providing the application with the necessary credentials to access the Kubernetes API.</p>"},{"location":"OpenShift%20Castle/62_k8s_api_access/#conclusion","title":"Conclusion","text":"<p>Managing Kubernetes API access for infrastructure applications in OpenShift is crucial for maintaining security and ensuring that applications have the permissions they need to function correctly. By defining and binding roles to service accounts and properly configuring pods, you can control access effectively, much like how a castle's hierarchy manages access to its various sections. This ensures a secure, well-functioning environment where each application can perform its duties without compromising the security of the cluster.</p>"},{"location":"OpenShift%20Castle/63_scoping_application_access/","title":"Scoping Application Access to Kubernetes API Resources","text":""},{"location":"OpenShift%20Castle/63_scoping_application_access/#objective","title":"Objective","text":"<p>Understand how to manage and scope application access to Kubernetes API resources within OpenShift, ensuring applications have the necessary permissions while adhering to the principle of least privilege.</p>"},{"location":"OpenShift%20Castle/63_scoping_application_access/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Understanding of Kubernetes RBAC (Role-Based Access Control) and service accounts.</li> <li>Basic knowledge of YAML syntax for creating and editing configuration files.</li> </ul>"},{"location":"OpenShift%20Castle/63_scoping_application_access/#introduction","title":"Introduction","text":"<p>In the OpenShift kingdom, applications often need access to various resources, much like how different roles within a castle require access to specific rooms and areas. Properly scoping this access ensures security and functionality without over-provisioning permissions.</p>"},{"location":"OpenShift%20Castle/63_scoping_application_access/#accessing-api-resources-in-the-same-namespace","title":"Accessing API Resources in the Same Namespace","text":"<p>To grant an application access to resources within the same namespace, you need to follow a process similar to granting a castle guard access to a specific wing of the castle.</p>"},{"location":"OpenShift%20Castle/63_scoping_application_access/#steps","title":"Steps:","text":"<ol> <li>Create a Role or Cluster Role: Define the permissions required for the application within the namespace.</li> <li>Create a Service Account: This service account represents the application's identity within the namespace.</li> <li>Create a Role Binding: Associate the service account with the role, allowing it to perform the actions specified by the role on the resource.</li> </ol>"},{"location":"OpenShift%20Castle/63_scoping_application_access/#example","title":"Example:","text":"<p>Creating a role and binding it to a service account within the same namespace:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: example-namespace\n  name: pod-reader\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: example-sa\n  namespace: example-namespace\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: read-pods\n  namespace: example-namespace\nsubjects:\n- kind: ServiceAccount\n  name: example-sa\n  namespace: example-namespace\nroleRef:\n  kind: Role\n  name: pod-reader\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"OpenShift%20Castle/63_scoping_application_access/#accessing-api-resources-in-a-different-namespace","title":"Accessing API Resources in a Different Namespace","text":"<p>When an application needs access to resources in a different namespace, it's like granting a guard access to a different wing of the castle. You need to create the role binding in the namespace where the resource resides and reference the service account from the other namespace.</p>"},{"location":"OpenShift%20Castle/63_scoping_application_access/#steps_1","title":"Steps:","text":"<ol> <li>Create a Role in the Target Namespace: Define the permissions required for the application within the target namespace.</li> <li>Create a Role Binding in the Target Namespace: Bind the role to the service account from the other namespace using the <code>system:serviceaccount</code> format.</li> </ol>"},{"location":"OpenShift%20Castle/63_scoping_application_access/#example_1","title":"Example:","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: target-namespace\n  name: secret-reader\nrules:\n- apiGroups: [\"\"]\n  resources: [\"secrets\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: read-secrets\n  namespace: target-namespace\nsubjects:\n- kind: ServiceAccount\n  name: example-sa\n  namespace: source-namespace\n  apiGroup: \"\"\nroleRef:\n  kind: Role\n  name: secret-reader\n  apiGroup: rbac.authorization.k8s.io\n</code></pre> <p>In the <code>subjects</code> field, <code>system:serviceaccount:source-namespace:example-sa</code> is used to reference the service account from the other namespace.</p>"},{"location":"OpenShift%20Castle/63_scoping_application_access/#accessing-api-resources-in-all-namespaces","title":"Accessing API Resources in All Namespaces","text":"<p>To grant an application access to resources across all namespaces, you must use a cluster role binding, similar to giving a high-ranking official keys to all the castle's wings.</p>"},{"location":"OpenShift%20Castle/63_scoping_application_access/#steps_2","title":"Steps:","text":"<ol> <li>Create a Cluster Role: Define the global permissions required by the application.</li> <li>Create a Cluster Role Binding: Associate the cluster role with the application service account, granting it access across the entire cluster.</li> </ol>"},{"location":"OpenShift%20Castle/63_scoping_application_access/#example_2","title":"Example:","text":"<p>Creating a cluster role and binding it to a service account for access across all namespaces:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: cluster-secret-reader\nrules:\n- apiGroups: [\"\"]\n  resources: [\"secrets\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: read-secrets-global\nsubjects:\n- kind: ServiceAccount\n  name: example-sa\n  namespace: example-namespace\nroleRef:\n  kind: ClusterRole\n  name: cluster-secret-reader\n  apiGroup: rbac.authorization.k8s.io\n</code></pre> <p>In this setup, the service account <code>example-sa</code> in the namespace <code>example-namespace</code> is granted cluster-wide access to read secrets.</p>"},{"location":"OpenShift%20Castle/63_scoping_application_access/#conclusion","title":"Conclusion","text":"<p>By carefully scoping application access to Kubernetes API resources, you ensure that applications have the permissions they need while maintaining the security and integrity of the cluster. This approach mirrors how a castle manages access to its various areas, granting specific keys to different roles to maintain order and security.</p>"},{"location":"OpenShift%20Castle/64_k8s_batch_api_resources/","title":"Kubernetes Batch API Resources","text":""},{"location":"OpenShift%20Castle/64_k8s_batch_api_resources/#objective","title":"Objective","text":"<p>This tutorial aims to guide you through the process of automating tasks in OpenShift using Kubernetes jobs and cron jobs.</p>"},{"location":"OpenShift%20Castle/64_k8s_batch_api_resources/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Familiarity with Kubernetes batch resources, including jobs and cron jobs.</li> <li>Basic knowledge of YAML syntax for creating and editing configuration files.</li> </ul>"},{"location":"OpenShift%20Castle/64_k8s_batch_api_resources/#introduction","title":"Introduction","text":"<p>In the grand kingdom of OpenShift, automation plays a crucial role in maintaining order and efficiency. Just as a medieval castle relies on automated mechanisms like clock chimes and automated gates, OpenShift uses Kubernetes batch resources\u2014jobs and cron jobs\u2014to manage repetitive and scheduled tasks. These tasks range from simple one-off commands to complex maintenance routines that keep the infrastructure running smoothly. Understanding how to effectively utilize these batch resources is key to ensuring the kingdom's stability and prosperity.</p>"},{"location":"OpenShift%20Castle/64_k8s_batch_api_resources/#kubernetes-jobs","title":"Kubernetes Jobs","text":"<p>A Kubernetes job is akin to a knight given a specific quest to complete a single task. It ensures that a specified number of pods run to completion successfully. The job resource includes a pod template that describes the task to execute.</p>"},{"location":"OpenShift%20Castle/64_k8s_batch_api_resources/#example","title":"Example:","text":"<p>To create a job, you can use the <code>oc create job --dry-run=client</code> command to generate the YAML representation, like a scribe drafting the quest details for the knight:</p> <pre><code>oc create job --dry-run=client -o yaml test \\\n--image=registry.access.redhat.com/ubi9/ubi:9.4 \\\n-- curl https://example.com\n</code></pre> <p>This command outlines a job that uses a pod with a container running the Universal Base Image (UBI) and executes a curl command to access a website.</p>"},{"location":"OpenShift%20Castle/64_k8s_batch_api_resources/#kubernetes-cron-jobs","title":"Kubernetes Cron Jobs","text":"<p>A Kubernetes cron job is like a castle bell ringer, tasked with ringing the bell at specific times. It runs jobs on a schedule, ensuring that tasks are performed regularly.</p>"},{"location":"OpenShift%20Castle/64_k8s_batch_api_resources/#example_1","title":"Example:","text":"<p>To create a cron job, you can use the <code>oc create cronjob --dry-run=client</code> command to get the YAML representation:</p> <pre><code>oc create cronjob --dry-run=client -o yaml test \\\n--image=registry.access.redhat.com/ubi9/ubi:9.4 \\\n--schedule='0 0 * * *' \\\n-- curl https://example.com\n</code></pre> <p>This command creates a cron job scheduled to run at midnight every day, executing a curl command using a container running the UBI.</p>"},{"location":"OpenShift%20Castle/64_k8s_batch_api_resources/#automating-application-maintenance-tasks","title":"Automating Application Maintenance Tasks","text":"<p>Just as the castle has regular maintenance to keep its structures sound, applications in OpenShift often need regular maintenance tasks. Here\u2019s an example of a cron job automating a WordPress backup:</p> <pre><code>apiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: wordpress-backup\nspec:\n  schedule: 0 2 * * 7\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          dnsPolicy: ClusterFirst\n          restartPolicy: Never\n          containers:\n          - name: wp-cli\n            image: registry.io/wp-maintenance/wp-cli:2.7\n            resources: {}\n            command:\n            - bash\n            - -xc\n            args:\n            - &gt;\n              wp maintenance-mode activate ;\n              wp db export | gzip &gt; database.sql.gz ;\n              wp maintenance-mode deactivate ;\n              rclone copy database.sql.gz s3://bucket/backups/ ;\n              rm -v database.sql.gz ;\n</code></pre> <p>This cron job activates WordPress maintenance mode, exports and compresses the database, uploads it to an S3 bucket, and then cleans up.</p>"},{"location":"OpenShift%20Castle/64_k8s_batch_api_resources/#automating-cluster-maintenance-tasks","title":"Automating Cluster Maintenance Tasks","text":"<p>Just as the castle's guards perform regular patrols to ensure safety, clusters need regular maintenance to stay healthy. Here\u2019s an example of a script for image pruning:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: maintenance\n  app: crictl\ndata:\n  maintenance.sh: |\n    #!/bin/bash\n    NODES=$(oc get nodes -o=name)\n    for NODE in ${NODES}\n    do\n      echo ${NODE}\n      oc debug ${NODE} -- \\\n      chroot /host \\\n        /bin/bash -xc 'crictl images ; crictl rmi --prune'\n      echo $?\n    done\n</code></pre> <p>This script lists and prunes unused images on each node. It can be executed as a cron job:</p> <pre><code>apiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: image-pruner\nspec:\n  schedule: 0 * * * *\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          dnsPolicy: ClusterFirst\n          restartPolicy: Never\n          containers:\n          - name: image-pruner\n            image: quay.io/openshift/origin-cli:4.12\n            resources: {}\n            command:\n            - /opt/scripts/maintenance.sh\n            volumeMounts:\n            - name: scripts\n              mountPath: /opt\n          volumes:\n          - name: scripts\n            configMap:\n              name: maintenance\n              defaultMode: 0555\n</code></pre>"},{"location":"OpenShift%20Castle/64_k8s_batch_api_resources/#assigning-privileged-access","title":"Assigning Privileged Access","text":"<p>Sometimes, maintenance tasks require higher privileges, much like how certain castle tasks require special keys. You can create a service account with the required privileges and associate it with the cron job:</p> <pre><code>oc create serviceaccount maintenance-sa\noc adm policy add-scc-to-user privileged -z maintenance-sa\n</code></pre> <p>Then, specify the service account in the cron job:</p> <pre><code>spec:\n  serviceAccountName: maintenance-sa\n</code></pre>"},{"location":"OpenShift%20Castle/64_k8s_batch_api_resources/#conclusion","title":"Conclusion","text":"<p>By leveraging Kubernetes jobs and cron jobs, you can automate and schedule critical tasks in OpenShift, ensuring your applications and clusters are well-maintained. This automation is akin to the efficient operation of a castle, where every task is carefully scheduled and executed, ensuring the kingdom runs smoothly and securely.</p>"},{"location":"OpenShift%20Castle/65_cluster_updates_intro/","title":"Introducing Cluster Updates","text":""},{"location":"OpenShift%20Castle/65_cluster_updates_intro/#objective","title":"Objective","text":"<p>Learn how to manage OpenShift cluster updates using Over-the-Air (OTA) updates to access new features, bug fixes, and security patches through a unified interface.</p>"},{"location":"OpenShift%20Castle/65_cluster_updates_intro/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Understanding of OpenShift cluster versions and update channels.</li> <li>Basic knowledge of YAML syntax for patching resources using the <code>oc</code> client.</li> </ul>"},{"location":"OpenShift%20Castle/65_cluster_updates_intro/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, keeping your cluster up-to-date ensures that your operations run smoothly and securely, much like ensuring the castle's defenses are regularly maintained and upgraded. Over-the-Air (OTA) updates provide a streamlined way to manage these updates, allowing you to leverage the latest features and improvements.</p>"},{"location":"OpenShift%20Castle/65_cluster_updates_intro/#cluster-updates-overview","title":"Cluster Updates Overview","text":"<p>OpenShift clusters support OTA updates, enabling administrators to apply new features, bug fixes, and security patches as they become available. This capability ensures that your cluster remains robust and up-to-date, much like a castle that regularly upgrades its fortifications and amenities.</p>"},{"location":"OpenShift%20Castle/65_cluster_updates_intro/#changing-the-update-channel","title":"Changing the Update Channel","text":"<p>In OpenShift, an update channel represents a specific upgrade path, guiding the cluster through different versions and ensuring compatibility and stability. Switching to a different update channel can be likened to choosing a new strategy for enhancing the castle's defenses, ensuring that you stay ahead of potential threats.</p>"},{"location":"OpenShift%20Castle/65_cluster_updates_intro/#steps-to-change-the-update-channel","title":"Steps to Change the Update Channel:","text":"<ol> <li>Identify the Desired Channel: Determine the channel you want to switch to based on your requirements (e.g., stability, new features).</li> <li>Use the <code>oc</code> Client to Patch the Cluster Version: Apply the patch to change the update channel.</li> </ol>"},{"location":"OpenShift%20Castle/65_cluster_updates_intro/#example","title":"Example:","text":"<p>To switch to the \"fast-4.14\" update channel using the <code>oc</code> client:</p> <pre><code>oc patch clusterversion version --type=\"merge\" --patch '{\"spec\":{\"channel\":\"fast-4.14\"}}'\n</code></pre> <p>This command changes the update channel to \"fast-4.14,\" allowing the cluster to receive updates from this channel. It's akin to directing the castle's guards to adopt a new protocol for enhanced security.</p>"},{"location":"OpenShift%20Castle/65_cluster_updates_intro/#conclusion","title":"Conclusion","text":"<p>Managing cluster updates effectively is crucial for maintaining a secure and efficient OpenShift environment. By utilizing OTA updates and appropriately managing update channels, you ensure that your cluster, much like a well-defended castle, remains fortified against potential issues while benefiting from the latest advancements and features.</p>"},{"location":"OpenShift%20Castle/66_pausing_machine_health/","title":"Pausing the Machine Health Check Resource","text":""},{"location":"OpenShift%20Castle/66_pausing_machine_health/#objective","title":"Objective","text":"<p>Learn how to manage the Machine Health Check (MHC) resource during the cluster upgrade process to prevent unnecessary node reboots.</p>"},{"location":"OpenShift%20Castle/66_pausing_machine_health/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster or a terminal emulator connected to one.</li> <li>Basic understanding of Machine Health Check (MHC) resources in Kubernetes.</li> <li>Familiarity with using <code>oc</code> commands to annotate and manage resources.</li> </ul>"},{"location":"OpenShift%20Castle/66_pausing_machine_health/#introduction","title":"Introduction","text":"<p>In the grand kingdom of OpenShift, ensuring the stability and efficiency of worker nodes is paramount to the castle's defense strategy. The Machine Health Check (MHC) acts as vigilant sentries, ever watchful for signs of trouble among the kingdom\u2019s nodes. However, during the upgrade process, nodes may appear temporarily unwell, much like soldiers resting and recovering in the barracks. Just as wise rulers would pause certain security measures during peacetime adjustments to avoid unnecessary alarms, administrators can pause the MHC to prevent it from mistaking these temporary states for serious issues, thereby avoiding unnecessary reboots.</p>"},{"location":"OpenShift%20Castle/66_pausing_machine_health/#steps-to-pause-and-resume-machine-health-check","title":"Steps to Pause and Resume Machine Health Check","text":"<p>Pausing the MHC ensures that worker nodes are not rebooted during the upgrade, allowing for a smooth and uninterrupted update process. Think of this as a royal decree to temporarily ease the watchful eyes of the sentries, ensuring that their well-meaning but potentially disruptive interventions are paused.</p>"},{"location":"OpenShift%20Castle/66_pausing_machine_health/#listing-available-machine-health-check-resources","title":"Listing Available Machine Health Check Resources","text":"<p>First, gather intelligence on the available MHC resources within the <code>openshift-machine-api</code> namespace. This step is akin to consulting the royal records to understand the current state of castle defenses before making any strategic changes.</p> <pre><code>oc get machinehealthcheck -n openshift-machine-api\n</code></pre>"},{"location":"OpenShift%20Castle/66_pausing_machine_health/#pausing-the-machine-health-check-resource_1","title":"Pausing the Machine Health Check Resource","text":"<p>Next, issue a royal decree to pause the MHC resource by adding the <code>cluster.x-k8s.io/paused</code> annotation. This annotation acts like a temporary truce, instructing the sentries to stand down and refrain from taking action during the upgrade.</p> <pre><code>oc annotate machinehealthcheck -n openshift-machine-api machine-api-termination-handler cluster.x-k8s.io/paused=\"\"\n</code></pre>"},{"location":"OpenShift%20Castle/66_pausing_machine_health/#example-command","title":"Example Command","text":"<p>For instance, to pause the MHC resource named <code>machine-api-termination-handler</code>, the command is:</p> <pre><code>oc annotate machinehealthcheck -n openshift-machine-api machine-api-termination-handler cluster.x-k8s.io/paused=\"\"\n</code></pre>"},{"location":"OpenShift%20Castle/66_pausing_machine_health/#resuming-the-machine-health-check-resource","title":"Resuming the Machine Health Check Resource","text":"<p>Once the cluster upgrade is complete, remove the <code>cluster.x-k8s.io/paused</code> annotation to lift the truce and allow the MHC to resume its vigilant watch. This is akin to ending the temporary ceasefire, enabling the sentries to return to their full duties in safeguarding the castle.</p> <pre><code>oc annotate machinehealthcheck -n openshift-machine-api machine-api-termination-handler cluster.x-k8s.io/paused-\n</code></pre>"},{"location":"OpenShift%20Castle/66_pausing_machine_health/#example-command_1","title":"Example Command","text":"<p>To resume the MHC resource named <code>machine-api-termination-handler</code>, the command is:</p> <pre><code>oc annotate machinehealthcheck -n openshift-machine-api machine-api-termination-handler cluster.x-k8s.io/paused-\n</code></pre>"},{"location":"OpenShift%20Castle/66_pausing_machine_health/#conclusion","title":"Conclusion","text":"<p>By effectively managing the Machine Health Check resource during the upgrade process, you ensure that your OpenShift kingdom remains stable and efficient, much like a well-defended castle avoiding unnecessary disturbances. Pausing the MHC resource temporarily prevents the misinterpretation of node unavailability as critical issues, thereby maintaining a smooth and uninterrupted upgrade process. The wise rulers of OpenShift know that sometimes, a strategic pause is the best way to ensure long-term stability and peace in their realm.</p>"},{"location":"OpenShift%20Castle/67_updating_cluster/","title":"Updating the Cluster","text":""},{"location":"OpenShift%20Castle/67_updating_cluster/#objective","title":"Objective","text":"<p>Learn how to update your OpenShift cluster using both the web console and the command-line interface (CLI), while ensuring all prerequisites are met.</p>"},{"location":"OpenShift%20Castle/67_updating_cluster/#prerequisites","title":"Prerequisites","text":"<p>Before updating your OpenShift cluster, ensure the following: 1. All operators installed through the Operator Lifecycle Manager (OLM) are updated to their latest versions. 2. For production clusters, ensure the update channel is set to stable.</p>"},{"location":"OpenShift%20Castle/67_updating_cluster/#introduction","title":"Introduction","text":"<p>In the kingdom of OpenShift, maintaining an up-to-date infrastructure is akin to ensuring the castle is fortified with the latest defenses and technologies. Regular updates bring new features, security enhancements, and bug fixes, much like reinforcements and upgrades to a castle\u2019s defenses. As a wise ruler, it\u2019s essential to follow a structured process to update the cluster, ensuring the realm remains secure and efficient.</p>"},{"location":"OpenShift%20Castle/67_updating_cluster/#updating-the-cluster-via-web-console","title":"Updating the Cluster via Web Console","text":"<p>The web console provides an intuitive interface for initiating cluster updates.</p> <ol> <li>Navigate to Administration &gt; Cluster Settings.</li> <li>When a new update is available, click Update now to begin the process.</li> </ol> <p>Note: Rolling back your cluster to an earlier version is not supported. If your update fails to complete, contact Red Hat support.</p>"},{"location":"OpenShift%20Castle/67_updating_cluster/#updating-the-cluster-via-command-line-interface-cli","title":"Updating the Cluster via Command-Line Interface (CLI)","text":"<p>For those who prefer the precision of command-line tools, the CLI offers a powerful way to manage cluster updates.</p>"},{"location":"OpenShift%20Castle/67_updating_cluster/#step-by-step-cli-update-process","title":"Step-by-Step CLI Update Process","text":"<ol> <li> <p>Update All Operators:    Ensure all operators installed through the OLM are updated to the latest version before updating the OpenShift cluster. This is akin to preparing all the castle\u2019s defenses before a major upgrade.</p> </li> <li> <p>Retrieve Cluster Version and Update Channel Information:</p> </li> <li>Retrieve the current cluster version:      <pre><code>oc get clusterversion\n</code></pre></li> <li> <p>Review the current update channel information. Ensure it reads stable if running in production:      <pre><code>oc get clusterversion -o jsonpath='{.items[0].spec.channel}{\"\\n\"}'\n</code></pre></p> </li> <li> <p>View Available Updates:    Discover the available updates and note the version number to apply. This step is like surveying the available reinforcements and choosing the best fit for your castle.    <pre><code>oc adm upgrade\n</code></pre></p> </li> <li> <p>Apply the Update:</p> </li> <li>To install the latest available update:      <pre><code>oc adm upgrade --to-latest=true\n</code></pre></li> <li> <p>To install a specific version, where <code>VERSION</code> corresponds to an available version:      <pre><code>oc adm upgrade --to=VERSION\n</code></pre></p> </li> <li> <p>Review the Update Status:    Once the update process is initiated, monitor the status of the Cluster Version Operator (CVO) and the installed cluster operators. This ensures all components are updating correctly, similar to overseeing the progress of castle upgrades.    <pre><code>oc get clusterversion\noc get clusteroperators\n</code></pre></p> </li> <li> <p>Monitor the Update Process:    Review the cluster version history and monitor the status of the update. It might take some time for all objects to finish updating. Successful updates have a Completed state, while incomplete updates have a Partial state.    <pre><code>oc describe clusterversion\n</code></pre></p> </li> </ol> <p>If the update fails to complete, the CVO reports the status of any blocking components and attempts to reconcile the update. Contact Red Hat support if the issue persists.</p> <ol> <li>Confirm the Update:    After the process completes, confirm that the cluster is updated to the new version. This final check ensures the castle\u2019s defenses are now fully upgraded and ready to protect the realm.    <pre><code>oc get clusterversion\n</code></pre></li> </ol>"},{"location":"OpenShift%20Castle/67_updating_cluster/#conclusion","title":"Conclusion","text":"<p>Updating your OpenShift cluster is a crucial task that ensures your environment remains secure, efficient, and up-to-date with the latest features. By following these steps, whether through the web console or CLI, you can manage the updates seamlessly, much like a wise ruler upgrading the castle\u2019s defenses to protect the kingdom. Remember, while rolling back is not supported, Red Hat support is always available to assist with any issues during the update process.</p>"},{"location":"OpenShift%20Castle/68_api_deprecation_policy/","title":"Kubernetes API Deprecation Policy","text":""},{"location":"OpenShift%20Castle/68_api_deprecation_policy/#objective","title":"Objective","text":"<p>Help administrators navigate the deprecation and removal of Kubernetes API versions, ensuring that their clusters remain up-to-date and functional.</p>"},{"location":"OpenShift%20Castle/68_api_deprecation_policy/#introduction","title":"Introduction","text":"<p>In the grand kingdom of Kubernetes, the API serves as the central hall where all commands are issued and executed. Just as a well-managed kingdom evolves its laws and practices to remain effective, Kubernetes updates its APIs to ensure robustness and security. Understanding the deprecation policy of Kubernetes APIs is essential for maintaining the harmony and functionality of your clusters.</p>"},{"location":"OpenShift%20Castle/68_api_deprecation_policy/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster.</li> <li>Familiarity with Kubernetes API and resource management.</li> <li>Administrative privileges to view and manage API resources.</li> </ul>"},{"location":"OpenShift%20Castle/68_api_deprecation_policy/#understanding-api-versions","title":"Understanding API Versions","text":"<p>In our Kubernetes kingdom, API versions are like the evolving laws: - Experimental: Newly introduced laws being tested. - Pre-release: Laws that are being fine-tuned based on feedback. - Stable: Well-established laws that are widely adopted.</p> <p>To check the current version of a specific resource, such as cronjobs, use: <pre><code>oc api-resources | egrep '^NAME|cronjobs'\n</code></pre></p>"},{"location":"OpenShift%20Castle/68_api_deprecation_policy/#deprecation-and-removal-policy","title":"Deprecation and Removal Policy","text":"<p>When a new stable version of a feature is decreed, any older beta versions are marked as deprecated, similar to old laws being phased out. These deprecated versions are typically removed after three Kubernetes releases. It's crucial to track these changes to prevent any disruptions in your operations.</p>"},{"location":"OpenShift%20Castle/68_api_deprecation_policy/#handling-deprecation-warnings","title":"Handling Deprecation Warnings","text":"<p>If you issue a command using a deprecated API version, the API server responds with a deprecation warning, much like the castle's heralds announcing that certain laws will soon change. This warning includes the current version of the cluster.</p>"},{"location":"OpenShift%20Castle/68_api_deprecation_policy/#handling-removed-api-versions","title":"Handling Removed API Versions","text":"<p>Attempting to use an API version that has been removed is like trying to follow an old law that is no longer valid. The API server will return an error, indicating that the version is not supported in the cluster.</p>"},{"location":"OpenShift%20Castle/68_api_deprecation_policy/#monitoring-api-requests","title":"Monitoring API Requests","text":"<p>To ensure your kingdom\u2019s operations are up-to-date, monitor the API request counts to identify usage of deprecated API versions. The REMOVEDINRELEASE column indicates when a specific API version will be removed: <pre><code>oc get apirequestcounts | awk '{if(NF==4){print $0}}'\n</code></pre></p> <p>To gather detailed information about the actions for a resource and identify who performed them, use a JSONPath filter: <pre><code>FILTER='{range .status.currentHour..byUser[*]}{..byVerb[*].verb}{\",\"}{.username}{\",\"}{.userAgent}{\"\\n\"}{end}'\nTYPE=apirequestcount.apiserver.openshift.io/cronjobs.v1beta1.batch\necho ${TYPE} ; oc get ${TYPE} -o jsonpath=\"${FILTER}\" | column -t -s ',' -N \"Verbs,Username,UserAgent\"\n</code></pre></p> <p>This command helps track which knights and courtiers (users and systems) are still relying on old laws (deprecated API versions).</p>"},{"location":"OpenShift%20Castle/68_api_deprecation_policy/#conclusion","title":"Conclusion","text":"<p>Keeping your Kubernetes API usage current is akin to ensuring that your kingdom's laws are up-to-date. Regularly reviewing deprecation warnings and planning upgrades accordingly will maintain a robust and efficient OpenShift environment. By staying informed and proactive, you can ensure that your Kubernetes kingdom remains secure and well-governed.</p>"},{"location":"OpenShift%20Castle/69_deprecated_and_removed_features/","title":"Deprecated and Removed Features in OpenShift","text":""},{"location":"OpenShift%20Castle/69_deprecated_and_removed_features/#objective","title":"Objective","text":"<p>Assist administrators in managing deprecated and removed features in OpenShift to ensure smooth cluster updates and continued functionality.</p>"},{"location":"OpenShift%20Castle/69_deprecated_and_removed_features/#introduction","title":"Introduction","text":"<p>In the grand kingdom of OpenShift, deprecated features are like old customs that need to be retired for the kingdom to flourish. Recognizing and managing these deprecated APIs is essential to maintaining the realm\u2019s health and security. OpenShift provides mechanisms to alert administrators when deprecated APIs are in use and requires explicit acknowledgment before cluster updates to ensure a smooth transition to newer versions.</p>"},{"location":"OpenShift%20Castle/69_deprecated_and_removed_features/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster.</li> <li>Familiarity with OpenShift monitoring and Prometheus.</li> <li>Administrative privileges to manage cluster updates and configurations.</li> </ul>"},{"location":"OpenShift%20Castle/69_deprecated_and_removed_features/#deprecated-and-removed-features","title":"Deprecated and Removed Features","text":"<p>OpenShift includes two specific alerts for deprecated API usage: - APIRemovedInNextReleaseInUse: Triggered for APIs scheduled for removal in the next OpenShift Container Platform release. - APIRemovedInNextEUSReleaseInUse: Triggered for APIs scheduled for removal in the next Extended Update Support (EUS) release.</p>"},{"location":"OpenShift%20Castle/69_deprecated_and_removed_features/#extracting-deprecated-api-alerts","title":"Extracting Deprecated API Alerts","text":"<p>To keep the kingdom of OpenShift secure, administrators must identify and manage deprecated APIs. By extracting alerts in JSON format from the Prometheus stateful set and filtering the results, you can identify which deprecated APIs are still in use. This process is akin to the royal scribes keeping track of old laws that need to be updated.</p> <p>Run the following commands to retrieve deprecated API alerts: <pre><code>oc exec -it statefulset/prometheus-k8s -c prometheus \\\n-n openshift-monitoring -- \\\ncurl -fsSL 'http://localhost:9090/api/v1/alerts' | jq . &gt; alerts.json\n\njq '[.data.alerts[] |\nselect(.labels.alertname==\"APIRemovedInNextReleaseInUse\" or\n.labels.alertname==\"APIRemovedInNextEUSReleaseInUse\")]' &lt; alerts.json\n</code></pre></p>"},{"location":"OpenShift%20Castle/69_deprecated_and_removed_features/#explicit-acknowledgment-before-cluster-updates","title":"Explicit Acknowledgment Before Cluster Updates","text":"<p>Before the kingdom can adopt new laws (cluster updates), administrators must acknowledge deprecated APIs. This acknowledgment is necessary to ensure that all components using outdated APIs are migrated to the new versions, preventing disruptions during the transition.</p> <p>To provide a manual acknowledgment, use the following command: <pre><code>oc patch configmap admin-acks -n openshift-config --type=merge --patch '{\"data\":{\"ack-4.11-kube-1.25-api-removals-in-4.12\":\"true\"}}'\n</code></pre></p> <p>This process ensures that the council (administrators) is aware of the changes and has taken the necessary steps to update the kingdom\u2019s practices (API usage).</p>"},{"location":"OpenShift%20Castle/69_deprecated_and_removed_features/#conclusion","title":"Conclusion","text":"<p>Managing deprecated and removed features in OpenShift is like ensuring that the kingdom\u2019s laws and customs remain relevant and effective. By monitoring alerts for deprecated APIs and providing explicit acknowledgments before updates, administrators can maintain a secure and efficient OpenShift environment. Staying informed and proactive in handling these changes will ensure the continued prosperity of the Kubernetes kingdom.</p>"},{"location":"OpenShift%20Castle/70_operator_updates/","title":"Operator Updates","text":""},{"location":"OpenShift%20Castle/70_operator_updates/#objective","title":"Objective","text":"<p>Help cluster administrators define and manage operator update policies to ensure the cluster remains functional and up-to-date with bug fixes and new features.</p>"},{"location":"OpenShift%20Castle/70_operator_updates/#introduction","title":"Introduction","text":"<p>In the grand kingdom of OpenShift, operators are like the skilled artisans who maintain and enhance the castle\u2019s various systems. These artisans, whether they be blacksmiths, masons, or engineers, play a crucial role in ensuring the castle remains fortified and efficient. Keeping these operators updated is essential for the smooth functioning of the cluster. OpenShift provides several tools to help administrators manage operator updates effectively, ensuring that the castle remains secure and operational.</p>"},{"location":"OpenShift%20Castle/70_operator_updates/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to an OpenShift cluster.</li> <li>Familiarity with Operator Lifecycle Manager (OLM) and operator management.</li> <li>Administrative privileges to manage operator updates and policies.</li> </ul>"},{"location":"OpenShift%20Castle/70_operator_updates/#defining-operator-update-policies","title":"Defining Operator Update Policies","text":""},{"location":"OpenShift%20Castle/70_operator_updates/#automatic-and-manual-updates","title":"Automatic and Manual Updates","text":"<p>When new techniques or tools are discovered in the kingdom, the master artisans need to decide whether to implement these changes immediately or wait for royal approval. Similarly, when installing an operator, administrators can choose whether updates should be applied automatically by the OLM or require manual approval.</p> <p>The <code>installPlanApproval</code> property in the resource specification dictates this behavior, accepting either <code>Automatic</code> or <code>Manual</code> values. To manage updates from the web console, navigate to Operators &gt; Installed Operators.</p> <p>To retrieve information about subscription resources and install plans, use: <pre><code>oc get sub -n openshift-operators web-terminal -o yaml\n</code></pre></p> <p>If the operator channel has a newer version, the OLM creates an install plan resource, much like a master plan crafted by the kingdom's engineers. For example: <pre><code>oc get installplan -n openshift-operators install-72vnw -o yaml\n</code></pre></p> <p>To approve an update manually, edit the install plan to change the <code>approved</code> key to <code>true</code>: <pre><code>oc patch installplan install-72vnw --type merge --patch '{\"spec\":{\"approved\":true}}'\n</code></pre></p>"},{"location":"OpenShift%20Castle/70_operator_updates/#operator-channels-and-custom-catalogs","title":"Operator Channels and Custom Catalogs","text":"<p>Operator providers can create multiple channels for an operator, much like different guilds that follow distinct practices and update schedules. Administrators can choose which channel to follow based on their update policies, ensuring the castle's operations align with their strategic plans. Additionally, custom catalogs can be created to include specific versions of operators, offering more control over the updates.</p>"},{"location":"OpenShift%20Castle/70_operator_updates/#integrating-operator-updates-with-cluster-updates","title":"Integrating Operator Updates with Cluster Updates","text":"<p>Before updating the entire kingdom\u2019s infrastructure, it\u2019s essential to review and apply any operator updates required for compatibility. This step ensures that all artisans are ready to support the new changes decreed by the royal council.</p> <p>If no compatible operator updates are available, uninstalling incompatible operators might be necessary. This is akin to retiring outdated guilds that can no longer serve the kingdom\u2019s needs. Operators can be uninstalled from the web console under Operators &gt; Installed Operators, or by deleting the subscription and cluster service versions using the <code>oc</code> command.</p> <p>Uninstalling an operator can leave remnants on the cluster, similar to abandoned workshops and tools. Always consult the operator documentation for any cleanup processes to ensure complete removal.</p>"},{"location":"OpenShift%20Castle/70_operator_updates/#example-commands","title":"Example Commands","text":"<p>Here are some practical examples to guide administrators in managing operator updates:</p> <ol> <li> <p>Retrieve Subscription Details:     <pre><code>oc get sub -n openshift-operators web-terminal -o yaml\n</code></pre></p> </li> <li> <p>View Install Plans:     <pre><code>oc get installplan -n openshift-operators install-72vnw -o yaml\n</code></pre></p> </li> <li> <p>Approve an Install Plan:     <pre><code>oc patch installplan install-72vnw --type merge --patch '{\"spec\":{\"approved\":true}}'\n</code></pre></p> </li> <li> <p>Uninstall an Operator:     <pre><code>oc delete sub -n openshift-operators web-terminal\noc delete csv -n openshift-operators web-terminal.v1.0.0\n</code></pre></p> </li> </ol>"},{"location":"OpenShift%20Castle/70_operator_updates/#conclusion","title":"Conclusion","text":"<p>Managing operator updates is crucial for maintaining a healthy and functional OpenShift cluster. By defining clear update policies and integrating them with overall cluster maintenance, administrators can ensure that their Kubernetes kingdom remains robust and up-to-date. Staying proactive with operator updates will keep the castle running smoothly and efficiently, ready to tackle any challenges that arise. Just as a well-maintained castle withstands the test of time, a well-managed OpenShift cluster can handle the ever-evolving landscape of technology and innovation.</p>"},{"location":"WorkFlows/01_local_jenkins_openid/","title":"Local Jenkins OpenId test - Login in Jenkins with Azure Entra Id","text":""},{"location":"WorkFlows/01_local_jenkins_openid/#objective","title":"Objective","text":"<p>Setting up a local Jenkins instance with OpenID Connect authentication using Docker containers. </p>"},{"location":"WorkFlows/01_local_jenkins_openid/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Docker</li> </ul>"},{"location":"WorkFlows/01_local_jenkins_openid/#story-time","title":"Story Time","text":"<p>In a bustling coral reef community, a cozy new workshop was being built by a Docker whale, where Jenkins, a diligent fish butler, would soon begin his work. One of their main concerns was securing the workshop by fitting a new lock on the front door.</p>"},{"location":"WorkFlows/01_local_jenkins_openid/#start-jenkins-as-container","title":"Start Jenkins as container","text":"<p>The fish and the whale began by setting up a cozy corner in their neighborhood. They needed to bring their workshop to life, so Jenkins could cheerfully go about his duties, much like a diligent housekeeper.</p>"},{"location":"WorkFlows/01_local_jenkins_openid/#1-create-a-docker-network","title":"1. Create a Docker network","text":"<p>Docker and Jenkins decided to start by laying down pathways in their neighborhood, they established a connection.</p> <p>Open a terminal window and create a bridge network in Docker:</p> <pre><code>docker network create jenkins\n</code></pre>"},{"location":"WorkFlows/01_local_jenkins_openid/#2-run-jenkins-docker-image","title":"2. Run Jenkins Docker image","text":"<p>With the network in place, they proceed to welcome the new inhabitant to their underwater community.</p> <p>Execute the following command to run the Docker image for Jenkins:</p> <pre><code>docker run \\\n  --name jenkins-docker \\\n  --rm \\\n  --detach \\\n  --privileged \\\n  --network jenkins \\\n  --network-alias docker \\\n  --env DOCKER_TLS_CERTDIR=/certs \\\n  --volume jenkins-docker-certs:/certs/client \\\n  --volume jenkins-data:/var/jenkins_home \\\n  --publish 2376:2376 \\\n  docker:dind \\\n  --storage-driver overlay2\n</code></pre>"},{"location":"WorkFlows/01_local_jenkins_openid/#3-create-dockerfile-for-custom-jenkins-image","title":"3. Create Dockerfile for custom Jenkins image","text":"<p>Docker and Jenkins started by drafting a custom blueprint for their workshop. In this plan, they included all the necessary components to make their workshop unique.</p> <p>Create a file named 'Dockerfile' and add the following content:</p> Dockerfile<pre><code>FROM jenkins/jenkins:2.440.3-jdk17\nUSER root\nRUN apt-get update &amp;&amp; apt-get install -y lsb-release\nRUN curl -fsSLo /usr/share/keyrings/docker-archive-keyring.asc \\\n  https://download.docker.com/linux/debian/gpg\nRUN echo \"deb [arch=$(dpkg --print-architecture) \\\n  signed-by=/usr/share/keyrings/docker-archive-keyring.asc] \\\n  https://download.docker.com/linux/debian \\\n  $(lsb_release -cs) stable\" &gt; /etc/apt/sources.list.d/docker.list\nRUN apt-get update &amp;&amp; apt-get install -y docker-ce-cli\nUSER jenkins\nRUN jenkins-plugin-cli --plugins \"blueocean docker-workflow\"\n</code></pre>"},{"location":"WorkFlows/01_local_jenkins_openid/#4-build-and-run-custom-jenkins-image","title":"4. Build and run custom Jenkins image","text":"<p>With the blueprint ready, Docker fired up and built a fresh workshop image from scratch. Jenkins watched eagerly as their creation took shape.</p> <p>Build a new Docker image from the Dockerfile:</p> <pre><code>docker build -t myjenkins-blueocean:2.440.3-1 .\n</code></pre> <p>Run the custom Jenkins image as a container:</p> <pre><code>docker run \\\n  --name jenkins-blueocean \\\n  --restart=on-failure \\\n  --detach \\\n  --network jenkins \\\n  --env DOCKER_HOST=tcp://docker:2376 \\\n  --env DOCKER_CERT_PATH=/certs/client \\\n  --env DOCKER_TLS_VERIFY=1 \\\n  --publish 8080:8080 \\\n  --publish 50000:50000 \\\n  --volume jenkins-data:/var/jenkins_home \\\n  --volume jenkins-docker-certs:/certs/client:ro \\\n  myjenkins-blueocean:2.440.3-1\n</code></pre>"},{"location":"WorkFlows/01_local_jenkins_openid/#5-access-jenkins","title":"5. Access Jenkins","text":"<p>As the sunlight filtered through the water, Docker and Jenkins admired their handiwork as their workshop came to life, accessible with a flick of a fin. They retrieved the workshop keys from their treasure chest and unlocked the door to their new workspace.</p> <p>Jenkins is now accessible at http://localhost:8080/. Retrieve the initial password from the container logs using:</p> <pre><code>docker ps\ndocker logs -f &lt;container_name&gt;\n</code></pre>"},{"location":"WorkFlows/01_local_jenkins_openid/#install-plugins","title":"Install plugins","text":"<p>Eager to enhance their workspace, Docker and Jenkins dove into a trove of plugins, much like searching for new tools in a reef. They carefully selected the ones that would streamline their workflow and improve productivity.</p> <p>These steps include the process to setup the login configuration as code. You can skip the \"Configuration as Code\" installation and still have a working login setup through interface.</p>"},{"location":"WorkFlows/01_local_jenkins_openid/#through-gui","title":"Through GUI","text":"<ol> <li>Connect to http://localhost:8080/.</li> <li>Use the password retrieved earlier to login.</li> <li>Navigate to Dashboard -&gt; Manage Jenkins -&gt; Manage Plugins -&gt; Available.</li> <li>Search and install \"Configuration as Code\" and \"OpenId Connect Authentication\".</li> </ol> <p>Keep the last page open, so you can restart Jenkins later.</p>"},{"location":"WorkFlows/01_local_jenkins_openid/#through-cli","title":"Through CLI","text":"<ol> <li>Get into the Jenkins container shell:</li> </ol> <pre><code>docker ps\ndocker exec -it &lt;container_name&gt; bash\n</code></pre> <ol> <li>Inside the shell, install plugins:</li> </ol> <pre><code>jenkins-plugin-cli --plugins oic-auth:4.257.v5360e8489e8b_\njenkins-plugin-cli --plugins configuration-as-code:1775.v810dc950b_514\n</code></pre> <ol> <li>Restart Jenkins from the plugin installation section if needed.</li> </ol>"},{"location":"WorkFlows/01_local_jenkins_openid/#setup-app-registration","title":"Setup App registration","text":"<p>In the bustling reef marketplace, Docker and Jenkins registered their workshop as an official establishment. They filled out the necessary forms and secured access for themselves and their trusted collaborators.</p> <ol> <li>Login to Azure Portal. You need to have the necessary permissions, like Application Developer.</li> <li>Navigate to App registrations and create a new app, name it something appropriate, like 'jenkins-oauth-sandbox'.</li> <li>In Authentication menu add Redirect URIs: <code>http://localhost:8080/securityRealm/finishLogin</code>.</li> <li>In Certificate &amp; secrets create a new client secret, add a name like 'oauth' and save its value securely.</li> <li>In Owners, 'Add owners', add all the users that will be able to authenticate. </li> </ol>"},{"location":"WorkFlows/01_local_jenkins_openid/#get-data","title":"Get data","text":"<p>Armed with the necessary information, Docker and Jenkins swam through the reef to collect tokens and secrets for access. They made sure to keep everything organized in their treasure trove.</p> <p>Collect the following parameters for the OpenID Connect plugin configuration (not all of them mandatory, but you can easily get them):</p> <ul> <li> <p>tokenServerUrl: https://login.microsoftonline.com/123456a7-xxx-xxx-xxx-xxxx/oauth2/v2.0/token In Overview -&gt; Endpoints it's 'OAuth 2.0 authorization endpoint (v2)'.</p> </li> <li> <p>authorizationServerUrl: https://login.microsoftonline.com/987654b3-xxx-xxx-xxx-xxxx/oauth2/v2.0/authorize In Overview -&gt; Endpoints it's 'OAuth 2.0 authorization endpoint (v2)'In Overview -&gt; Endpoints It's 'OAuth 2.0 token endpoint (v2)'.</p> </li> <li> <p>clientId: 12345-xxx-xxx-xxx-xxxx In Overview it's 'Application (client) ID'.</p> </li> <li> <p>clientSecret: 12345~a-xxx-xxx-xxxx It's the secret you copied earlier from Certificate &amp; secrets.</p> </li> <li> <p>userNameField: preferred_username default value, copy exactly this.</p> </li> <li> <p>fullNameFieldName: name default value, copy exactly this.</p> </li> <li> <p>emailFieldName: email default value, copy exactly this.</p> </li> <li> <p>scopes: openid email profile default value, copy exactly this.</p> </li> </ul>"},{"location":"WorkFlows/01_local_jenkins_openid/#manual-setup-jenkins","title":"Manual Setup Jenkins","text":"<p>With their paperwork in order, Docker and Jenkins dove into the settings of their workshop. They adjusted security settings and user permissions to ensure everything ran smoothly.</p> <ol> <li>Go to Dashboard -&gt; Manage Jenkins -&gt; Security.</li> <li>Select Security Realm as Login with OpenID Connect.</li> <li>Configure with Manual configuration and adjust Advanced options.</li> </ol>"},{"location":"WorkFlows/01_local_jenkins_openid/#optional-add-escape-hatch","title":"Optional: Add escape hatch","text":"<p>For added security, Docker and Jenkins installed an emergency escape tunnel, much like building a secret passage in their workshop. This provided a safe retreat in case access to their workshop was ever temporarily disrupted.</p> <p>To access through 'escape hatch' you must add /login, so go to http://localhost:8080/login .</p> <p>You can configure the option Dashboard -&gt; Manage Jenkis -&gt; Security</p> <p>Selecting Security Realm as Login with Openid Connect and going into detail with Manual configuration, Advanced, and Configure 'escape hatch' for when the OpenID Provider is unavailable.</p> <p>Then you activate the option from the interface and insert the credentials to login with.</p>"},{"location":"WorkFlows/01_local_jenkins_openid/#optional-configure-jenkins-using-configuration-as-code","title":"Optional: Configure Jenkins Using Configuration as Code","text":"<p>In a final touch, Docker and Jenkins decided to automate their setup for their eventual future workshop. They codified their settings, ensuring consistency and ease of management.</p> <ol> <li> <p>Navigate to Dashboard -&gt; Manage Jenkins -&gt; Configuration as Code.</p> </li> <li> <p>Click on the Download configuration button to retrieve the current configuration in YAML format.</p> </li> <li> <p>Open the downloaded <code>jenkins.yaml</code> file and locate the <code>jenkins.securityRealm.local</code> section.</p> </li> <li> <p>Replace <code>jenkins.securityRealm.local</code> with <code>jenkins.securityRealm.oic</code> and insert the following configuration:</p> <p><pre><code>jenkins:\n  securityRealm:\n    oic:\n      authorizationServerUrl: https://login.microsoftonline.com/987654b3-xxx-xxx-xxx-xxxx/oauth2/v2.0/authorize\n      clientId: 12345-xxx-xxx-xxx-xxxx\n      clientSecret: 12345~a-xxx-xxx-xxxx\n      userNameField: preferred_username\n      fullNameFieldName: name\n      emailFieldName: email\n      scopes: openid email profile\n      tokenServerUrl: https://login.microsoftonline.com/123456a7-xxx-xxx-xxx-xxxx/oauth2/v2.0/token\n      escapeHatchEnabled: true\n      escapeHatchGroup: ''\n      escapeHatchSecret: password\n      escapeHatchUsername: test\n</code></pre> e.g: jenkins.yaml<pre><code>jenkins:\n  agentProtocols:\n  - \"JNLP4-connect\"\n  - \"Ping\"\n  authorizationStrategy:\n    loggedInUsersCanDoAnything:\n      allowAnonymousRead: false\n  crumbIssuer:\n    standard:\n      excludeClientIPFromCrumb: false\n  disableRememberMe: false\n  labelAtoms:\n  - name: \"built-in\"\n  markupFormatter: \"plainText\"\n  mode: NORMAL\n  myViewsTabBar: \"standard\"\n  nodeMonitors:\n  - \"architecture\"\n  - \"clock\"\n  - diskSpace:\n      freeSpaceThreshold: \"1GiB\"\n      freeSpaceWarningThreshold: \"2GiB\"\n  - \"swapSpace\"\n  - tmpSpace:\n      freeSpaceThreshold: \"1GiB\"\n      freeSpaceWarningThreshold: \"2GiB\"\n  - \"responseTime\"\n  numExecutors: 2\n  primaryView:\n    all:\n      name: \"all\"\n  projectNamingStrategy: \"standard\"\n  quietPeriod: 5\n  remotingSecurity:\n    enabled: true\n  scmCheckoutRetryCount: 0\n  securityRealm:\n    local:\n      allowsSignup: false\n      enableCaptcha: false\n      users:\n      - id: \"admin\"\n        name: \"admin\"\n        properties:\n        - \"apiToken\"\n        - \"consoleUrlProvider\"\n        - \"mailer\"\n        - \"myView\"\n        - preferredProvider:\n            providerId: \"default\"\n        - \"timezone\"\n        - \"experimentalFlags\"\n        - \"favorite\"\n  slaveAgentPort: 50000\n  updateCenter:\n    sites:\n    - id: \"default\"\n      url: \"https://updates.jenkins.io/update-center.json\"\n  views:\n  - all:\n      name: \"all\"\n  viewsTabBar: \"standard\"\nglobalCredentialsConfiguration:\n  configuration:\n    providerFilter: \"none\"\n    typeFilter: \"none\"\nappearance:\n  prism:\n    theme: PRISM\nsecurity:\n  apiToken:\n    creationOfLegacyTokenEnabled: false\n    tokenGenerationOnCreationEnabled: false\n    usageStatisticsEnabled: true\n  gitHooks:\n    allowedOnAgents: false\n    allowedOnController: false\n  gitHostKeyVerificationConfiguration:\n    sshHostKeyVerificationStrategy: \"knownHostsFileVerificationStrategy\"\nunclassified:\n  bitbucketEndpointConfiguration:\n    endpoints:\n    - bitbucketCloudEndpoint:\n        enableCache: false\n        manageHooks: false\n        repositoriesCacheDuration: 0\n        teamCacheDuration: 0\n  buildDiscarders:\n    configuredBuildDiscarders:\n    - \"jobBuildDiscarder\"\n  fingerprints:\n    fingerprintCleanupDisabled: false\n    storage: \"file\"\n  gitHubConfiguration:\n    apiRateLimitChecker: ThrottleForNormalize\n  gitHubPluginConfig:\n    hookUrl: \"http://localhost:8080/github-webhook/\"\n  junitTestResultStorage:\n    storage: \"file\"\n  location:\n    adminAddress: \"address not configured yet &lt;nobody@nowhere&gt;\"\n  mailer:\n    charset: \"UTF-8\"\n    useSsl: false\n    useTls: false\n  pollSCM:\n    pollingThreadCount: 10\n  scmGit:\n    addGitTagAction: false\n    allowSecondFetch: false\n    createAccountBasedOnEmail: false\n    disableGitToolChooser: false\n    hideCredentials: false\n    showEntireCommitSummaryInChanges: false\n    useExistingAccountWithSameEmail: false\n  timestamper:\n    allPipelines: false\n    elapsedTimeFormat: \"'&lt;b&gt;'HH:mm:ss.S'&lt;/b&gt; '\"\n    systemTimeFormat: \"'&lt;b&gt;'HH:mm:ss'&lt;/b&gt; '\"\ntool:\n  git:\n    installations:\n    - home: \"git\"\n      name: \"Default\"\n  mavenGlobalConfig:\n    globalSettingsProvider: \"standard\"\n    settingsProvider: \"standard\"\n</code></pre> becomes: updated-jenkins.yaml<pre><code>jenkins:\n  agentProtocols:\n  - \"JNLP4-connect\"\n  - \"Ping\"\n  authorizationStrategy:\n    loggedInUsersCanDoAnything:\n      allowAnonymousRead: false\n  crumbIssuer:\n    standard:\n      excludeClientIPFromCrumb: false\n  disableRememberMe: false\n  labelAtoms:\n  - name: \"built-in\"\n  markupFormatter: \"plainText\"\n  mode: NORMAL\n  myViewsTabBar: \"standard\"\n  nodeMonitors:\n  - \"architecture\"\n  - \"clock\"\n  - diskSpace:\n      freeSpaceThreshold: \"1GiB\"\n      freeSpaceWarningThreshold: \"2GiB\"\n  - \"swapSpace\"\n  - tmpSpace:\n      freeSpaceThreshold: \"1GiB\"\n      freeSpaceWarningThreshold: \"2GiB\"\n  - \"responseTime\"\n  numExecutors: 2\n  primaryView:\n    all:\n      name: \"all\"\n  projectNamingStrategy: \"standard\"\n  quietPeriod: 5\n  remotingSecurity:\n    enabled: true\n  scmCheckoutRetryCount: 0\n  securityRealm:\n    oic:\n      authorizationServerUrl: https://login.microsoftonline.com/987654b3-xxx-xxx-xxx-xxxx/oauth2/v2.0/authorize\n      clientId: 12345-xxx-xxx-xxx-xxxx\n      clientSecret: 12345~a-xxx-xxx-xxxx\n      userNameField: preferred_username\n      fullNameFieldName: name\n      emailFieldName: email\n      scopes: openid email profile\n      tokenServerUrl: https://login.microsoftonline.com/123456a7-xxx-xxx-xxx-xxxx/oauth2/v2.0/token\n      escapeHatchEnabled: true\n      escapeHatchGroup: ''\n      escapeHatchSecret: password\n      escapeHatchUsername: test\n  slaveAgentPort: 50000\n  updateCenter:\n    sites:\n    - id: \"default\"\n      url: \"https://updates.jenkins.io/update-center.json\"\n  views:\n  - all:\n      name: \"all\"\n  viewsTabBar: \"standard\"\nglobalCredentialsConfiguration:\n  configuration:\n    providerFilter: \"none\"\n    typeFilter: \"none\"\nappearance:\n  prism:\n    theme: PRISM\nsecurity:\n  apiToken:\n    creationOfLegacyTokenEnabled: false\n    tokenGenerationOnCreationEnabled: false\n    usageStatisticsEnabled: true\n  gitHooks:\n    allowedOnAgents: false\n    allowedOnController: false\n  gitHostKeyVerificationConfiguration:\n    sshHostKeyVerificationStrategy: \"knownHostsFileVerificationStrategy\"\nunclassified:\n  bitbucketEndpointConfiguration:\n    endpoints:\n    - bitbucketCloudEndpoint:\n        enableCache: false\n        manageHooks: false\n        repositoriesCacheDuration: 0\n        teamCacheDuration: 0\n  buildDiscarders:\n    configuredBuildDiscarders:\n    - \"jobBuildDiscarder\"\n  fingerprints:\n    fingerprintCleanupDisabled: false\n    storage: \"file\"\n  gitHubConfiguration:\n    apiRateLimitChecker: ThrottleForNormalize\n  gitHubPluginConfig:\n    hookUrl: \"http://localhost:8080/github-webhook/\"\n  junitTestResultStorage:\n    storage: \"file\"\n  location:\n    adminAddress: \"address not configured yet &lt;nobody@nowhere&gt;\"\n  mailer:\n    charset: \"UTF-8\"\n    useSsl: false\n    useTls: false\n  pollSCM:\n    pollingThreadCount: 10\n  scmGit:\n    addGitTagAction: false\n    allowSecondFetch: false\n    createAccountBasedOnEmail: false\n    disableGitToolChooser: false\n    hideCredentials: false\n    showEntireCommitSummaryInChanges: false\n    useExistingAccountWithSameEmail: false\n  timestamper:\n    allPipelines: false\n    elapsedTimeFormat: \"'&lt;b&gt;'HH:mm:ss.S'&lt;/b&gt; '\"\n    systemTimeFormat: \"'&lt;b&gt;'HH:mm:ss'&lt;/b&gt; '\"\ntool:\n  git:\n    installations:\n    - home: \"git\"\n      name: \"Default\"\n  mavenGlobalConfig:\n    globalSettingsProvider: \"standard\"\n    settingsProvider: \"standard\"\n</code></pre></p> </li> <li> <p>Save the changes and close the file.</p> </li> <li> <p>Connect to the Jenkins Docker container's shell:</p> <pre><code>docker ps\ndocker exec -it &lt;container_name&gt; bash\n</code></pre> </li> <li> <p>In the Docker container shell, navigate to the home directory:</p> <pre><code>cd\npwd\n</code></pre> </li> <li> <p>Create a new file named <code>conf.yaml</code> and paste the content of the updated <code>jenkins.yaml</code> file into it(you may need to escape with '\\' the '&lt;''&gt;' characters in the date format). From command line you use the commands:</p> <pre><code>echo '&lt;updated-jenkinsfile.yaml_content&gt;' &gt; conf.yaml\n</code></pre> <p>e.g.:</p> <pre><code>echo 'jenkins:\n  agentProtocols:\n  - \"JNLP4-connect\"\n  - \"Ping\"\n  authorizationStrategy:\n    loggedInUsersCanDoAnything:\n      allowAnonymousRead: false\n  crumbIssuer:\n    standard:\n      excludeClientIPFromCrumb: false\n  disableRememberMe: false\n  labelAtoms:\n  - name: \"built-in\"\n  markupFormatter: \"plainText\"\n  mode: NORMAL\n  myViewsTabBar: \"standard\"\n  nodeMonitors:\n  - \"architecture\"\n  - \"clock\"\n  - diskSpace:\n      freeSpaceThreshold: \"1GiB\"\n      freeSpaceWarningThreshold: \"2GiB\"\n  - \"swapSpace\"\n  - tmpSpace:\n      freeSpaceThreshold: \"1GiB\"\n      freeSpaceWarningThreshold: \"2GiB\"\n  - \"responseTime\"\n  numExecutors: 2\n  primaryView:\n    all:\n      name: \"all\"\n  projectNamingStrategy: \"standard\"\n  quietPeriod: 5\n  remotingSecurity:\n    enabled: true\n  scmCheckoutRetryCount: 0\n  securityRealm:\n    oic:\n      authorizationServerUrl: https://login.microsoftonline.com/987654b3-xxx-xxx-xxx-xxxx/oauth2/v2.0/authorize\n      clientId: 12345-xxx-xxx-xxx-xxxx\n      clientSecret: 12345~a-xxx-xxx-xxxx\n      userNameField: preferred_username\n      fullNameFieldName: name\n      emailFieldName: email\n      scopes: openid email profile\n      tokenServerUrl: https://login.microsoftonline.com/123456a7-xxx-xxx-xxx-xxxx/oauth2/v2.0/token\n      escapeHatchEnabled: true\n      escapeHatchGroup: ''\n      escapeHatchSecret: password\n      escapeHatchUsername: test\n  slaveAgentPort: 50000\n  updateCenter:\n    sites:\n    - id: \"default\"\n      url: \"https://updates.jenkins.io/update-center.json\"\n  views:\n  - all:\n      name: \"all\"\n  viewsTabBar: \"standard\"\nglobalCredentialsConfiguration:\n  configuration:\n    providerFilter: \"none\"\n    typeFilter: \"none\"\nappearance:\n  prism:\n    theme: PRISM\nsecurity:\n  apiToken:\n    creationOfLegacyTokenEnabled: false\n    tokenGenerationOnCreationEnabled: false\n    usageStatisticsEnabled: true\n  gitHooks:\n    allowedOnAgents: false\n    allowedOnController: false\n  gitHostKeyVerificationConfiguration:\n    sshHostKeyVerificationStrategy: \"knownHostsFileVerificationStrategy\"\nunclassified:\n  bitbucketEndpointConfiguration:\n    endpoints:\n    - bitbucketCloudEndpoint:\n        enableCache: false\n        manageHooks: false\n        repositoriesCacheDuration: 0\n        teamCacheDuration: 0\n  buildDiscarders:\n    configuredBuildDiscarders:\n    - \"jobBuildDiscarder\"\n  fingerprints:\n    fingerprintCleanupDisabled: false\n    storage: \"file\"\n  gitHubConfiguration:\n    apiRateLimitChecker: ThrottleForNormalize\n  gitHubPluginConfig:\n    hookUrl: \"http://localhost:8080/github-webhook/\"\n  junitTestResultStorage:\n    storage: \"file\"\n  location:\n    adminAddress: \"address not configured yet &lt;nobody@nowhere&gt;\"\n  mailer:\n    charset: \"UTF-8\"\n    useSsl: false\n    useTls: false\n  pollSCM:\n    pollingThreadCount: 10\n  scmGit:\n    addGitTagAction: false\n    allowSecondFetch: false\n    createAccountBasedOnEmail: false\n    disableGitToolChooser: false\n    hideCredentials: false\n    showEntireCommitSummaryInChanges: false\n    useExistingAccountWithSameEmail: false\n  timestamper:\n    allPipelines: false\n    elapsedTimeFormat: \"'\\&lt;b\\&gt;'HH:mm:ss.S'\\&lt;/b\\&gt; '\"\n    systemTimeFormat: \"'\\&lt;b\\&gt;'HH:mm:ss'\\&lt;/b\\&gt; '\"\ntool:\n  git:\n    installations:\n    - home: \"git\"\n      name: \"Default\"\n  mavenGlobalConfig:\n    globalSettingsProvider: \"standard\"\n    settingsProvider: \"standard\"' &gt; conf.yaml\n</code></pre> </li> <li> <p>Once <code>conf.yaml</code> is created, exit the Docker container shell.</p> </li> <li> <p>Return to http://localhost:8080/manage/configuration-as-code/.</p> </li> <li> <p>In the Path or URL field, enter:</p> <pre><code>/var/jenkins_home/conf.yaml\n</code></pre> </li> <li> <p>Click Apply new configuration to update Jenkins with the new configuration.</p> </li> </ol> <p>With their workshop now revamped and secured, Docker and Jenkins floated contentedly, ready to tackle their projects with renewed energy and efficiency.</p>"}]}